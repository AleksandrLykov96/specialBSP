// @strict-types

//@skip-check method-too-many-params
//@skip-check doc-comment-ref-link

#Область ПрограммныйИнтерфейс

// Формирует и выводит сообщение, которое может быть связано с элементом управления формы.
//
// См. Спец_ОбщегоНазначения.СообщитьПользователю
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных - ЛюбаяСсылка, Неопределено - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле - Строка, Неопределено - наименование реквизита формы.
//  ПутьКДанным - Строка, Неопределено - путь к данным (путь к реквизиту формы).
//  Отказ - Булево - выходной параметр, всегда устанавливается в значение Истина.
//  ИдентификаторНазначения - Неопределено, УникальныйИдентификатор - Уникальный идентификатор назначения сообщения
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимого.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(Знач ТекстСообщенияПользователю, Знач КлючДанных = Неопределено, Знач Поле = "", Знач ПутьКДанным = "", Отказ = Ложь, Знач ИдентификаторНазначения = Неопределено) Экспорт
	
	#Если Клиент Тогда
		Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(ТекстСообщенияПользователю, КлючДанных, Поле, ПутьКДанным, Отказ, ИдентификаторНазначения);
	#Иначе
		Спец_ОбщегоНазначения.СообщитьПользователю(ТекстСообщенияПользователю, КлючДанных, Поле, ПутьКДанным, Отказ, ИдентификаторНазначения);
	#КонецЕсли
	
КонецПроцедуры

// Добавляем подробный текст ошибки в общий текст ошибок.
// 
// Параметры:
//  ТекстОшибкиИлиИнформацияОбОшибке - Строка, ИнформацияОбОшибке - Текст ошибки или информация об ошибке
//  ИмяПроцедуры - Строка - Имя процедуры (источник ошибки)
//  ОбщийТекстОшибок - Строка - Общий текст ошибок, куда будет добавлен подробный текст ошибки
//  Отказ - Булево - Флаг отказа
//  ЗаписатьЛогОшибки - Булево - Флаг того, что данную ошибку нужно записать в логи
//
Процедура ДобавитьОшибку(Знач ТекстОшибкиИлиИнформацияОбОшибке = "", Знач ИмяПроцедуры = "", ОбщийТекстОшибок = "", Отказ = Ложь, Знач ЗаписатьЛогОшибки = Истина) Экспорт
	
	ТекстОшибкиДляЗаписи = ?(ТипЗнч(ТекстОшибкиИлиИнформацияОбОшибке) = Тип("ИнформацияОбОшибке"),
			ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ТекстОшибкиИлиИнформацияОбОшибке),
			СокрЛП(ТекстОшибкиИлиИнформацияОбОшибке));
	
	Если ПустаяСтрока(ТекстОшибкиДляЗаписи) Тогда Возврат; КонецЕсли;
	
	МассивШаблонОшибки    = Новый Массив; // Массив из Строка
	ИмяПользователяКлиент = ТекущийПользовательСистемы(Истина);
	Если ПустаяСтрока(ИмяПользователяКлиент) Тогда
		ИмяПользователяКлиент = ТекущийПользовательСистемы(Истина);
	КонецЕсли;
	
	ОСКлиент = Строка(Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаКлиент")); // Строка
	ОССервер = Строка(Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаСервер")); // Строка
	
	// Может быть ошибка в транзакции, поэтому через попытку
	Попытка
		СтруктураПараметровБазы = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы();
	Исключение
		СтруктураПараметровБазы = Новый ФиксированнаяСтруктура(НоваяСтруктураПараметровБазы());
	КонецПопытки;
	
	Если Не ПустаяСтрока(ИмяПроцедуры) Тогда
		
		МассивШаблонОшибки.Добавить(
				
				"Ошибка из / при выполнении: ""[ИмяПроцедуры]""
				|	
				|	Текст ошибки:
				|[ТекстОшибки]");
		
		ТекстОшибкиДляЗаписи = Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(ТекстОшибкиДляЗаписи, Символы.Таб + Символы.Таб);
		
		Если ЗаписатьЛогОшибки Тогда
			
			Спец_ЗаписатьЛог(ИмяПроцедуры,
					ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Ошибка"),
					ТекстОшибкиДляЗаписи);
			
		КонецЕсли;
		
	Иначе
		
		МассивШаблонОшибки.Добавить("[ТекстОшибки]");
		
	КонецЕсли;
	
	МассивШаблонОшибки.Добавить(
			
			"	Информация о базе/пользователе:
			|		Наименование базы: [База]
			|		Адрес базы: [АдресБазы]
			|		Имя базы: [ИмяБазы]
			|		Вид базы: [ВидБазы]
			|		Тип БД: [ТипБД]
			|		Время ошибки: [ВремяОшибки]
			|		Пользователь 1С: [Пользователь1С]
			|		Полные права доступны: [ПолныеПраваДоступны]
			|		Пользователь ОС (сервер): [ПользовательОССервер]
			|		Тип ОС (сервер): [ТипОССервер]");
	
	Если Не ПустаяСтрока(ИмяПользователяКлиент) Тогда // Это клиентская 1С
		
		МассивШаблонОшибки.Добавить(
				
				"		Пользователь ОС (клиент): [ПользовательОСКлиент]
				|		Тип ОС (клиент): [ТипОСКлиент]");
		
	КонецЕсли;
	
	ТекстСообщения = СтрЗаменить(СтрСоединить(МассивШаблонОшибки, Символы.ПС), "[ИмяПроцедуры]", ИмяПроцедуры);
	
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ТекстОшибки]"          , ТекстОшибкиДляЗаписи);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[База]"                 , СтруктураПараметровБазы.НаименованиеБазы);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[АдресБазы]"            , СтруктураПараметровБазы.АдресСервераИБ);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ИмяБазы]"              , СтруктураПараметровБазы.ИмяБазы);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ВидБазы]"              , Строка(СтруктураПараметровБазы.ВидБазы));
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ТипБД]"                , Строка(СтруктураПараметровБазы.ТипБазыДанных));
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ВремяОшибки]"          , Формат(ТекущаяДатаПоНормальному(), "ДЛФ=DDT"));
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[Пользователь1С]"       , ТекущийПользователь1СПолноеИмя());
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ПолныеПраваДоступны]"  , Формат(Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ЭтоПользовательСПолнымиПравами(), "БЛ=Нет; БИ=Да"));
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ПользовательОСКлиент]" , ИмяПользователяКлиент);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ТипОСКлиент]"          , ОСКлиент);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ПользовательОССервер]" , ТекущийПользовательСистемы(Ложь, Истина));
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ТипОССервер]"          , ОССервер);
	
	Спец_СтроковыеФункцииКлиентСервер.ДобавитьСтрокуВТекст(ТекстСообщения, ОбщийТекстОшибок, Символы.ПС + "	------------------------------" + Символы.ПС);
	СообщитьПользователю(СокрЛП(ТекстОшибкиДляЗаписи), , , , Отказ);
	
КонецПроцедуры

// Отправляет сообщение в Telegram (подробнее про параметры https://tlgrm.ru/docs/bots/api#sendmessage)
// 
// Параметры:
//  ТекстСообщенияДляОтправки - Строка - Текст сообщения для отправки
//  ТипПарсинга - Строка - Тип парсинга
//  ТекстОшибки - Строка - Текст ошибки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
Процедура ОтправитьСообщениеВТелеграм(Знач ТекстСообщенияДляОтправки, Знач ТипПарсинга = "", ТекстОшибки = "", Знач Кэш = Неопределено) Экспорт
	
	#Если Не ВебКлиент Тогда
		
		МассивИдентификаторовПолучателей = Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.ИдентификаторыПолучателей")); // Массив из Строка
		ИдентификаторБотаВТелеграм = Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.ИдентификаторБота"), ""); // Строка
		
		Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивИдентификаторовПолучателей);
		Если МассивИдентификаторовПолучателей.Количество() = 0 Или ПустаяСтрока(ИдентификаторБотаВТелеграм) Или ПустаяСтрока(ТекстСообщенияДляОтправки) Тогда
			Возврат;
		КонецЕсли;
		
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.HTTPClient_ПодключитьЕслиНеПодключали(Кэш);
		
		Если Кэш.КомпонентаHTTPClient <> Неопределено Тогда
			Кэш.КомпонентаHTTPClient.Timeout_ms = 5000;
		КонецЕсли;
		
		ПолныйURLЗапроса = "https://api.telegram.org/bot" + ИдентификаторБотаВТелеграм + "/sendMessage";
		Для Каждого ИдентификаторПолучателя Из МассивИдентификаторовПолучателей Цикл
			
			ЗаписьJSON = Новый ЗаписьJSON();
			ЗаписьJSON.УстановитьСтроку();
			
			ЗаписьJSON.ЗаписатьНачалоОбъекта();
			
			ЗаписатьЗначениеРеквизитаВJSON(ЗаписьJSON, "chat_id" , ИдентификаторПолучателя);
			ЗаписатьЗначениеРеквизитаВJSON(ЗаписьJSON, "text"    , ТекстСообщенияДляОтправки);
			
			Если Не ПустаяСтрока(ТипПарсинга) Тогда
				ЗаписатьЗначениеРеквизитаВJSON(ЗаписьJSON, "parse_mode", ТипПарсинга);
			КонецЕсли;
			
			ЗаписьJSON.ЗаписатьКонецОбъекта();
			
			ТелоЗапроса = ЗаписьJSON.Закрыть();
			
			СоответствиеЗаголовков = Новый Соответствие;
			СоответствиеЗаголовков["Content-Type"] = "application/json";
			
			СтруктураЗапроса = Спец_КомпонентаДополнительныеФункцииКлиентСервер.HTTPClientПолучитьСтруктуруЗапроса(ПолныйURLЗапроса,
					ИдентификаторПолучателя,
					,
					ТелоЗапроса,
					СоответствиеЗаголовков);
			
			Спец_КомпонентаДополнительныеФункцииКлиентСервер.HTTPClientЗарегистрироватьЗапросыКВыполнению(СтруктураЗапроса,
					Ложь,
					ТекстОшибки,
					Кэш);
			
		КонецЦикла;
		
		МассивРезультатов = Спец_КомпонентаДополнительныеФункцииКлиентСервер.HTTPClientПолучитьРезультатыЗарегистрированныхЗапросов(ТекстОшибки, Кэш);
		Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивРезультатов);
		
		Для Каждого СтруктураРезультат Из МассивРезультатов Цикл
			
			Если Не СтруктураРезультат.Успешно Тогда
				
				ШаблонСообщения = НСтр("ru = 'Не удалось отправить сообщение получателю ""%1""!%2%3'");
				ТекстСообщения = СтрШаблон(ШаблонСообщения, СтруктураРезультат.ИдентификаторЗапроса, Символы.ПС, СтруктураРезультат.ТелоРезультат);
				
				ДобавитьОшибку(ТекстСообщения, "Спец_ОбщегоНазначенияКлиентСервер.ОтправитьСообщениеВТелеграм(...)", ТекстОшибки);
				
			КонецЕсли;
			
		КонецЦикла;
		
	#Иначе
		
		Спец_ОбщегоНазначенияВызовСервера.ОтправитьСообщениеВТелеграм(ТекстСообщенияДляОтправки, ТипПарсинга, ТекстОшибки);
		
	#КонецЕсли
	
КонецПроцедуры

// Метод для удаления массива файлов. Если вызов с клиента, то запускает асинхронный вариант удаления файлов (НачатьУдалениеФайлов).
// 
// Параметры:
//  МассивФайловИлиИмяФайла - Строка, Массив из Строка - Массив имён файлов или имя файла
//
Процедура УдалитьФайлыНеМешаяРаботе(Знач МассивФайловИлиИмяФайла) Экспорт
	
	#Если Клиент Тогда
		
		// ++ Спец_БСП.Версия1С_18_ВышеИлиРавно
		Спец_ОбщегоНазначенияКлиент.УдалитьФайлыНеМешаяРаботеАсинх(МассивФайловИлиИмяФайла);
		// -- Спец_БСП.Версия1С_18_ВышеИлиРавно
		
		// ++ Спец_БСП.Версия1С_18_Ниже
		////Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивФайловИлиИмяФайла);
		////ОписаниеОповещения = Новый ОписаниеОповещения("ОписаниеОповещенияЗаглушкаСОднимПараметром", Спец_ОбщегоНазначенияКлиент);
		////Для Каждого ИмяФайла Из МассивФайловИлиИмяФайла Цикл Если Не ПустаяСтрока(ИмяФайла) Тогда НачатьУдалениеФайлов(ОписаниеОповещения, ИмяФайла); КонецЕсли; КонецЦикла;
		// -- Спец_БСП.Версия1С_18_Ниже
		
	#Иначе
		
		Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивФайловИлиИмяФайла);
		
		//@skip-check empty-except-statement
		Для Каждого ИмяФайла Из МассивФайловИлиИмяФайла Цикл Если Не ПустаяСтрока(ИмяФайла) Тогда Попытка УдалитьФайлы(ИмяФайла); Исключение КонецПопытки; КонецЕсли; КонецЦикла;
		
	#КонецЕсли
	
КонецПроцедуры

// Меняет 2 значения местами.
// 
// Параметры:
//  Значение1 - Произвольный
//  Значение2 - Произвольный
Процедура Swap(Значение1, Значение2) Экспорт
	
	ВременнаяПеременная = Значение1;
	Значение1           = Значение2;
	Значение2           = ВременнаяПеременная;
	
КонецПроцедуры

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//  СтрокаURI - Строка - ссылка на ресурс в формате:
//                       <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//  Структура - составные части URI согласно формату:
//   * Схема         - Строка              - схема из URI.
//   * Логин         - Строка              - логин из URI.
//   * Пароль        - Строка              - пароль из URI.
//   * ИмяСервера    - Строка              - часть <хост>:<порт> из URI.
//   * Хост          - Строка              - хост из URI.
//   * Порт          - Неопределено, Число - порт из URI.
//   * ПутьНаСервере - Строка              - часть <путь>?<параметры>#<якорь> из URI.
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтруктураРезультат = НоваяСтруктураURIСсылки();
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// схема
	Позиция = СтрНайти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		СтруктураРезультат.Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;
	
	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	Позиция = СтрНайти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		СтруктураРезультат.ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
	
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	СтруктураРезультат.ИмяСервера = СтрокаСоединения;
	Позиция = СтрНайти(СтрокаСоединения, "@", НаправлениеПоиска.СКонца);
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		СтруктураРезультат.ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	СтруктураРезультат.Логин = СтрокаАвторизации;
	Позиция = СтрНайти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		СтруктураРезультат.Логин = Лев(СтрокаАвторизации, Позиция - 1);
		СтруктураРезультат.Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	СтруктураРезультат.Хост = СтруктураРезультат.ИмяСервера;
	Позиция = СтрНайти(СтруктураРезультат.ИмяСервера, ":");
	Если Позиция > 0 Тогда
		СтруктураРезультат.Хост = Лев(СтруктураРезультат.ИмяСервера, Позиция - 1);
		
		Порт = Сред(СтруктураРезультат.ИмяСервера, Позиция + 1);
		Если Спец_СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(Порт) Тогда
			СтруктураРезультат.Порт = Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(Порт);
		КонецЕсли;
	
	КонецЕсли;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Возвращает флаг того, что сильно нагружающие базу методы лучше не запускать в текущее время.
// 
// Возвращаемое значение:
//  Булево
Функция ИдетРабочийДень() Экспорт
	
	// Всё сильно нагружающее базу убираем с рабочего времени.
	ТекущаяДата       = ТекущаяДатаПоНормальному();
	ТекущийДеньНедели = ДеньНедели(ТекущаяДата);
	
	// Конец и начало месяца целиком не трогаем
	Если НачалоДня(ТекущаяДата) = НачалоМесяца(ТекущаяДата) Или КонецДня(ТекущаяДата) = КонецМесяца(ТекущаяДата) Тогда
		
		Возврат Истина;
		
	ИначеЕсли ТекущийДеньНедели >= 1 И ТекущийДеньНедели <= 5 Тогда // Рабочая неделя
		
		ТекущийЧас = Час(ТекущаяДата);
		Возврат ТекущийЧас >= 8 И ТекущийЧас <= 20;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

// Подключает внешнюю компоненту для работы и возвращает её объект.
// 
// Параметры:
//  МестоположениеКомпоненты - Строка
//  ИмяКомпоненты - Строка
//  ИдентификаторВКомпоненте - Строка
//  СтатическоеИмя - Булево - Если ИСТИНА, то подключает компоненту из кэша рабочего процесса. В противном случае кэширует компоненту на сеанс.
//  Бесшумно - Булево - Если ИСТИНА, то никакие сообщения об ошибках не будут выведены.
// 
// Возвращаемое значение:
//  ОбъектВнешнейКомпоненты, Неопределено -
Функция ПодключитьВнешнююКомпонентуДляРаботы(Знач МестоположениеКомпоненты, Знач ИмяКомпоненты, Знач ИдентификаторВКомпоненте,
		Знач СтатическоеИмя = Истина, Знач Бесшумно = Ложь) Экспорт
	
	// Если не постоянное имя компоненты - много файлов в tmp, при 200+ одновременных подключений начинает очень сильно тормозить в функции "ПодключитьВнешнююКомпоненту".
	// Если постоянное имя компоненты - при чистке tmp (или при глюке рабочего процесса) слетает компонента, валит ошибку, которая даже с попыткой вылетает.
	//		Нужно перезапускать рабочий процесс, чтобы вернуть работоспособность.
	
	#Если Не ТонкийКлиент И Не ВебКлиент И Не ТолстыйКлиентУправляемоеПриложение Тогда
		УстановитьОтключениеБезопасногоРежима(Истина);
	#КонецЕсли
	
	Если ПустаяСтрока(МестоположениеКомпоненты) Тогда
		
		ИмяДляПодключения = СтрШаблон("AddIn.%1.%2", ИмяКомпоненты, СтрЗаменить(ИмяКомпоненты, ".", "_"));
		
		Попытка
			
			Спец_Проверить(ПодключитьВнешнююКомпоненту(ИмяКомпоненты), "Внешний драйвер не найден: " + ИмяКомпоненты);
			Результат = Новый(ИмяДляПодключения); // ОбъектВнешнейКомпоненты
			
		Исключение
			
			Если Не Бесшумно Тогда
				
				СообщитьПользователю(
						СтрШаблон("Не удалось подключить компоненту ""%1""!%2%3",
								ИмяКомпоненты,
								Символы.ПС,
								КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб)));
				
			КонецЕсли;
			
		КонецПопытки;
		
		Возврат Результат;
		
	КонецЕсли;
	
	Если ПустаяСтрока(МестоположениеКомпоненты)
		Или (Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьМассивИменМоихКомпонент().Найти(МестоположениеКомпоненты) <> Неопределено И ЭтоWine()) Тогда
		
		#Если Не ТонкийКлиент И Не ВебКлиент И Не ТолстыйКлиентУправляемоеПриложение Тогда
			УстановитьОтключениеБезопасногоРежима(Ложь);
		#КонецЕсли
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	ИмяОбъекта = ИмяКомпоненты + "_"
			+ ?(СтатическоеИмя,
					Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ПодготовитьУникальноеИмяНаВремяРаботыРабочегоПроцесса(),
					Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ПодготовитьУникальноеИмяНаВремяСеанса());
	
	ТекстОшибки = "";
	Попытка
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.ПодключитьКомпоненту(МестоположениеКомпоненты, ИмяОбъекта);
	Исключение
		ТекстОшибки = КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб);
	КонецПопытки;
	
	Если Успешно = Неопределено Тогда
		
		Если Не Бесшумно Тогда
			
			СообщитьПользователю(
					СтрШаблон("Не удалось подключить компоненту ""%1""!%2%3",
							МестоположениеКомпоненты,
							Символы.ПС,
							ТекстОшибки));
			
		КонецЕсли;
		
		Возврат Результат;
		
	КонецЕсли;
	
	// Если дошли сюда, то значит компонента либо подключилась, либо нет.
	ИмяДляПодключения = СтрШаблон("AddIn.%1.%2", ИмяОбъекта, ИдентификаторВКомпоненте);
	Если Успешно = Истина Тогда
		
		Результат = Новый(ИмяДляПодключения); // ОбъектВнешнейКомпоненты
		
		#Если Не ТонкийКлиент И Не ВебКлиент И Не ТолстыйКлиентУправляемоеПриложение Тогда
			УстановитьОтключениеБезопасногоРежима(Ложь);
		#КонецЕсли
		
		Возврат Результат;
		
	КонецЕсли;
	
	// Если не клиент - нет смысла устанавливать компоненту
	#Если ВебКлиент Или Не Клиент Тогда
		
		Если Не Бесшумно Тогда
			
			СообщитьПользователю(
					СтрШаблон("Не удалось подключить компоненту ""%1""!
							|Компонента не подключается. Проверьте, корректная ли компонента и соблюдены ли системные требования.",
							
							МестоположениеКомпоненты));
			
		КонецЕсли;
		
		#Если Не ВебКлиент Тогда
			УстановитьОтключениеБезопасногоРежима(Ложь);
		#КонецЕсли
		
		Возврат Результат;
		
	#Иначе
		
		// Устанавливаем компоненту
		Попытка
			
			//@skip-check object-deprecated
			УстановитьВнешнююКомпоненту(МестоположениеКомпоненты);
			
		Исключение
			
			Если Не Бесшумно Тогда
				
				СообщитьПользователю(
						СтрШаблон("Не удалось подключить компоненту ""%1""!%2%3",
								МестоположениеКомпоненты,
								Символы.ПС,
								КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб)));
				
			КонецЕсли;
			
			#Если Не ТонкийКлиент Тогда
				УстановитьОтключениеБезопасногоРежима(Ложь);
			#КонецЕсли
			
			Возврат Результат;
			
		КонецПопытки;
		
		// Подключаем ещё раз. Готовое имя компоненты уже сохранилось
		Попытка
			
			Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.ПодключитьКомпоненту(МестоположениеКомпоненты, ИмяОбъекта),
					"Компонента не подключается. Проверьте, корректная ли компонента и соблюдены ли системные требования.");
			
			Результат = Новый(ИмяДляПодключения); // ОбъектВнешнейКомпоненты
			
		Исключение
			
			Если Не Бесшумно Тогда
				
				СообщитьПользователю(
						СтрШаблон("Не удалось подключить компоненту ""%1""!%2%3",
								МестоположениеКомпоненты,
								Символы.ПС,
								КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб)));
				
			КонецЕсли;
			
		КонецПопытки;
		
		#Если Не ТонкийКлиент Тогда
			УстановитьОтключениеБезопасногоРежима(Ложь);
		#КонецЕсли
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

// Возвращает Истина, если функциональная подсистема существует в конфигурации.
// Предназначена для реализации вызова необязательной подсистемы (условного вызова).
// У функциональной подсистемы снят флажок "Включать в командный интерфейс".
// См. также ОбщегоНазначенияПереопределяемый.ПриОпределенииОтключенныхПодсистем
// и ОбщегоНазначенияКлиент.ПодсистемаСуществует для вызова из клиентского кода.
//
// Параметры:
//  ПолноеИмяПодсистемы - Строка - полное имя объекта метаданных подсистема
//                        без слов "Подсистема." и с учетом регистра символов.
//                        Например: "СтандартныеПодсистемы.ВариантыОтчетов".
//
// Пример:
//	Если Спец_ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("Спец_БСП.Спец_ОбменыСДругимиБазами") Тогда
//		МодульОбновлениеКонфигурации = Спец_ОбщегоНазначенияКлиентСервер.ОбщийМодуль("Спец_ОбменСДругимиБазами");
//		МодульОбновлениеКонфигурации.<Имя метода>();
//	КонецЕсли;
//
// Возвращаемое значение:
//  Булево - Истина, если подсистема существует.
Функция ПодсистемаСуществует(Знач ПолноеИмяПодсистемы) Экспорт
	
	//@skip-check unknown-method-property
	Возврат Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ИменаПодсистем().Получить(ПолноеИмяПодсистемы) <> Неопределено;
	
КонецФункции

// Возвращает ссылку на общий модуль или модуль менеджера по имени.
//
// Параметры:
//  Имя - Строка - имя общего модуля.
//
// Возвращаемое значение:
//   ОбщийМодуль
//   МодульМенеджераОбъекта
//
// Пример:
//	Если Спец_ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("Спец_БСП.Спец_ОбменыСДругимиБазами") Тогда
//		МодульОбновлениеКонфигурации = Спец_ОбщегоНазначенияКлиентСервер.ОбщийМодуль("Спец_ОбменСДругимиБазами");
//		МодульОбновлениеКонфигурации.<Имя метода>();
//	КонецЕсли;
//	
//@skip-check server-execution-safe-mode
Функция ОбщийМодуль(Знач Имя) Экспорт
	
	#Если Не ТонкийКлиент И Не ВебКлиент И Не ТолстыйКлиентУправляемоеПриложение Тогда
		
		Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
			
			Возврат Вычислить(Имя);
		ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
			Возврат Спец_ОбщегоНазначения.СерверныйМодульМенеджера(Имя);
		Иначе
			Возврат Неопределено;
		КонецЕсли;
		
	#Иначе
		
		Возврат Вычислить(Имя);
		
	#КонецЕсли
	
КонецФункции

// Текст для выдачи сообщений по строке ТЧ (для СообщитьПользователю)
// 
// Параметры:
//  ИмяТЧ - Строка
//  НомерСтроки - Число
//  ИмяРеквизита - Строка
// 
// Возвращаемое значение:
//  Строка
Функция ТекстДляВыдачиСообщенийПоСтрокеТЧ(Знач ИмяТЧ, Знач НомерСтроки, Знач ИмяРеквизита) Экспорт
	
	Возврат ИмяТЧ + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0; ЧФ=[Ч].") + ИмяРеквизита;
	
КонецФункции

// Получает текущий Unix timestamp (https://www.unixtimestamp.com/).
// 
// Параметры:
//  ДатаДляПреобразования - Неопределено, Дата - Дата для преобразования. Если Неопределено, тогда возвращает текущую дату
// 
// Возвращаемое значение:
//  Число
Функция UnixTimestamp(Знач ДатаДляПреобразования = Неопределено) Экспорт
	
	Возврат УниверсальноеВремя(?(ДатаДляПреобразования = Неопределено, ТекущаяДатаПоНормальному(), ДатаДляПреобразования)) - '19700101';
	
КонецФункции

// Преобразует Unix timestamp в дату.
// 
// Параметры:
//  UnixTime - Число
// 
// Возвращаемое значение:
//  Дата
Функция UnixTimestampВДату(Знач UnixTime) Экспорт
	
	Возврат МестноеВремя('19700101' + UnixTime);
	
КонецФункции

// Текущая дата сеанса (по-нормальому, с учётом сервера)
// 
// Возвращаемое значение:
//  Дата
Функция ТекущаяДатаПоНормальному() Экспорт
	
	#Если ТонкийКлиент Или ВебКлиент Тогда
		//@skip-check use-non-recommended-method
		Возврат ТекущаяДата();
	#Иначе
		Возврат ТекущаяДатаСеанса();
	#КонецЕсли
	
КонецФункции

// Возвращает структуру адреса базы, имени базы по строке соединения (СтрокаСоединенияИнформационнойБазы)
// 
// Возвращаемое значение:
//  Структура:
//		* ИмяСервераИБ - Строка - Если серверная база, то возвращает имя сервера, указанное при подключении. Если файловая - файловый путь к базе.
//		* ИмяБазыИБ - Строка - Наименование базы. Если база файловая, то вернёт наименование папки, в которой лежит данная база
//		* ЭтоФайловаяБаза - Булево - Флаг того, что данная база файловая
Функция СтруктураИмениАдресаТипаБазыДанных() Экспорт
	
	СтруктураРезультат  = НоваяСтруктураИмениАдресаТипаБазыДанных();
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	ПозицияПоиска = СтрНайти(Врег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска = 1 Тогда
		
		ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
		НачальнаяПозицияКопирования = 6 + 1;
		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2;
		
		СтруктураРезультат.ИмяСервераИБ = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
		СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
		
		ПозицияПоиска = СтрНайти(Врег(СтрокаСоединенияСБД), "REF=");
		Если ПозицияПоиска = 1 Тогда
			
			НачальнаяПозицияКопирования = 6;
			ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
			КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2;
			СтруктураРезультат.ИмяБазыИБ = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
			
		КонецЕсли;
		
	ИначеЕсли СтрНайти(Врег(СтрокаСоединенияСБД), "FILE") > 0 Тогда
		
		СтруктураРезультат.ЭтоФайловаяБаза = Истина;
		СтруктураРезультат.ИмяСервераИБ = СтрЗаменить(Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6), """", "");
		
		Попытка
			
			ФайлДляПроверки = Новый Файл(СтруктураРезультат.ИмяСервераИБ);
			СтруктураРезультат.ИмяБазыИБ = ФайлДляПроверки.ИмяБезРасширения;
			
		Исключение
			
			СтруктураРезультат.ИмяБазыИБ = "<Неизвестно>";
			
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Возвращает флаг того, что переданная форма - управляемая.
// 
// Параметры:
//  ФормаДляПроверки - Произвольный - ФормаНастройкиНочногоРасчета для проверки
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоУправляемаяФорма(Знач ФормаДляПроверки) Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Возврат ТипЗнч(ФормаДляПроверки) <> Тип("Форма");
	#Иначе
		Возврат Истина;
	#КонецЕсли
	
КонецФункции

// Возвращает содержимое текстового файла.
// 
// Параметры:
//  ДанныеДляЧтения - Строка, Поток, ПотокВПамяти, ФайловыйПоток - Данные для чтения текста.
//  Кодировка - Строка - Кодировка
// 
// Возвращаемое значение:
//  Строка - Содержимое файла
Функция ПрочитатьЧтениеТекста(Знач ДанныеДляЧтения, Знач Кодировка = "UTF-8") Экспорт
	
	#Если Не ВебКлиент Тогда
		
		Попытка
			ЧтениеТекста = Новый ЧтениеТекста(ДанныеДляЧтения, Кодировка, Символы.ПС);
		Исключение
			Возврат "";
		КонецПопытки;
		
		СтрокаРезультат = ЧтениеТекста.Прочитать();
		ЧтениеТекста.Закрыть();
		
		Возврат ?(СтрокаРезультат = Неопределено, "", СтрокаРезультат);
		
	#Иначе
		
		Возврат "";
	
	#КонецЕсли
	
КонецФункции

#Область МатематическиеОперации

// Возвращает модуль числа
//
// Параметры:
//	ИсходноеЧисло - Число
//
// Возвращаемое значение:
//  Число - НОД чисел
//
Функция Abs(Знач ИсходноеЧисло) Экспорт
	
	Возврат Макс(ИсходноеЧисло, -ИсходноеЧисло);
	
КонецФункции

// Рассчитывает наибольший общий делитель 2-х чисел.
// 
//@skip-check bsl-variable-name-invalid
// 
// Параметры:
//  A - Число
//  B - Число
// 
// Возвращаемое значение:
//  Число - НОД чисел
//
Функция НОД(Знач A, Знач B) Экспорт
	
	Возврат ?(B = 0, Abs(A), НОД(B, A % B));
	
КонецФункции

// Рассчитывает наименьшее общее кратное 2-х чисел.
// 
//@skip-check bsl-variable-name-invalid
// 
// Параметры:
//  A - Число
//  B - Число
// 
// Возвращаемое значение:
//  Число - НОК чисел
//
Функция НОК(Знач A, Знач B) Экспорт
	
	НОД = НОД(A, B);
	Возврат ?(НОД = 0, 0, Abs(A / НОД * B));
	
КонецФункции

// Рассчитывает факториал числа
// 
// Параметры:
//	ИсходноеЧисло - Число
// 
// Возвращаемое значение:
//	Число - факториал числа
//
Функция Факториал(Знач ИсходноеЧисло) Экспорт
	
	Возврат ?(ИсходноеЧисло = 0, 1, ИсходноеЧисло * Факториал(ИсходноеЧисло - 1));
	
КонецФункции

#КонецОбласти

//@skip-check doc-comment-collection-item-type
//@skip-check constructor-function-return-section
//@skip-check transfer-object-between-client-server
#Область РаботаСJSON_XML

// Десериализует из JSON в соответствие / структуру JSON по входным данным.
// Если передан поток (ну или объект из которого можно получить поток) - он будет закрыт
// Если при десериализации возникла ошибка, то исключение НЕ будет вызвано.
// 
// Параметры:
//  ВходныеДанные - Строка
//  			  - Поток
//  			  - ПотокВПамяти
//  			  - ФайловыйПоток
//  			  - HTTPЗапрос
//  			  - HTTPОтвет
//  			  - HTTPСервисЗапрос
//  			  - HTTPСервисОтвет
//  			  - ДвоичныеДанные - Данные для чтения
//  ЧитатьИзФайла - Булево - Флаг того, что нужно читать из файла. Если ИСТИНА, то входные данные должны содержать имя файла.
//  ВСоответствие - Булево - Флаг того, что нужно читать в соответствие. Если ЛОЖЬ, то JSON будет прочитан в структуру.
//  КодировкаДляЧтения - Строка, КодировкаТекста - Кодировка для чтения JSON (по умолчанию - UTF8)
// 
// Возвращаемое значение:
// 				- Структура - Если ВСоответствие = ЛОЖЬ
// 				- Массив из Структура, Соответствие, Строка, Число, Булево
//				- Строка
//				- Булево
//				- Число
// 				- Соответствие из КлючИЗначение - Если ВСоответствие = ИСТИНА:
// 					* Ключ - Строка -
// 					* Значение - Массив из Соответствие, Строка, Число, Булево
// 							   - Соответствие
// 							   - Строка
// 							   - Булево
// 							   - Число
//
Функция ПолучитьСоответствиеJSON(Знач ВходныеДанные, Знач ЧитатьИзФайла = Ложь, Знач ВСоответствие = Истина,
		Знач КодировкаДляЧтения = "UTF-8") Экспорт
	
	#Если Не ВебКлиент Тогда
		
		// ++ Спец_БСП.Версия1С_23_ВышеИлиРавно
		// Новинки платформы (:
		// Не читает соответствия и данные из файла / потока, но работает на 40% быстрее
		Если Не ВСоответствие И Не ЧитатьИзФайла Тогда
			
			Попытка
				
				Возврат ПрочитатьЗначениеJSON(ВходныеДанные);
				
			Исключение
				
				//@skip-check module-unused-local-variable
				tmp = ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке());
				
			КонецПопытки;
			
		КонецЕсли;
		// -- Спец_БСП.Версия1С_23_ВышеИлиРавно
		
		ЧтениеJSON = Новый ЧтениеJSON();
		
		ТипВходныхДанных = ТипЗнч(ВходныеДанные);
		Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоПоток(ВходныеДанные, ТипВходныхДанных) Тогда
			
			ПотокДляЧтения = ВходныеДанные;
			
			ПотокДляЧтения.Перейти(0, ПозицияВПотоке.Начало);
			ЧтениеJSON.ОткрытьПоток(ПотокДляЧтения, КодировкаДляЧтения);
			
		ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоHTTPТип(ВходныеДанные, ТипВходныхДанных) Тогда
			
			ПотокДляЧтения = ВходныеДанные.ПолучитьТелоКакПоток();
			ЧтениеJSON.ОткрытьПоток(ПотокДляЧтения, КодировкаДляЧтения);
			
		ИначеЕсли ТипВходныхДанных = Тип("ДвоичныеДанные") Тогда
			
			ПотокДляЧтения = ВходныеДанные.ОткрытьПотокДляЧтения();
			ЧтениеJSON.ОткрытьПоток(ПотокДляЧтения, КодировкаДляЧтения);
			
		Иначе
			
			ДляЧтения = СокрЛП(ВходныеДанные);
			Если ЧитатьИзФайла Тогда
				ЧтениеJSON.ОткрытьФайл(ДляЧтения, КодировкаДляЧтения);
			Иначе
				ЧтениеJSON.УстановитьСтроку(ДляЧтения);
			КонецЕсли;
			
		КонецЕсли;
		
		Попытка
			СоответствиеРезультат = ПрочитатьJSON(ЧтениеJSON, ВСоответствие);
		Исключение
			ДобавитьОшибку(ИнформацияОбОшибке(), "ПолучитьСоответствиеJSON");
		КонецПопытки;
		
		ЧтениеJSON.Закрыть();
		
		Если ПотокДляЧтения <> Неопределено Тогда
			ЗакрытьПотокНеМешаяРаботе(ПотокДляЧтения);
		КонецЕсли;
		
		Возврат СоответствиеРезультат;
		
	#Иначе
		
		Возврат Спец_ОбщегоНазначенияВызовСервера.ПолучитьСоответствиеJSON(ВходныеДанные, ЧитатьИзФайла, ВСоответствие);
		
	#КонецЕсли
	
КонецФункции

// Сериализует объект в JSON
// 
// Параметры:
//  Объект - см. ПолучитьСоответствиеJSON
//  ДляПредставленияПользователю - Булево - Для представления пользователю. Если ИСТИНА, то будут добавлены переносы строк и ТАБы для читабельности.
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьСтрокуПоJSON(Знач Объект, Знач ДляПредставленияПользователю = Истина) Экспорт
	
	#Если Не ВебКлиент Тогда
		
		// ++ Спец_БСП.Версия1С_23_ВышеИлиРавно
		// Новинки платформы (:
		// Не записывает соответствия, но работает на 40% быстрее
		Если Не ДляПредставленияПользователю Тогда
			
			Попытка
				
				Возврат ЗаписатьЗначениеJSON(Объект);
				
			Исключение
				
				//@skip-check module-unused-local-variable
				tmp = ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке());
				
			КонецПопытки;
			
		КонецЕсли;
		// -- Спец_БСП.Версия1С_23_ВышеИлиРавно
		
		ПараметрыЗаписиJSON = ?(ДляПредставленияПользователю,
				Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, Символы.Таб),
				Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
		
		ЗаписьJSON = Новый ЗаписьJSON();
		ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
		
		Попытка
			ЗаписатьJSON(ЗаписьJSON, Объект);
		Исключение
			ДобавитьОшибку(ИнформацияОбОшибке(), "ПолучитьСтрокуПоJSON");
		КонецПопытки;
		
		Возврат ЗаписьJSON.Закрыть();
		
	#Иначе
		
		Возврат Спец_ОбщегоНазначенияВызовСервера.ПолучитьСтрокуПоJSON(Объект, ДляПредставленияПользователю);
		
	#КонецЕсли
	
КонецФункции

// Записывает значение реквизита в JSON
// 
// Параметры:
//  ЗаписьJSON - ЗаписьJSON
//  ИмяСвойства - Строка - Наименование свойства для записи
//  Значение - Строка, Число, Булево, Неопределено - Значение для записи
//
Процедура ЗаписатьЗначениеРеквизитаВJSON(Знач ЗаписьJSON, Знач ИмяСвойства, Знач Значение) Экспорт
	
	#Если Не ВебКлиент Тогда
		
		ЗаписьJSON.ЗаписатьИмяСвойства(ИмяСвойства);
		ЗаписьJSON.ЗаписатьЗначение(Значение);
		
	#КонецЕсли
	
КонецПроцедуры

// Подготовить запись JSON для быстрой записи по входящему потоку.
// 
// Параметры:
//  Поток - Поток, ПотокВПамяти, ФайловыйПоток - Поток, для которого нужно инициализировать запись JSON.
//  ДляПредставленияПользователю - Булево - Для представления пользователю. Если ИСТИНА, то будут добавлены переносы строк и ТАБы для читабельности.
// 
// Возвращаемое значение:
//  ЗаписьJSON
//
Функция ПодготовитьЗаписьJSONПоПотоку(Знач Поток, Знач ДляПредставленияПользователю = Ложь) Экспорт

	#Если Не ВебКлиент Тогда
	
		ЗаписьJSON = Новый ЗаписьJSON();
		ЗаписьJSON.ПроверятьСтруктуру = Ложь;
		
		ПараметрыЗаписиJSON = ?(ДляПредставленияПользователю,
								Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, Символы.Таб),
								Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
	
		ЗаписьJSON.ОткрытьПоток(Поток, "UTF-8", , ПараметрыЗаписиJSON);
		Возврат ЗаписьJSON;
	
	#Иначе
	
		Возврат Неопределено;
	
	#КонецЕсли

КонецФункции

// Подготовить запись JSON для быстрой записи с дальнейшим преобразованием в строку.
// 
// Параметры:
//  ДляПредставленияПользователю - Булево - Для представления пользователю. Если ИСТИНА, то будут добавлены переносы строк и ТАБы для читабельности.
// 
// Возвращаемое значение:
//  ЗаписьJSON
//
Функция ПодготовитьЗаписьJSONДляПреобразованияВСтроку(Знач ДляПредставленияПользователю = Ложь) Экспорт
	
	#Если Не ВебКлиент Тогда
		
		ЗаписьJSON = Новый ЗаписьJSON();
		ЗаписьJSON.ПроверятьСтруктуру = Ложь;
		
		ПараметрыЗаписиJSON = ?(ДляПредставленияПользователю,
								Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, Символы.Таб),
								Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
		
		ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
		Возврат ЗаписьJSON;
		
	#Иначе
		
		Возврат Неопределено;
		
	#КонецЕсли
	
КонецФункции

// Примитивная десериализация из XML в соответствие / структуру XML по входным данным. Атрибуты читаются как отдельные свойства.
// Если передан поток (ну или объект из которого можно получить поток) - он будет закрыт
// Если при десериализации возникла ошибка, то исключение НЕ будет вызвано.
// 
// Параметры:
//  ВходныеДанные - Строка
//  			  - Поток
//  			  - ПотокВПамяти
//  			  - ФайловыйПоток
//  			  - HTTPЗапрос
//  			  - HTTPОтвет
//  			  - HTTPСервисЗапрос
//  			  - HTTPСервисОтвет
//  			  - ДвоичныеДанные - Данные для чтения
//  ЧитатьИзФайла - Булево - Флаг того, что нужно читать из файла. Если ИСТИНА, то входные данные должны содержать имя файла.
//  ВСоответствие - Булево - Флаг того, что нужно читать в соответствие. Если ЛОЖЬ, то JSON будет прочитан в структуру.
//  ПараметрыЧтенияXML - ПараметрыЧтенияXML, Неопределено - Параметры чтения
//  НаборСхемXML - НаборСхемXML - Набор схем XML, используемых при проверке читаемого документа XML.
//  КодировкаДляЧтения - Строка, КодировкаТекста - Кодировка для чтения XML (по умолчанию - UTF8)
// 
// Возвращаемое значение:
// 				- Структура - Если ВСоответствие = ЛОЖЬ
// 				- Массив из Структура, Соответствие, Строка, Число, Булево
//				- Строка
//				- Булево
//				- Число
// 				- Соответствие из КлючИЗначение - Если ВСоответствие = ИСТИНА:
// 					* Ключ - Строка -
// 					* Значение - Массив из Соответствие, Строка, Число, Булево
// 							   - Соответствие
// 							   - Строка
// 							   - Булево
// 							   - Число
//
Функция ПолучитьСоответствиеXML(Знач ВходныеДанные, Знач ЧитатьИзФайла = Ложь, Знач ВСоответствие = Истина,
		Знач ПараметрыЧтенияXML = Неопределено, Знач НаборСхемXML = Неопределено, Знач КодировкаДляЧтения = "UTF-8") Экспорт
	
	#Если Не ВебКлиент Тогда
		
		ЧтениеXMLДанных = Новый ЧтениеXML();
		
		ТипВходныхДанных = ТипЗнч(ВходныеДанные);
		Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоПоток(ВходныеДанные, ТипВходныхДанных) Тогда
			
			ПотокДляЧтения = ВходныеДанные;
			
			ПотокДляЧтения.Перейти(0, ПозицияВПотоке.Начало);
			ЧтениеXMLДанных.ОткрытьПоток(ПотокДляЧтения, ПараметрыЧтенияXML, НаборСхемXML, КодировкаДляЧтения);
			
		ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоHTTPТип(ВходныеДанные, ТипВходныхДанных) Тогда
			
			ПотокДляЧтения = ВходныеДанные.ПолучитьТелоКакПоток();
			ЧтениеXMLДанных.ОткрытьПоток(ПотокДляЧтения, ПараметрыЧтенияXML, НаборСхемXML, КодировкаДляЧтения);
			
		ИначеЕсли ТипВходныхДанных = Тип("ДвоичныеДанные") Тогда
			
			ПотокДляЧтения = ВходныеДанные.ОткрытьПотокДляЧтения();
			ЧтениеXMLДанных.ОткрытьПоток(ПотокДляЧтения, ПараметрыЧтенияXML, НаборСхемXML, КодировкаДляЧтения);
			
		Иначе
			
			ДляЧтения = СокрЛП(ВходныеДанные);
			Если ЧитатьИзФайла Тогда
				ЧтениеXMLДанных.ОткрытьФайл(ДляЧтения, ПараметрыЧтенияXML, НаборСхемXML, КодировкаДляЧтения);
			Иначе
				ЧтениеXMLДанных.УстановитьСтроку(ДляЧтения, ПараметрыЧтенияXML, НаборСхемXML);
			КонецЕсли;
			
		КонецЕсли;
		
		Попытка
			ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXMLДанных);
		Исключение
			ДобавитьОшибку(ИнформацияОбОшибке(), "ПолучитьСоответствиеXML");
		КонецПопытки;
		
		ЧтениеXMLДанных.Закрыть();
		Если ПотокДляЧтения <> Неопределено Тогда
			ЗакрытьПотокНеМешаяРаботе(ПотокДляЧтения);
		КонецЕсли;
		
		Возврат ?(ОбъектXDTO = Неопределено, Неопределено, ОбъектXDTOВСтруктуру_Рекурсия(ОбъектXDTO, ВСоответствие));
		
	#Иначе
		
		Возврат Спец_ОбщегоНазначенияВызовСервера.ПолучитьСоответствиеXML(ВходныеДанные,
				ЧитатьИзФайла,
				ВСоответствие,
				ПараметрыЧтенияXML,
				НаборСхемXML,
				КодировкаДляЧтения);
		
	#КонецЕсли
	
КонецФункции

// Преобразует массив строк ГУИДов в массив ссылок нужного типа. Если передан массив структур, то необходимо передать имя поля структуры с ГУИДом объекта.
// Данный тип преобразования НЕ проверяет наличие объекта в базе, но зато самый быстрый.
// 
// Параметры:
//	МассивИлиСтруктураГУИДов - Массив из Структура, Строка - Массив ГУИДов нужного объекта
//	ГотовыйТипОбъекта - Тип - Готовый тип объекта для преобразования
//	ИмяПоляСтруктуры - Строка - Если передан массив структур, то должен содержать имя поля структуры с ГУИДом объкта.
// 
// Возвращаемое значение:
//	Массив из ЛюбаяСсылка - Массив объектов базы.
//
//@skip-check invocation-parameter-type-intersect
Функция ПреобразоватьМассивГУИДовВМассивОбъектов(Знач МассивИлиСтруктураГУИДов, Знач ГотовыйТипОбъекта, Знач ИмяПоляСтруктуры = "") Экспорт
	
	МассивРезультат = Новый Массив(); // Массив из ЛюбаяСсылка
	
	Если ПустаяСтрока(ИмяПоляСтруктуры) Тогда
		
		#Если Не ВебКлиент Тогда
			Для Каждого ГУИД Из МассивИлиСтруктураГУИДов Цикл МассивРезультат.Добавить(СериализаторXDTO.XMLЗначение(ГотовыйТипОбъекта, ГУИД)); КонецЦикла;
		#Иначе
			Для Каждого ГУИД Из МассивИлиСтруктураГУИДов Цикл МассивРезультат.Добавить(ПолучитьXMLЗначениеПоНормальному(ГотовыйТипОбъекта, ГУИД)); КонецЦикла;
		#КонецЕсли
		
	Иначе
		
		#Если Не ВебКлиент Тогда
			Для Каждого СтруктураПоля Из МассивИлиСтруктураГУИДов Цикл МассивРезультат.Добавить(СериализаторXDTO.XMLЗначение(ГотовыйТипОбъекта, СтруктураПоля[ИмяПоляСтруктуры])); КонецЦикла;
		#Иначе
			Для Каждого СтруктураПоля Из МассивИлиСтруктураГУИДов Цикл МассивРезультат.Добавить(ПолучитьXMLЗначениеПоНормальному(ГотовыйТипОбъекта, СтруктураПоля[ИмяПоляСтруктуры])); КонецЦикла;
		#КонецЕсли
		
	КонецЕсли;
	
	Возврат МассивРезультат;
	
КонецФункции

#КонецОбласти

#Область ОписанияТипов

// Создает объект ОписаниеТипов, содержащий тип Строка.
//
// Параметры:
//  ДлинаСтроки - Число - длина строки.
//  ФиксированнаяДлина - Булево - Флаг того, что нужна строки фиксированной длины
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа Строка.
//
Функция ОписаниеТипаСтрока(Знач ДлинаСтроки = 0, Знач ФиксированнаяДлина = Ложь) Экспорт
	
	Возврат Новый ОписаниеТипов("Строка",
			,
			Новый КвалификаторыСтроки(ДлинаСтроки,
					?(ФиксированнаяДлина, ДопустимаяДлина.Фиксированная, ДопустимаяДлина.Переменная)));
	
КонецФункции

// Создает объект ОписаниеТипов, содержащий тип Число.
//
// Параметры:
//  Разрядность - Число - общее количество разрядов числа (количество разрядов
//                        целой части плюс количество разрядов дробной части).
//  РазрядностьДробнойЧасти - Число - число разрядов дробной части.
//  ЗнакЧисла - ДопустимыйЗнак - допустимый знак числа.
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа Число.
Функция ОписаниеТипаЧисло(Знач Разрядность, Знач РазрядностьДробнойЧасти = 0, Знач ЗнакЧисла = Неопределено) Экспорт
	
	Возврат Новый ОписаниеТипов("Число",
		Новый КвалификаторыЧисла(Разрядность,
			РазрядностьДробнойЧасти,
			?(ЗнакЧисла = Неопределено, ДопустимыйЗнак.Любой, ЗнакЧисла)));
	
КонецФункции

// Создает объект ОписаниеТипов, содержащий тип Дата.
//
// Параметры:
//  ЧастиДаты - ЧастиДаты - набор вариантов использования значений типа Дата.
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа Дата.
Функция ОписаниеТипаДата(Знач ЧастиДаты) Экспорт
	
	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));
	
КонецФункции

// Проверить, что описание типа состоит из единственного типа значения и совпадает с нужным типом.
//
// Параметры:
//   ОписаниеТипа - ОписаниеТипов - проверяемая коллекция типов;
//   ТипЗначения  - Тип - проверяемый тип.
//
// Возвращаемое значение:
//   Булево - Истина, если совпадает.
//
// Пример:
//  Если Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСостоитИзТипа(ТипЗначенияСвойства, Тип("Булево") Тогда
//    // Выводим поле в виде флажка.
//  КонецЕсли;
//
Функция ОписаниеТипаСостоитИзТипа(Знач ОписаниеТипа, Знач ТипЗначения) Экспорт
	
	Возврат ОписаниеТипа.Типы().Количество() = 1 И ОписаниеТипа.Типы().Получить(0) = ТипЗначения;
	
КонецФункции

// Создает объект ОписаниеТипов, содержащий все типы из параметра, исключая тип Null
//
// Параметры:
//  ОписаниеТипов - ОписаниеТипов - коллекция типов для копирования
//
// Возвращаемое значение:
//  ОписаниеТипов
Функция ОписаниеТиповБезNull(Знач ОписаниеТипов) Экспорт
	
	Возврат Новый ОписаниеТипов(ОписаниеТипов, , "Null");
	
КонецФункции

#КонецОбласти

#Область РаботаПотоками

// Готовит файловый поток с временным файлом, доступным после закрытия потока (это не ФайловыеПотоки.СоздатьВременныйФайл)
// 
// Параметры:
//  ФорматФайла - Строка - Формат необходимого файла
// 
// Возвращаемое значение:
//  ФайловыйПоток
Функция ПодготовитьФайловыйПотокСИменемФайла(Знач ФорматФайла = "json") Экспорт
	
	#Если Не ВебКлиент Тогда
		
		РазмерБуфера = Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков"), 16384); // Число
		Возврат ФайловыеПотоки.ОткрытьДляЗаписи(ПолучитьИмяВременногоФайлаПоНормальному(ФорматФайла), РазмерБуфера);
		
	#Иначе
		
		Возврат Неопределено;
		
	#КонецЕсли
	
КонецФункции

// Готовит файловый поток с временным файлом, удаляющимся после закрытия потока (это ФайловыеПотоки.СоздатьВременныйФайл)
// 
// Возвращаемое значение:
//	ФайловыйПоток
Функция ПодготовитьВременныйФайловыйПоток() Экспорт
	
	#Если Не ВебКлиент Тогда
		
		ЛимитПамяти = Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.ЛимитПамятиДляПотоков"), 65535); // Число
		РазмерБуфера = Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков"), 16384); // Число
		
		Возврат ФайловыеПотоки.СоздатьВременныйФайл(ЛимитПамяти, РазмерБуфера);
		
	#Иначе
		
		Возврат Неопределено;
		
	#КонецЕсли
	
КонецФункции

// Метод для сброса остаточного буфера на диск и перехода к началу потока (для дальнейшей работы с потоком, например копирования)
// 
// Параметры:
//  ПотокДляОбработки - Поток, ПотокВПамяти, ФайловыйПоток - Поток для обработки 
Процедура СброситьДанныеПотока(Знач ПотокДляОбработки) Экспорт
	
	ПотокДляОбработки.СброситьБуферы();
	ПотокДляОбработки.Перейти(0, ПозицияВПотоке.Начало);
	
КонецПроцедуры

// Метод для неблокирующего закрытия потока (на клиенте).
// Если это файловый поток и нужно закрыть для дальнейшей работы с файлом, то закрытие потока идёт как обычно.
// Если передан признак удалять файл файлового потока, что файл потока будет удалён (так же асинхронно) после закрытия потока.
// 
// Параметры:
//  ПотокДляЗакрытия - Поток, ПотокВПамяти, ФайловыйПоток - Поток для закрытия
//  ЗакрытьДляРаботыСФайлом - Булево - Если ИСТИНА, то поток будет закрыть НЕ асинхронно в любом случае.
//  УдалятьФайлФайловогоПотока - Булево - Если ИСТИНА и передан файловый поток, то его файл будет удалён (так же асинхронно, по-возможности).
Процедура ЗакрытьПотокНеМешаяРаботе(ПотокДляЗакрытия, Знач ЗакрытьДляРаботыСФайлом = Ложь, Знач УдалятьФайлФайловогоПотока = Истина) Экспорт
	
	Если ЗакрытьДляРаботыСФайлом Тогда
		
		ПотокДляЗакрытия.СброситьБуферы();
		ПотокДляЗакрытия.Закрыть();
		
	Иначе
		
		#Если Клиент Тогда
			//@skip-check invocation-parameter-type-intersect
			ПотокДляЗакрытия.НачатьЗакрытие(Новый ОписаниеОповещения("ОписаниеОповещенияЗаглушкаСОднимПараметром", Спец_ОбщегоНазначенияКлиент));
		#Иначе
			ПотокДляЗакрытия.Закрыть();
		#КонецЕсли
		
		Если УдалятьФайлФайловогоПотока И ТипЗнч(ПотокДляЗакрытия) = Тип("ФайловыйПоток") Тогда УдалитьФайлыНеМешаяРаботе(ПотокДляЗакрытия.ИмяФайла); КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область HTTPЗапросы

// Отправляет HTTP запросы через 1С и возвращает результат их выполнения.
// 
// Параметры:
//  МассивИлиСтруктураЗапросов - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.HTTPClientОтправитьЗапросыАсинхронно.МассивИлиСтруктураЗапросов
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.HTTPClientПреобразоватьJsonВРезультат
Функция ОтправитьHTTPЗапросы(Знач МассивИлиСтруктураЗапросов, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	ТипВходныхДанных        = ТипЗнч(МассивИлиСтруктураЗапросов);
	ВозвращатьОдинРезультат = Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(МассивИлиСтруктураЗапросов, ТипВходныхДанных);
	МассивРезультат         = Новый Массив; // Массив из см. НоваяСтруктураРезультатаHTTPЗапроса
	ТаймаутЗапросов         = ?(Кэш.Свойство("ТекущийТаймАутHTTPЗапросов"), 30, Кэш.ТекущийТаймАутHTTPЗапросов);
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивИлиСтруктураЗапросов, ТипВходныхДанных);
	Если МассивИлиСтруктураЗапросов.Количество() = 0 Тогда
		Возврат МассивРезультат;
	КонецЕсли;
	
	Для Каждого СтруктураЗапроса Из МассивИлиСтруктураЗапросов Цикл
		
		СтруктураURIЗапроса = СтруктураURI(СтруктураЗапроса.URL);
		
		// С кэшированным соединением происходит какая-то чертовщина (в базах аптеки (8.3.12) при выполнении запроса всегда возвращает последний отправленный запрос).
		// Убираем.
		
		// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
		HTTPСоединение = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.КэшированноеHTTPСоединение(СтруктураURIЗапроса.Хост,
				СтруктураURIЗапроса.Порт,
				СтруктураURIЗапроса.Логин,
				СтруктураURIЗапроса.Пароль,
				ТаймаутЗапросов,
				СтруктураURIЗапроса.Схема = "https");
		// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
		
		// ++ Спец_БСП.Версия1С_20_Ниже
		////HTTPСоединение = Новый HTTPСоединение(СтруктураURIЗапроса.Хост,
		////		СтруктураURIЗапроса.Порт,
		////		СтруктураURIЗапроса.Логин,
		////		СтруктураURIЗапроса.Пароль,
		////		,
		////		ТаймаутЗапросов,
		////		?(СтруктураURIЗапроса.Схема = "https", Новый ЗащищенноеСоединениеOpenSSL(), Неопределено));
		// -- Спец_БСП.Версия1С_20_Ниже
		
		HTTPЗапрос = Новый HTTPЗапрос(СтруктураURIЗапроса.ПутьНаСервере, СтруктураЗапроса.Заголовки);
		Если Не ПустаяСтрока(СтруктураЗапроса.ИмяФайлаЧтения) Тогда
			HTTPЗапрос.УстановитьИмяФайлаТела(СтруктураЗапроса.ИмяФайлаЧтения);
		Иначе
			ЗаполнитьТелоHTTPЗапроса(HTTPЗапрос, СтруктураЗапроса.ТелоЗапроса);
		КонецЕсли;
		
		СтруктураРезультат = НоваяСтруктураРезультатаHTTPЗапроса(СтруктураЗапроса.ИдентификаторЗапроса, СтруктураЗапроса.URL, СтруктураЗапроса.МетодЗапроса);
		HTTPОтвет = Неопределено;
		
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.НачатьЗамер("HTTPЗапрос", Кэш);
		Попытка
			
			HTTPОтвет = HTTPСоединение.ВызватьHTTPМетод(СтруктураЗапроса.МетодЗапроса, HTTPЗапрос, СтруктураЗапроса.ИмяФайлаРезультат);
			СтруктураРезультат.UnixTimestampОтвета = Спец_КомпонентаДополнительныеФункцииКлиентСервер.ТекущийUnixTimestamp(Кэш);
			
		Исключение
	
			ТекстОшибки = "";
			ДобавитьОшибку(КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке()),
					"Спец_ОбщегоНазначенияКлиентСервер.ОтправитьHTTPЗапрос(...)",
					ТекстОшибки);
			
			Если Не ПустаяСтрока(СтруктураЗапроса.ИмяФайлаРезультат) Тогда
				
				#Если Не ВебКлиент Тогда
					
					ЗаписьТекста = Новый ЗаписьТекста(СтруктураЗапроса.ИмяФайлаРезультат, "UTF-8");
					ЗаписьТекста.Записать(ТекстОшибки);
					ЗаписьТекста.Закрыть();
					
					СтруктураРезультат.Вставить("ФайлРезультат", СтруктураЗапроса.ИмяФайлаРезультат);
					
				#КонецЕсли
				
			Иначе
				
				СтруктураРезультат.Вставить("ТелоРезультат", ТекстОшибки);
				
			КонецЕсли;
			
		КонецПопытки;
		СтруктураРезультат.ВремяОтвета = Спец_КомпонентаДополнительныеФункцииКлиентСервер.ЗавершитьЗамер("HTTPЗапрос", Кэш);
		
		Если HTTPОтвет <> Неопределено Тогда
			
			СтруктураРезультат.КодОтвета = HTTPОтвет.КодСостояния;
			СтруктураРезультат.Успешно   = HTTPОтвет.КодСостояния >= 200 И HTTPОтвет.КодСостояния < 300;
			
			Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьОбъект(HTTPОтвет.Заголовки, СтруктураРезультат.ЗаголовкиРезультат);
			
			ИмяФайлаРезультат = HTTPОтвет.ПолучитьИмяФайлаТела();
			Если Не ПустаяСтрока(ИмяФайлаРезультат) Тогда
				СтруктураРезультат.Вставить("ФайлРезультат", ИмяФайлаРезультат);
			Иначе
				СтруктураРезультат.Вставить("ТелоРезультат", HTTPОтвет.ПолучитьТелоКакСтроку("UTF-8"));
			КонецЕсли;
			
		КонецЕсли;
		
		МассивРезультат.Добавить(СтруктураРезультат);
		
	КонецЦикла;
	
	Возврат ?(ВозвращатьОдинРезультат, МассивРезультат.Получить(0), МассивРезультат);
	
КонецФункции

// Заполняет тело HTTP запроса по произвольным входным данным.
// 
// Параметры:
//  HTTPЗапрос - HTTPЗапрос
//  		   - HTTPСервисОтвет
//  ДанныеДляЗапроса - ДвоичныеДанные
//  				 - Массив из Произвольный
//  				 - ФиксированныйМассив из Произвольный
//  				 - Структура
//  				 - ФиксированнаяСтруктура
//  				 - Соответствие из КлючИЗначение
//  				 - ФиксированноеСоответствие из КлючИЗначение
//  				 - ФайловыйПоток
//  				 - Файл
//  				 - ПотокВПамяти
//  				 - ЗаписьJSON
//  				 - ЗаписьXML
//  				 - ИнформацияОбОшибке
//  				 - Строка
//  				 - Произвольный
//  ИсходныйЗапрос - Неопределено, HTTPСервисЗапрос - Если передать HTTPСервисЗапрос, то в ответ будет помещёны исходные данные HTTP запроса.
Процедура ЗаполнитьТелоHTTPЗапроса(HTTPЗапрос, Знач ДанныеДляЗапроса, Знач ИсходныйЗапрос = Неопределено) Экспорт
	
	Если ДанныеДляЗапроса = Неопределено Или ДанныеДляЗапроса = "" Тогда
		Возврат;
	КонецЕсли;
	
	УстанавливатьТипДанных = HTTPЗапрос.Заголовки["Content-Type"] = Неопределено;
	
	ТипДанных = ТипЗнч(ДанныеДляЗапроса);
	Если ТипДанных = Тип("ДвоичныеДанные") Тогда
		
		HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДанныеДляЗапроса);
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ДанныеДляЗапроса, ТипДанных)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ДанныеДляЗапроса, ТипДанных)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(ДанныеДляЗапроса, ТипДанных) Тогда
		
		ТекстДляВозврата = ПолучитьСтрокуПоJSON(ДанныеДляЗапроса, Ложь);
		Если ПустаяСтрока(ТекстДляВозврата) Тогда
			
			HTTPЗапрос.УстановитьТелоИзСтроки(СокрЛП(ДанныеДляЗапроса));
			
			Если УстанавливатьТипДанных Тогда
				HTTPЗапрос.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
			КонецЕсли;
			
		Иначе
			
			HTTPЗапрос.УстановитьТелоИзСтроки(ТекстДляВозврата);
			
			Если УстанавливатьТипДанных Тогда
				HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
			КонецЕсли;
			
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ФайловыйПоток") Тогда
		
		HTTPЗапрос.УстановитьИмяФайлаТела(ДанныеДляЗапроса.ИмяФайла);
		ДанныеДляЗапроса.Закрыть();
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("Файл") Тогда
		
		HTTPЗапрос.УстановитьИмяФайлаТела(ДанныеДляЗапроса.ПолноеИмя);
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ПотокВПамяти") Тогда
		
		ДанныеДляЗапроса.Перейти(0, ПозицияВПотоке.Начало);
		HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДанныеДляЗапроса.ЗакрытьИПолучитьДвоичныеДанные());
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ЗаписьJSON") Тогда
		
		HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеДляЗапроса.Закрыть(), "UTF-8");
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ЗаписьXML") Тогда
		
		HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеДляЗапроса.Закрыть(), "UTF-8");
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/xml;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("Строка") Тогда
		
		HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеДляЗапроса, "UTF-8");
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ИнформацияОбОшибке") Тогда
		
		ДобавитьОшибку(ДанныеДляЗапроса, "HTTP запрос", ТекстДляВозврата);
		
		Если ИсходныйЗапрос <> Неопределено Тогда
			
			Спец_СтроковыеФункцииКлиентСервер.ДобавитьСтрокуВТекст(Спец_СтроковыеФункцииКлиентСервер.СформироватьТекстовоеПредставлениеОбъекта(ИсходныйЗапрос, Символы.Таб),
					ТекстДляВозврата,
					Символы.ПС + Символы.ПС);
			
		КонецЕсли;
		
		HTTPЗапрос.УстановитьТелоИзСтроки(ТекстДляВозврата, "UTF-8");
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных <> Тип("Неопределено") Тогда
		
		ДляПередачи = ПолучитьXMLСтрокуПоНормальному(ДанныеДляЗапроса);
		Если ПустаяСтрока(ДляПередачи) Тогда
			ДляПередачи = Строка(ДанныеДляЗапроса);
		КонецЕсли;
			
		Если Не ПустаяСтрока(ДляПередачи) Тогда
			
			HTTPЗапрос.УстановитьТелоИзСтроки(ДляПередачи, "UTF-8");
			Если УстанавливатьТипДанных Тогда
				HTTPЗапрос.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Заголовки для HTTP запросов по умолчанию. Содержит необходимые данные для того, чтобы приёмник мог однозначно определить базу-отправителя.
// Содержит следующие заголовки:
//	* SPEC-Database - наименование базы-отправителя запроса
//	* SPEC-BaseLevel - уровень базы-отправителя
//	* SPEC-WorksInReserve - база-отправитель работает в резервной базе
//	* SPEC-UID - ГУИД текущей базы. Если заполнен магазин текущей базы, то содержит его ГУИД, в противном случае наименование базы
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//		* Ключ - Строка
//		* Значение - Строка
//
Функция ЗаголовкиДляHTTPЗапросовПоУмолчанию() Экспорт
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		
		Возврат Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьСоответствие(
				Спец_ОбщегоНазначенияВызовСервера.ЗаголовкиДляHTTPЗапросовПоУмолчанию(), Ложь);
		
	#Иначе
		
		Возврат Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьСоответствие(
				Спец_ОбщегоНазначенияПовтИсп.ЗаголовкиДляHTTPЗапросовПоУмолчанию(), Ложь);
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти

#Область РаботаОС

// Выполнить КОНСОЛЬНУЮ команду системы и, если нужно, возвращает результат выполнения (в виде строки).
// По-возможности пытается выполнить команду, не отображая окно консоли.
// Вызов прекрасно работает для: Windows, *nix, Wine систем.
// 
// Параметры:
//  СтрокаКоманды - Строка - Текст команды. Не нужно принудительно дописывать "cmd <текст команды>", можно просто написать "<текст команды>"
//  					   Например, если в Windows передать "ipconfig", то вернёт вывод из консоли.
//  ДождатьсяЗавершения - Булево, Неопределено - Флаг того, что нужно дождаться завершения выполнения команды
//  ВозвращатьРезультат - Булево, Неопределено - Флаг того, что нужно вернуть вывод команды в консоли (<OUT)
//  ОписаниеОповещенияРезультат - Неопределено, ОписаниеОповещения - Если вызов с клиента и значение параметра заполнено,
//  									то команда будет выполнена асинхронно.
//  ТипОСКэш - Неопределено, ПеречислениеСсылка.Спец_ОперационныеСистемы - Тип ОС кэш
// 
// Возвращаемое значение:
//  Булево, Строка - Выполнить команду системы
Функция ВыполнитьКомандуСистемы(Знач СтрокаКоманды, Знач ДождатьсяЗавершения = Истина, Знач ВозвращатьРезультат = Истина,
		Знач ОписаниеОповещенияРезультат = Неопределено, Знач ТипОСКэш = Неопределено) Экспорт
	
	Если ВозвращатьРезультат Тогда ДождатьсяЗавершения = Истина; КонецЕсли;
	#Если Клиент Тогда
		
		Если ТипОСКэш <> Неопределено Тогда
			
			Если ТипОСКэш = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows") Тогда
				Возврат Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Windows(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат, ОписаниеОповещенияРезультат);
			ИначеЕсли ТипОСКэш = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine") Тогда
				Возврат Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Wine(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат, ОписаниеОповещенияРезультат);
			Иначе
				Возврат Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Other(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат, ОписаниеОповещенияРезультат);
			КонецЕсли;
			
		ИначеЕсли ЭтоWindows() Тогда
			
			Возврат Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Windows(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат, ОписаниеОповещенияРезультат);
			
		ИначеЕсли ЭтоWine() Тогда
			
			Возврат Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Wine(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат, ОписаниеОповещенияРезультат);
			
		Иначе
			
			Возврат Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Other(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат, ОписаниеОповещенияРезультат);
			
		КонецЕсли;
		
	#Иначе
		
		Возврат Спец_ОбщегоНазначения.ВыполнитьКомандуСистемы(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат, ТипОСКэш);
		
	#КонецЕсли
	
КонецФункции

// Флаг того, что текущая операционная система - *nix
// 
// Параметры:
//  Клиента - Булево - Флаг того, что нужно проверить клиентскую ОС
//  Сервера - Булево - Флаг того, что нужно проверить серверную ОС
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоLinux(Знач Клиента = Ложь, Знач Сервера = Ложь) Экспорт
	
	Если Клиента Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаКлиент") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.UNIX");
		
	ИначеЕсли Сервера Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаСервер") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.UNIX");
		
	Иначе
		
		#Если Клиент Тогда
			Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаКлиент") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.UNIX");
		#Иначе
			Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаСервер") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.UNIX");
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

// Флаг того, что текущая операционная система - Windows
// 
// Параметры:
//  Клиента - Булево - Флаг того, что нужно проверить клиентскую ОС
//  Сервера - Булево - Флаг того, что нужно проверить серверную ОС
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоWindows(Знач Клиента = Ложь, Знач Сервера = Ложь) Экспорт
	
	Если Клиента Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаКлиент") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows");
		
	ИначеЕсли Сервера Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаСервер") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows");
		
	Иначе
		
		#Если Клиент Тогда
			Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаКлиент") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows");
		#Иначе
			Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаСервер") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows");
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

// Флаг того, что текущая операционная система - *nix, но 1С запущена по Wine.
// 
// Параметры:
//  Клиента - Булево - Флаг того, что нужно проверить клиентскую ОС
//  Сервера - Булево - Флаг того, что нужно проверить серверную ОС
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоWine(Знач Клиента = Ложь, Знач Сервера = Ложь) Экспорт
	
	Если Клиента Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаКлиент") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine");
		
	ИначеЕсли Сервера Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаСервер") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine");
		
	Иначе
		
		#Если Клиент Тогда
			Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаКлиент") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine");
		#Иначе
			Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаСервер") = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine");
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

// Возвращает имя компьютера текущего компьютера. 
// 
// Параметры:
//  Клиента - Булево - Флаг того, что нужно вернуть имя клиентского компьютера
//  Сервера - Булево - Флаг того, что нужно вернуть имя серверного компьютера
// 
// Возвращаемое значение:
//  Строка
Функция ПолучитьИмяКомпьютера(Знач Клиента = Ложь, Знач Сервера = Ложь) Экспорт
	
	Если Клиента Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ИмяКомпьютераКлиент");
		
	ИначеЕсли Сервера Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ИмяКомпьютераСервер");
		
	Иначе
		
		#Если Клиент Тогда
			Возврат Спец_ПолучитьЗначениеПеременной("ИмяКомпьютераКлиент");
		#Иначе
			Возврат Спец_ПолучитьЗначениеПеременной("ИмяКомпьютераСервер");
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

// Возвращает тип текущей операционной системы.
// 
// Параметры:
//  Клиента - Булево - Флаг того, что нужно вернуть тип клиентского компьютера
//  Сервера - Булево - Флаг того, что нужно вернуть тип серверного компьютера
// 
// Возвращаемое значение:
//  ПеречислениеСсылка.Спец_ОперационныеСистемы
Функция ПолучитьТипОС(Знач Клиента = Ложь, Знач Сервера = Ложь) Экспорт
	
	Если Клиента Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаКлиент");
		
	ИначеЕсли Сервера Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаСервер");
		
	Иначе
		
		#Если Клиент Тогда
			Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаКлиент");
		#Иначе
			Возврат Спец_ПолучитьЗначениеПеременной("ОперационнаяСистемаСервер");
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

// Возвращает имя текущего пользователя системы
// 
// Параметры:
//  Клиента - Булево - Флаг того, что нужно вернуть имя пользователя клиентского компьютера
//  Сервера - Булево - Флаг того, что нужно вернуть имя пользователя клиентского компьютера
// 
// Возвращаемое значение:
//  Строка
Функция ТекущийПользовательСистемы(Знач Клиента = Ложь, Знач Сервера = Ложь) Экспорт
	
	Если Клиента Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ИмяПользователяОСКлиент");
		
	ИначеЕсли Сервера Тогда
		
		Возврат Спец_ПолучитьЗначениеПеременной("ИмяПользователяОССервер");
		
	Иначе
		
		#Если Клиент Тогда
			Возврат Спец_ПолучитьЗначениеПеременной("ИмяПользователяОСКлиент");
		#Иначе
			Возврат Спец_ПолучитьЗначениеПеременной("ИмяПользователяОССервер");
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

// Возвращает имя текущего пользователя 1С.
// 
// Возвращаемое значение:
//  Строка
Функция ТекущийПользователь1С() Экспорт
	
	Возврат ТРег(ИмяПользователя());
	
КонецФункции

// Возвращает польное имя текущего пользователя 1С.
// 
// Возвращаемое значение:
//  Строка
Функция ТекущийПользователь1СПолноеИмя() Экспорт
	
	Возврат Спец_ПолучитьЗначениеПеременной("ТекущийПользовательПолноеИмя");
	
КонецФункции

// Возвращает FTP соединение по переданным параметрам
// 
// Параметры:
//  URLИлиСтруктураURI - Строка - Адрес URL для подключения FTP соединение. Строка должна содержать все необходимые данные для подключения (см. СтруктураURI.СтрокаURI).
//  				   - см. СтруктураURI
//  ТаймаутПодключения - Число - Таймаут подключения
// 
// Возвращаемое значение:
//  Неопределено, FTPСоединение - 
Функция ПолучитьFTPСоединениеПоURL(Знач URLИлиСтруктураURI, Знач ТаймаутПодключения = 5) Экспорт
	
	СтруктураДляПодключения = ?(Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(URLИлиСтруктураURI), URLИлиСтруктураURI, СтруктураURI(URLИлиСтруктураURI));
	Возврат Спец_ОбщегоНазначенияКлиентСерверПовтИсп.FTPСоединение(СтруктураДляПодключения.Хост,
			СтруктураДляПодключения.Порт,
			СтруктураДляПодключения.Логин,
			СтруктураДляПодключения.Пароль,
			ТаймаутПодключения);
	
КонецФункции

// Возвращает FTP соединение по полному пути к каталогу на FTP сервере. Путь должен содержать необходимые данные для подключения (см. СтруктураURI.СтрокаURI).
// Если получилось успешно подключить FTP соединение, то пошагово выполняет переход к нужному каталогу (УстановитьТекущийКаталог).
// Если какой-то каталог отсутствует - данный метод создаст его (СоздатьКаталог).
// 
// Параметры:
//  КаталогДляОбмена - Строка - Полный путь к каталогу
//  ТаймаутПодключения - Число - Таймаут подключения
// 
// Возвращаемое значение:
//  Неопределено, FTPСоединение - 
Функция ПолучитьFTPСоединениеПоURLИПерейтиККаталогу(Знач КаталогДляОбмена, Знач ТаймаутПодключения = 5) Экспорт
	
	#Если Не ВебКлиент Тогда
		
		СтруктураURI = СтруктураURI(КаталогДляОбмена);
		КаталогДляПерехода = СтрЗаменить(СтруктураURI.ПутьНаСервере, "\", "/");
		МассивПолногоПути = СтрРазделить(КаталогДляПерехода, "/", Ложь);
		
		FTPСоединение = ПолучитьFTPСоединениеПоURL(СтруктураURI, ТаймаутПодключения);
		Если FTPСоединение = Неопределено Или FTPСоединение.ТекущийКаталог() = "/" + КаталогДляПерехода Тогда Возврат FTPСоединение; КонецЕсли;
		
		Попытка
			
			FTPСоединение.УстановитьТекущийКаталог("/");
			Для Каждого Путь Из МассивПолногоПути Цикл
				
				ТекущийКаталог   = FTPСоединение.ТекущийКаталог();
				ПутьДляУстановки = ТекущийКаталог + ?(СтрЗаканчиваетсяНа(ТекущийКаталог, "/"), "", "/") + Путь;
				
				Попытка
					
					FTPСоединение.УстановитьТекущийКаталог(ПутьДляУстановки);
					
				Исключение
					
					FTPСоединение.СоздатьКаталог(Путь);
					FTPСоединение.УстановитьТекущийКаталог(ПутьДляУстановки);
					
				КонецПопытки;
				
			КонецЦикла;
			
			Возврат FTPСоединение;
			
		Исключение
			
			ДобавитьОшибку(ИнформацияОбОшибке(), "Спец_ОбщегоНазначенияКлиентСервер.ПолучитьFTPСоединениеПоURLИПерейтиККаталогу(...)");
			Возврат FTPСоединение;
			
		КонецПопытки;
		
	#Иначе
		
		Возврат Неопределено;
		
	#КонецЕсли
	
КонецФункции

// Возвращает идентификатор (PID) текущего процесса 1С. Работает только для Windows или для *nix (для Wine нет возможности).
// Если вызов на сервере, возвращает PID процесса "rphost", для клиентского идентификатор процесса "1cv8" (или "1cv8c")
// 
// Возвращаемое значение:
//  Строка
Функция PIDТекущегоПроцесса() Экспорт
	
	Результат = "";
	Если ЭтоLinux() Тогда
		
		РезультатВыполнения = ВыполнитьКомандуСистемы("pstree -ps $$");
		Если Не ПустаяСтрока(РезультатВыполнения) Тогда
			
			#Если Сервер Тогда
				ПозицияПроцесса = СтрНайти(НРег(РезультатВыполнения), "rphost");
			#Иначе
				ПозицияПроцесса = СтрНайти(НРег(РезультатВыполнения), "1cv8");
			#КонецЕсли
			
			Если ПозицияПроцесса > 0 Тогда
				
				ПозицияЛевойСкобки = СтрНайти(РезультатВыполнения, "(", , ПозицияПроцесса);
				Если ПозицияЛевойСкобки > 0 Тогда
					
					ПозицияПравойСкобки = СтрНайти(РезультатВыполнения, ")", , ПозицияЛевойСкобки);
					Если ПозицияПравойСкобки > 0 Тогда
						Результат = Сред(РезультатВыполнения, ПозицияЛевойСкобки + 1, ПозицияПравойСкобки - ПозицияЛевойСкобки - 1);
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	ИначеЕсли ЭтоWindows() Тогда
		
		//@skip-check property-return-type
		//@skip-check variable-value-type
		//@skip-check dynamic-access-method-not-found
		//@skip-check invocation-parameter-type-intersect
		Попытка
			
			Locator = Новый COMObject("WbemScripting.SWbemLocator");
			Service = Locator.ConnectServer(".", "root\CIMV2");
			
			Shell = Новый COMObject("WScript.Shell");
			App = Shell.Exec("rundll32.exe kernel32,Sleep");
			ChildProcess = Service.Get("Win32_Process.Handle=" + Формат(App.ProcessID, "ЧГ="));
			Результат = Формат(ChildProcess.ParentProcessID, "ЧГ=");
			ChildProcess.Terminate();
			
		Исключение
			
			//@skip-check module-unused-local-variable
			tmp = ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке());
			
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область РаботаСМетаданнымиИТипами

// См. Спец_ОбщегоНазначения.ЭтоПустаяИлиБитаяСсылка
// На случай частого обращения к одной и той же таблице с клиента
// 
// Параметры:
//  СсылкаДляПроверки - см. Спец_ОбщегоНазначения.ЭтоПустаяИлиБитаяСсылка.СсылкаДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоПустаяИлиБитаяСсылка
//
Функция ЭтоПустаяИлиБитаяСсылка(Знач СсылкаДляПроверки, Кэш = Неопределено) Экспорт
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		
		Если Не ЗначениеЗаполнено(СсылкаДляПроверки) Тогда Возврат Истина; КонецЕсли; // Отсеиваем пустые ссылки
		Если Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна() Тогда
			
			Если Кэш = Неопределено Тогда
				Кэш = Спец_ПолучитьКэш();
			КонецЕсли;
			
			ТипСсылки     = ТипЗнч(СсылкаДляПроверки);
			ИмяМетаданных = ИмяМетаданныхПоТипу(ТипСсылки, Кэш);
			
			Если Кэш.КэшПараметровЗаполненияТаблиц["Спец_ЭтоПустаяИлиБитаяСсылка"] = Неопределено Тогда
				Кэш.КэшПараметровЗаполненияТаблиц["Спец_ЭтоПустаяИлиБитаяСсылка"] = Новый Соответствие();
			КонецЕсли;
			Если Кэш.КэшПараметровЗаполненияТаблиц["Спец_ЭтоПустаяИлиБитаяСсылка"][ИмяМетаданных] = Неопределено Тогда
				
				ТекстЗапроса = СтрШаблон(
						"SELECT true
						|FROM [%1]
						|WHERE [%1.Ссылка] = %%1",
						
						ИмяМетаданных);
				
				Кэш.КэшПараметровЗаполненияТаблиц["Спец_ЭтоПустаяИлиБитаяСсылка"][ИмяМетаданных] = Спец_РаботаСБазойДанныхНапрямуюВызовСервера.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(ТекстЗапроса);
				
			КонецЕсли;
			
			//@skip-check invocation-parameter-type-intersect
			ТекстЗапросаДляВыполнения = СтрШаблон(Кэш.КэшПараметровЗаполненияТаблиц["Спец_ЭтоПустаяИлиБитаяСсылка"][ИмяМетаданных],
					Спец_PostgreSQLКлиентСервер.ПолучитьЗначениеДляPostgreSQLВТекстЗапроса(СсылкаДляПроверки, ТипСсылки, Кэш));
			
			СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапросаДляВыполнения, -1, "", Кэш);
			Если СтруктураРезультат.Успешно Тогда
				Возврат СтруктураРезультат.РезультатЗапроса.Количество() = 0;
			КонецЕсли;
			
		КонецЕсли;
		
		Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоПустаяИлиБитаяСсылка(СсылкаДляПроверки);
		
	#Иначе
		
		Возврат Спец_ОбщегоНазначения.ЭтоПустаяИлиБитаяСсылка(СсылкаДляПроверки, Кэш);
		
	#КонецЕсли
	
КонецФункции

// См. Спец_ОбщегоНазначения.ПолучитьИмяМетаданныхПоТипу
// 
// Параметры:
//  ТипКолонки - Тип
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка - Имя метаданных по типу
Функция ИмяМетаданныхПоТипу(Знач ТипКолонки, Кэш = Неопределено) Экспорт
	
	#Если Не ТонкийКлиент И Не ВебКлиент И Не ТолстыйКлиентУправляемоеПриложение Тогда
		
		Возврат Спец_ОбщегоНазначения.ПолучитьИмяМетаданныхПоТипу(ТипКолонки, Кэш);
		
	#Иначе
		
		Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
		Если Кэш.КэшПоМетаданным.ИменаМетаданныхПоТипу[ТипКолонки] = Неопределено Тогда
			Кэш.КэшПоМетаданным.ИменаМетаданныхПоТипу[ТипКолонки] = Спец_ОбщегоНазначенияВызовСервера.ПолучитьИмяМетаданныхПоТипу(ТипКолонки);
		КонецЕсли;
	
		Возврат Кэш.КэшПоМетаданным.ИменаМетаданныхПоТипу[ТипКолонки];
		
	#КонецЕсли
	
КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоСсылка
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоСсылка
Функция ЭтоСсылка(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт
	
	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		Возврат ЭтоСправочник(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоДокумент(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоПеречисление(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоПланВидовХарактеристик(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоПланСчетов(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоПланВидовРасчета(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоБизнесПроцесс(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоЗадача(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоПланОбмена(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоЖурналДокументов(ОбъектДляПроверки, Кэш, ТипОбъекта);
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоСсылка(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоСсылка(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоСправочник
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоСправочник.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоСправочник.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоСправочник
Функция ЭтоСправочник(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "СПРАВОЧНИК.") Или СтрНачинаетсяС(ВРегСтрока, "СПРАВОЧНИКИ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоСправочник(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоСправочник(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоДокумент
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоДокумент.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоДокумент.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоДокумент
Функция ЭтоДокумент(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "ДОКУМЕНТ.") Или СтрНачинаетсяС(ВРегСтрока, "ДОКУМЕНТЫ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоДокумент(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоДокумент(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоПеречисление
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоПеречисление.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоПеречисление.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоПеречисление
Функция ЭтоПеречисление(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "ПЕРЕЧИСЛЕНИЕ.") Или СтрНачинаетсяС(ВРегСтрока, "ПЕРЕЧИСЛЕНИЯ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоПеречисление(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоПеречисление(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоПланВидовХарактеристик
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоПланВидовХарактеристик.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоПланВидовХарактеристик.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоПланВидовХарактеристик
Функция ЭтоПланВидовХарактеристик(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "ПЛАНЫВИДОВХАРАКТЕРИСТИК.") Или СтрНачинаетсяС(ВРегСтрока, "ПЛАНВИДОВХАРАКТЕРИСТИК.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоПланВидовХарактеристик(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоПланВидовХарактеристик(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоПланСчетов
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоПланСчетов.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоПланСчетов.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоПланСчетов
Функция ЭтоПланСчетов(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "ПЛАНСЧЕТОВ.") Или СтрНачинаетсяС(ВРегСтрока, "ПЛАНЫСЧЕТОВ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоПланСчетов(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоПланСчетов(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоПланВидовРасчета
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоПланВидовРасчета.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоПланВидовРасчета.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоПланВидовРасчета
Функция ЭтоПланВидовРасчета(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "ПЛАНВИДОВРАСЧЕТА.") Или СтрНачинаетсяС(ВРегСтрока, "ПЛАНЫВИДОВРАСЧЕТА.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоПланВидовРасчета(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоПланВидовРасчета(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоБизнесПроцесс
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоБизнесПроцесс.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоБизнесПроцесс.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоБизнесПроцесс
Функция ЭтоБизнесПроцесс(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "БИЗНЕСПРОЦЕСС.") Или СтрНачинаетсяС(ВРегСтрока, "БИЗНЕСПРОЦЕССЫ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоБизнесПроцесс(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоБизнесПроцесс(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоЗадача
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоЗадача.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоЗадача.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоЗадача
Функция ЭтоЗадача(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда

		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "ЗАДАЧА.") Или СтрНачинаетсяС(ВРегСтрока, "ЗАДАЧИ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоЗадача(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоЗадача(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоПланОбмена
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоПланОбмена.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоПланОбмена.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоПланОбмена
Функция ЭтоПланОбмена(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "ПЛАНОБМЕНА.") Или СтрНачинаетсяС(ВРегСтрока, "ПЛАНЫОБМЕНА.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоПланОбмена(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоПланОбмена(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоЖурналДокументов
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоЖурналДокументов.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоЖурналДокументов.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоЖурналДокументов
Функция ЭтоЖурналДокументов(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "ЖУРНАЛДОКУМЕНТОВ.") Или СтрНачинаетсяС(ВРегСтрока, "ЖУРНАЛЫДОКУМЕНТОВ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоЖурналДокументов(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоЖурналДокументов(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоРегистр
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоРегистр.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоРегистр.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоРегистр
Функция ЭтоРегистр(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
	
		Возврат ЭтоРегистрСведений(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоРегистрНакопления(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоРегистрБухгалтерии(ОбъектДляПроверки, Кэш, ТипОбъекта)
				Или ЭтоРегистрРасчета(ОбъектДляПроверки, Кэш, ТипОбъекта);
				
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоРегистр(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоРегистр(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
			
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоРегистрСведений
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоРегистрСведений.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоРегистрСведений.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоРегистрСведений
Функция ЭтоРегистрСведений(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "РЕГИСТРСВЕДЕНИЙ.") Или СтрНачинаетсяС(ВРегСтрока, "РЕГИСТРЫСВЕДЕНИЙ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоРегистрСведений(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоРегистрСведений(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоРегистрНакопления
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоРегистрНакопления.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоРегистрНакопления.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоРегистрНакопления
Функция ЭтоРегистрНакопления(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "РЕГИСТРНАКОПЛЕНИЯ.") Или СтрНачинаетсяС(ВРегСтрока, "РЕГИСТРЫНАКОПЛЕНИЯ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоРегистрНакопления(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоРегистрНакопления(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоРегистрБухгалтерии
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоРегистрБухгалтерии.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоРегистрБухгалтерии.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоРегистрБухгалтерии
Функция ЭтоРегистрБухгалтерии(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "РЕГИСТРБУХГАЛТЕРИИ.") Или СтрНачинаетсяС(ВРегСтрока, "РЕГИСТРЫБУХГАЛТЕРИИ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоРегистрБухгалтерии(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоРегистрБухгалтерии(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоРегистрРасчета
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоРегистрРасчета.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоРегистрРасчета.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоРегистрРасчета
Функция ЭтоРегистрРасчета(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "РЕГИСТРРАСЧЕТА.") Или СтрНачинаетсяС(ВРегСтрока, "РЕГИСТРЫРАСЧЕТА.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоРегистрРасчета(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоРегистрРасчета(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

// См. Спец_ОбщегоНазначения.ЭтоКонстанта
// 
// Параметры:
//  ОбъектДляПроверки - см. Спец_ОбщегоНазначения.ЭтоКонстанта.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. Спец_ОбщегоНазначения.ЭтоКонстанта.ТипОбъекта
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначения.ЭтоКонстанта
Функция ЭтоКонстанта(Знач ОбъектДляПроверки, Знач Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда
		
		ВРегСтрока = ВРег(ОбъектДляПроверки);
		Возврат СтрНачинаетсяС(ВРегСтрока, "КОНСТАНТА.") Или СтрНачинаетсяС(ВРегСтрока, "КОНСТАНТЫ.");
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ЭтоКонстанта(ОбъектДляПроверки, ТипОбъекта);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ЭтоКонстанта(ОбъектДляПроверки, Кэш, ТипОбъекта);
		#КонецЕсли
		
	КонецЕсли;

КонецФункции

#КонецОбласти

// Копировал из БСП
//@skip-check statement-type-change
//@skip-check invocation-parameter-type-intersect
//@skip-check property-return-type
#Область ДинамическийСписок

// Найти элемент или группу отбора по заданному имени поля или представлению.
//
// Параметры:
//  ОбластьПоиска - ОтборКомпоновкиДанных
//                - КоллекцияЭлементовОтбораКомпоновкиДанных
//                - ГруппаЭлементовОтбораКомпоновкиДанных    - контейнер с элементами и группами отбора,
//                                                             например Список.Отбор или группа в отборе.
//  ИмяПоля       - Строка - имя поля компоновки (не используется для групп).
//  Представление - Строка - представление поля компоновки.
//
// Возвращаемое значение:
//  Массив из ОтборКомпоновкиДанных, КоллекцияЭлементовОтбораКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных - коллекция отборов.
//
Функция НайтиЭлементыИГруппыОтбора(Знач ОбластьПоиска, Знач ИмяПоля = Неопределено, Знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	Возврат МассивЭлементов;
	
КонецФункции

// Добавить группу отбора в коллекцию КоллекцияЭлементов.
//
// Параметры:
//  КоллекцияЭлементов - ОтборКомпоновкиДанных
//                     - КоллекцияЭлементовОтбораКомпоновкиДанных
//                     - ГруппаЭлементовОтбораКомпоновкиДанных    - контейнер с элементами и группами отбора,
//                                                                  например Список.Отбор или группа в отборе.
//  Представление      - Строка - представление группы.
//  ТипГруппы          - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы.
//
// Возвращаемое значение:
//  ГруппаЭлементовОтбораКомпоновкиДанных - группа отбора.
//
Функция СоздатьГруппуЭлементовОтбора(Знач КоллекцияЭлементов, Представление, ТипГруппы) Экспорт
	
	Если ТипЗнч(КоллекцияЭлементов) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных")
		Или ТипЗнч(КоллекцияЭлементов) = Тип("ОтборКомпоновкиДанных") Тогда
		
		КоллекцияЭлементов = КоллекцияЭлементов.Элементы;
	КонецЕсли;
	
	ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);
	Если ГруппаЭлементовОтбора = Неопределено Тогда
		ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	Иначе
		ГруппаЭлементовОтбора.Элементы.Очистить();
	КонецЕсли;
	
	ГруппаЭлементовОтбора.Представление    = Представление;
	ГруппаЭлементовОтбора.Применение       = ТипПримененияОтбораКомпоновкиДанных.Элементы;
	ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	ГруппаЭлементовОтбора.ТипГруппы        = ТипГруппы;
	ГруппаЭлементовОтбора.Использование    = Истина;
	
	Возврат ГруппаЭлементовОтбора;
	
КонецФункции

// Добавить элемент компоновки в контейнер элементов компоновки.
//
// Параметры:
//  ОбластьДобавления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                                 например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  ПравоеЗначение          - Произвольный - сравниваемое значение.
//  Представление           - Строка - представление элемента компоновки данных.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
// Возвращаемое значение:
//  ЭлементОтбораКомпоновкиДанных - элемент компоновки.
//
Функция ДобавитьЭлементКомпоновки(ОбластьДобавления,
									Знач ИмяПоля,
									Знач ВидСравнения,
									Знач ПравоеЗначение = Неопределено,
									Знач Представление  = Неопределено,
									Знач Использование  = Неопределено,
									Знач РежимОтображения = Неопределено,
									Знач ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;
	
	Если РежимОтображения = Неопределено Тогда
		Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	Иначе
		Элемент.РежимОтображения = РежимОтображения;
	КонецЕсли;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;
	
	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;
	
	// Важно: установка идентификатора должна выполняться
	// в конце настройки элемента, иначе он будет скопирован
	// в пользовательские настройки частично заполненным.
	Если ИдентификаторПользовательскойНастройки <> Неопределено Тогда
		Элемент.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
	ИначеЕсли Элемент.РежимОтображения <> РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		Элемент.ИдентификаторПользовательскойНастройки = ИмяПоля;
	КонецЕсли;
	
	Возврат Элемент;
	
КонецФункции

// Изменить элемент отбора с заданным именем поля или представлением.
//
// Параметры:
//  ОбластьПоиска - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                             например Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  Представление           - Строка - представление элемента компоновки данных.
//  ПравоеЗначение          - Произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
//
// Возвращаемое значение:
//  Число - количество измененных элементов.
//
Функция ИзменитьЭлементыОтбора(ОбластьПоиска,
								Знач ИмяПоля = Неопределено,
								Знач Представление = Неопределено,
								Знач ПравоеЗначение = Неопределено,
								Знач ВидСравнения = Неопределено,
								Знач Использование = Неопределено,
								Знач РежимОтображения = Неопределено,
								Знач ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;
		Если ПравоеЗначение <> Неопределено Тогда
			Элемент.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
		Если РежимОтображения <> Неопределено Тогда
			Элемент.РежимОтображения = РежимОтображения;
		КонецЕсли;
		Если ИдентификаторПользовательскойНастройки <> Неопределено Тогда
			Элемент.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивЭлементов.Количество();
	
КонецФункции

// Удалить элементы отбора с заданным именем поля или представлением.
//
// Параметры:
//  ОбластьУдаления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                               например, Список.Отбор или группа в отборе..
//  ИмяПоля         - Строка - имя поля компоновки (не используется для групп).
//  Представление   - Строка - представление поля компоновки.
//
Процедура УдалитьЭлементыГруппыОтбора(Знач ОбластьУдаления, Знач ИмяПоля = Неопределено, Знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив; // Массив из ЭлементОтбораКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных
	
	НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если Элемент.Родитель = Неопределено Тогда
			ОбластьУдаления.Элементы.Удалить(Элемент);
		Иначе
			Элемент.Родитель.Элементы.Удалить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавить или заменить существующий элемент отбора.
//
// Параметры:
//  ОбластьПоискаДобавления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                     например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  ПравоеЗначение          - Произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Представление           - Строка - представление элемента компоновки данных.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления,
								Знач ИмяПоля,
								Знач ПравоеЗначение = Неопределено,
								Знач ВидСравнения = Неопределено,
								Знач Представление = Неопределено,
								Знач Использование = Неопределено,
								Знач РежимОтображения = Неопределено,
								Знач ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование, РежимОтображения, ИдентификаторПользовательскойНастройки);
	
	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			Если ТипЗнч(ПравоеЗначение) = Тип("Массив")
				Или ТипЗнч(ПравоеЗначение) = Тип("ФиксированныйМассив")
				Или ТипЗнч(ПравоеЗначение) = Тип("СписокЗначений") Тогда
				ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
			Иначе
				ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			КонецЕсли;
		КонецЕсли;
		Если РежимОтображения = Неопределено Тогда
			РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование, РежимОтображения, ИдентификаторПользовательскойНастройки);
	КонецЕсли;
	
КонецПроцедуры

// Добавить или заменить существующий элемент отбора динамического списка.
//
// Параметры:
//   ДинамическийСписок - ДинамическийСписок - список, в котором требуется установить отбор.
//   ИмяПоля            - Строка - поле, по которому необходимо установить отбор.
//   ПравоеЗначение     - Произвольный - значение отбора.
//       Необязательный. Значение по умолчанию Неопределено.
//       Внимание! Если передать Неопределено, то значение не будет изменено.
//   ВидСравнения  - ВидСравненияКомпоновкиДанных - условие отбора.
//   Представление - Строка - представление элемента компоновки данных.
//       Необязательный. Значение по умолчанию Неопределено.
//       Если указано, то выводится только флажок использования с указанным представлением (значение не выводится).
//       Для очистки (чтобы значение снова выводилось) следует передать пустую строку.
//   Использование - Булево - флажок использования этого отбора.
//       Необязательный. Значение по умолчанию: Неопределено.
//   РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - способ отображения этого отбора
//                                                                          пользователю:
//        РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ - в группе быстрых настроек над списком.
//        РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный       - в настройка списка (в подменю Еще).
//        РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный   - запретить пользователю менять этот отбор.
//   ИдентификаторПользовательскойНастройки - Строка - уникальный идентификатор этого отбора.
//       Используется для связи с пользовательскими настройками.
//
Процедура УстановитьЭлементОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля,
	ПравоеЗначение = Неопределено,
	ВидСравнения = Неопределено,
	Представление = Неопределено,
	Использование = Неопределено,
	РежимОтображения = Неопределено,
	ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	Если РежимОтображения = Неопределено Тогда
		РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	КонецЕсли;
	
	Если РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор;
	Иначе
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор;
	КонецЕсли;
	
	УстановитьЭлементОтбора(
		ОтборДинамическогоСписка,
		ИмяПоля,
		ПравоеЗначение,
		ВидСравнения,
		Представление,
		Использование,
		РежимОтображения,
		ИдентификаторПользовательскойНастройки);
	
КонецПроцедуры

// Удалить элемент группы отбора динамического списка.
//
// Параметры:
//  ДинамическийСписок - ДинамическийСписок - реквизит формы, для которого требуется установить отбор.
//  ИмяПоля         - Строка - имя поля компоновки (не используется для групп).
//  Представление   - Строка - представление поля компоновки.
//
Процедура УдалитьЭлементыГруппыОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля = Неопределено, Представление = Неопределено) Экспорт
	
	УдалитьЭлементыГруппыОтбора(
		ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор,
		ИмяПоля,
		Представление);
	
	УдалитьЭлементыГруппыОтбора(
		ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор,
		ИмяПоля,
		Представление);
	
КонецПроцедуры

// Установить или обновить значение параметра ИмяПараметра динамического списка Список.
//
// Параметры:
//  Список          - ДинамическийСписок - реквизит формы, для которого требуется установить параметр.
//  ИмяПараметра    - Строка             - имя параметра динамического списка.
//  Значение        - Произвольный        - новое значение параметра.
//  Использование   - Булево             - признак использования параметра.
//
Процедура УстановитьПараметрДинамическогоСписка(Список, ИмяПараметра, Значение, Использование = Истина) Экспорт
	
	ЗначениеПараметраКомпоновкиДанных = Список.Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
	Если ЗначениеПараметраКомпоновкиДанных <> Неопределено Тогда
		Если Использование И ЗначениеПараметраКомпоновкиДанных.Значение <> Значение Тогда
			ЗначениеПараметраКомпоновкиДанных.Значение = Значение;
		КонецЕсли;
		Если ЗначениеПараметраКомпоновкиДанных.Использование <> Использование Тогда
			ЗначениеПараметраКомпоновкиДанных.Использование = Использование;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Находит элемент отбора по представлению
// 
// Параметры:
//  КоллекцияЭлементов - ОтборКомпоновкиДанных, КоллекцияЭлементовОтбораКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных - Коллекция элементов
//  Представление - Строка
// 
// Возвращаемое значение:
//  Неопределено, ЭлементОтбораКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных -
// 
Функция НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление) Экспорт
	
	ВозвращаемоеЗначение = Неопределено;
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		Если ЭлементОтбора.Представление = Представление Тогда
			ВозвращаемоеЗначение = ЭлементОтбора;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

#КонецОбласти

// ++ Спец_БСП.Версия1С_14_ВышеИлиРавно
#Область РаботаСКластером1С

#Если Не ВебКлиент И Не ВнешнееСоединение Тогда

// Метод для установки блокировки входа в текущую базу и для удаления всех активных сеансов (кроме текущего пользователя).
// 
// Параметры:
//  УстановитьБлокировку - Булево - Нужный флаг блокировки. Если ИСТИНА, то сеансы будут заблокированы.
//  ТекстСообщенияБлокировки - Строка - Сообщение, выводимое при удалении сеанса.
Процедура УстановитьБлокировкуДляТекущейБазыКромеТекущегоПользователя(Знач УстановитьБлокировку = Истина, Знач ТекстСообщенияБлокировки = "") Экспорт
	
	База = ПодключитьсяКБазеВКластере();
	Если База = Неопределено Тогда
		
		СообщитьПользователю("Не удалось подключиться к текущей базе в кластере!");
		Возврат;
		
	КонецЕсли;
	
	УстановитьБлокировкуСеансовВБазе(База, УстановитьБлокировку, ТекстСообщенияБлокировки);
	Если УстановитьБлокировку Тогда
		
		ИмяПользователя = ВРег(ТекущийПользователь1С());
		Если Не ПустаяСтрока(ИмяПользователя) Тогда
			
			Для Каждого Сеанс Из База.ПолучитьСеансы() Цикл
				
				Если ВРег(Сеанс.ИмяПользователя) <> ИмяПользователя Тогда
					
					Попытка
						Сеанс.ЗавершитьСеанс(ТекстСообщенияБлокировки);
					Исключение
						ДобавитьОшибку(ИнформацияОбОшибке(), "Удаление сеанса пользователя " + Сеанс.ИмяПользователя);
					КонецПопытки;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает кластер сервера по адресу. Так как в большинстве ситуаций кластер всего один, возвращает первый попавшийся.
// 
// Параметры:
//  АдресСервера - Строка - Имя сервера для подключения. Если передана пустая строка, подставляет адрес текущей базы
//  Порт - Число - Порт подключения. Если передан 0, подставляет порт текущей базы (указанный в Спец_Базы).
// 
// Возвращаемое значение:
//  АдминистрированиеКластер, Неопределено - Нулевой кластер сервера
Функция ПодключитьсяККластеруСервера(Знач АдресСервера, Знач Порт = 0) Экспорт
	
	Если ПустаяСтрока(АдресСервера) Или Порт = 0 Тогда
		
		СтруктураБазы = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы();
		Если ПустаяСтрока(АдресСервера) Тогда
			АдресСервера = СтруктураБазы.АдресСервераИБ;
		КонецЕсли;
		Если Порт = 0 Тогда
			Порт = СтруктураБазы.ПортКластераИБ;
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		
		АдминистрированиеСервера = Новый АдминистрированиеСервера(АдресСервера, Порт);
		
	Исключение
		
		//@skip-check unknown-method-property
		Спец_ОбщегоНазначенияВызовСервера.ЗапуститьДемонКластера();
		
		Попытка
			АдминистрированиеСервера = Новый АдминистрированиеСервера(АдресСервера, Порт);
		Исключение
			Возврат Неопределено;
		КонецПопытки;
		
	КонецПопытки;
	
	АдминистрированиеСервера.ВыполнитьАутентификацию("", "");
	
	ВсеКластеры = АдминистрированиеСервера.ПолучитьКластеры();
	Если ВсеКластеры.Количество() > 0 Тогда
		
		Кластер = ВсеКластеры.Получить(0);
		Кластер.ВыполнитьАутентификацию("", "");
		
	КонецЕсли;
	
	Возврат Кластер;
	
КонецФункции

// Возвращает подключение к информационной базе в нулевой кластере по адресу сервера. Базу ищет по наименованию.
// Если какой-либо параметр не указан, то подставляет по умолчанию для текущей базы.
// Имя пользователя и пароль для подключения к базе берёт из констант (ИмяПользователяПоУмолчанию и ПарольПользователяПоУмолчанию).
// 
// Параметры:
//  АдресСервера - Строка - Адрес сервера для подключения
//  Порт - Число - Порт подключения
//  ИмяБазы - Строка - Наименование базы для подключения.
// 
// Возвращаемое значение:
//  Неопределено, АдминистрированиеИнформационнаяБаза - 
Функция ПодключитьсяКБазеВКластере(Знач АдресСервера = "", Знач Порт = 0, Знач ИмяБазы = "") Экспорт
	
	Если ПустаяСтрока(АдресСервера) Или Порт = 0 Или ПустаяСтрока(ИмяБазы) Тогда
		
		СтруктураБазы = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы();
		Если ПустаяСтрока(АдресСервера) Тогда
			АдресСервера = СтруктураБазы.АдресСервераИБ;
		КонецЕсли;
		Если ПустаяСтрока(ИмяБазы) Тогда
			ИмяБазы = ВРег(СтруктураБазы.ИмяБазы);
		КонецЕсли;
		Если Порт = 0 Тогда
			Порт = СтруктураБазы.ПортКластераИБ;
		КонецЕсли;
		
	КонецЕсли;
	
	ТекущийКластер = ПодключитьсяККластеруСервера(АдресСервера, Порт);
	Если ТекущийКластер = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивБаз   = ТекущийКластер.ПолучитьИнформационныеБазы();
	ВРегИмяБазы = ВРег(ИмяБазы);
	
	Для Каждого База Из МассивБаз Цикл
		
		Если ВРег(База.Имя) = ВРегИмяБазы Тогда
			
			ИмяПользователя = Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.ИмяПользователяПоУмолчанию"), ""); // Строка
			Пароль = Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.ПарольПользователяПоУмолчанию"), ""); // Строка
			
			Попытка
				
				База.ВыполнитьАутентификацию(ИмяПользователя, Пароль);
				Возврат База;
				
			Исключение
				
				ДобавитьОшибку(ИнформацияОбОшибке(), "Аутентификация к базе " + База.Имя);
				
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Метод для удаления подвисших сеансов. Если это фоновое задание (имя приложения не 1cv8), то ограничение удваивается. Это сделано в основном для фоновых заданий.
// 
// Параметры:
//  Кластер - АдминистрированиеКластер - Кластер для удаления сеансов
//  ОграничениеВызоваДляУдаленияСеанса - Число - Ограничение вызова для удаления сеанса. Если текущее время вызова превышает данное значение, сеанс будет удалён.
Процедура ПопытатьсяЗавершитьЗависшиеСеансы(Знач Кластер, Знач ОграничениеВызоваДляУдаленияСеанса = 600) Экспорт
	
	ТекущаяДата   = ТекущаяДатаПоНормальному();
	МассивСеансов = Кластер.ПолучитьСеансы();
	
	// Культурное удаление.
	Для Каждого АдминистрированиеСеанс Из МассивСеансов Цикл
		
		Удаляем = Ложь;
		Если ТекущаяДата - Спец_КонстантыКлиентСервер.СекундВСутках() >= АдминистрированиеСеанс.ВремяНачала Тогда
			Удаляем = Истина;
		КонецЕсли;
		
		Если Не Удаляем Тогда
			
			Если Не СтрНачинаетсяС(ВРег(АдминистрированиеСеанс.ИмяПриложения), "1CV8") Тогда
				Удаляем = АдминистрированиеСеанс.ДлительностьВызововТекущее / 1000 > ОграничениеВызоваДляУдаленияСеанса * 2;
			Иначе
				Удаляем = АдминистрированиеСеанс.ДлительностьВызововТекущее / 1000 > ОграничениеВызоваДляУдаленияСеанса;
			КонецЕсли;
			
		КонецЕсли;
		
		Если Удаляем Тогда
			
			Попытка
				АдминистрированиеСеанс.ЗавершитьСеанс("Сеанс зависший. Удаляем.");
			Исключение
				ДобавитьОшибку(ИнформацияОбОшибке(), "Не удалось удалить зависший сеанс пользователя " + АдминистрированиеСеанс.ИмяПользователя);
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает параметры перезапуска и принудительного завершения процессов для кластера.
// 
// Параметры:
//  Кластер - АдминистрированиеКластер - Кластер для установки параметров
//  ВремяПринудительногоЗавершения - Число - Время для принудительного завершения проблемных процессов
//  ПериодПерезапускаПроцесса - Число - Интервал перезапуска рабочих процессов
Процедура УстановитьОграниченияДляСеансовВКластере(Знач Кластер, Знач ВремяПринудительногоЗавершения, Знач ПериодПерезапускаПроцесса) Экспорт
	
	Кластер.ВремяПринудительногоЗавершения = ВремяПринудительногоЗавершения;
	Кластер.ПериодПерезапускаПроцесса = ПериодПерезапускаПроцесса;
	
	Кластер.Записать();
	
КонецПроцедуры

// Установавливает блокировку сеансов в нужной базе.
// 
// Параметры:
//  База - АдминистрированиеИнформационнаяБаза - База для установки блокировки
//  ЗначениеБлокировки - Булево - Значение блокировки
//  ТекстСообщенияБлокировки - Строка - Сообщение заблокированной базы
Процедура УстановитьБлокировкуСеансовВБазе(Знач База, Знач ЗначениеБлокировки = Истина, Знач ТекстСообщенияБлокировки = "") Экспорт
	
	База.ВключенаБлокировкаНачалаСеансов = ЗначениеБлокировки;
	
	Если ЗначениеБлокировки Тогда
		База.СообщениеБлокировки = ТекстСообщенияБлокировки;
	КонецЕсли;
	
	База.Записать();
	
КонецПроцедуры

// Устанавливает блокировку регламентных заданий в нужной базе.
// 
// Параметры:
//  База - АдминистрированиеИнформационнаяБаза - База для установки блокировки
//  ЗначениеБлокировки - Булево - Флаг блокировки
Процедура УстановитьБлокировкуРегламентныхЗаданийВБазе(Знач База, Знач ЗначениеБлокировки = Истина) Экспорт
	
	База.БлокировкаРегламентныхЗаданий = ЗначениеБлокировки;
	База.Записать();
	
КонецПроцедуры

#КонецЕсли

#КонецОбласти
// -- Спец_БСП.Версия1С_14_ВышеИлиРавно

//@skip-check transfer-object-between-client-server
#Область ЧертовВебКлиент

// ПолучитьИмяВременногоФайла (по-нормальному)
// 
// Параметры:
//  Расширение - Строка
// 
// Возвращаемое значение:
//  Строка
Функция ПолучитьИмяВременногоФайлаПоНормальному(Знач Расширение = "") Экспорт

	#Если ВебКлиент Тогда
		
		Возврат КаталогВременныхФайлов()
				+ Спец_СтроковыеФункцииКлиентСервер.ОчиститьИмяДляЗапроса(Строка(Новый УникальныйИдентификатор()))
				+ ?(Не ПустаяСтрока(Расширение), "." + Расширение, ".tmp");
	
	#Иначе
		
		Возврат ПолучитьИмяВременногоФайла(Расширение);
		
	#КонецЕсли 

КонецФункции

// СериализаторXDTO.XMLСтрока (по-нормальному)
// 
// Параметры:
//  ЗначениеДляОбработки - Произвольный
// 
// Возвращаемое значение:
//  Строка
Функция ПолучитьXMLСтрокуПоНормальному(Знач ЗначениеДляОбработки) Экспорт

	#Если Не ВебКлиент Тогда
		
		Попытка
			Возврат СериализаторXDTO.XMLСтрока(ЗначениеДляОбработки);
		Исключение
			Возврат "";
		КонецПопытки;
		
	#Иначе
		
		Возврат Спец_ОбщегоНазначенияВызовСервера.XMLСтрокаПрограммно(ЗначениеДляОбработки);
		
	#КонецЕсли

КонецФункции

// СериализаторXDTO.XMLЗначение (по-нормальному)
// 
// Параметры:
//  НужныйТип - Тип
//  ЗначениеДляОбработки - Строка
// 
// Возвращаемое значение:
//  Произвольный
Функция ПолучитьXMLЗначениеПоНормальному(Знач НужныйТип, Знач ЗначениеДляОбработки) Экспорт

	#Если Не ВебКлиент Тогда
		
		Попытка
			Возврат СериализаторXDTO.XMLЗначение(НужныйТип, ЗначениеДляОбработки);
		Исключение
			Возврат Неопределено;
		КонецПопытки;
		
	#Иначе
		
		Возврат Спец_ОбщегоНазначенияВызовСервера.XMLЗначениеПрограммно(НужныйТип, ЗначениеДляОбработки);
		
	#КонецЕсли

КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

//@skip-check structure-consructor-too-many-keys
//@skip-check constructor-function-return-section
//
// Возвращаемое значение:
//  Структура
Функция БазовыйКэш() Экспорт
	
	Кэш = Новый Структура();
	Кэш.Вставить("КэшПараметровЗаполненияТаблиц", Новый Соответствие());
	Кэш.Вставить("МассивЗарегистрированныхЗапросов", Новый Массив());
	Кэш.Вставить("ТекущийТаймАутHTTPЗапросов", 300);
	Кэш.Вставить("КомпонентыPostgreSQLДляДругихБаз", Новый Соответствие());
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Кэш.Вставить("ПропуститьЛогирование", Ложь);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	#Если Клиент Тогда
		
		// ++ Спец_БСП.ОбменСДругимиБазами_ЧтоТоЕсть
		Кэш.Вставить("КэшДляВнешнихСобытийHTTPЗапросов", Новый Соответствие());
		// -- Спец_БСП.ОбменСДругимиБазами_ЧтоТоЕсть
		
	#КонецЕсли
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Кэш.Вставить("УровниЛогирования", Спец_ЛогированиеОбъектовВызовСервера.ПолучитьСоответствиеУровнейЛогирования());
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		СтруктураКэшПоМетаданным = Новый Структура(
				
				"ИменаМетаданныхПоТипу,
				|ЭтоСсылочныйТип",
				
				Новый Соответствие(),
				Новый Соответствие());
		
	#Иначе
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Кэш.Вставить("УровниЛогирования", Спец_ЛогированиеОбъектов.ПолучитьСоответствиеУровнейЛогирования());
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		СтруктураКэшПоМетаданным = Новый Структура(
				
				"ОбъектМетаданныхПоТипу,
				|ЭтоКакойТоОбъектПоИмени,
				|СтруктураМетаданныхПоТипу,
				|СтруктураМетаданныхПоПолномуИмени,
				|ВсеРеквизитыОбъекта,
				|МассивОсновныхИзмерений,
				|ЭтоСсылочныйТип",
				
				Новый Соответствие(),
				Неопределено,
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Структура("ЧерезИмена, ЧерезМетаданные", Новый Соответствие, Новый Соответствие),
				Новый Соответствие(),
				Новый Соответствие());
		
		СтруктураЭтоКакойТоОбъект = Новый Структура(
				
				"ЭтоСправочник,
				|ЭтоДокумент,
				|ЭтоПеречисление,
				|ЭтоПланВидовХарактеристик,
				|ЭтоПланСчетов,
				|ЭтоПланВидовРасчета,
				|ЭтоБизнесПроцесс,
				|ЭтоЗадача,
				|ЭтоПланОбмена,
				|ЭтоЖурналДокументов,
				|ЭтоРегистрСведений,
				|ЭтоРегистрНакопления,
				|ЭтоРегистрБухгалтерии,
				|ЭтоРегистрРасчета,
				|ЭтоКонстанта",
				
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие(),
				Новый Соответствие());
		
		СтруктураКэшПоМетаданным.ЭтоКакойТоОбъектПоИмени = Новый ФиксированнаяСтруктура(СтруктураЭтоКакойТоОбъект);
		
	#КонецЕсли
	
	Кэш.Вставить("КэшПоМетаданным", СтруктураКэшПоМетаданным);
	
	#Если Не Клиент Тогда
		Кэш.Вставить("ДляПроверкиЦелостности", Метаданные.Справочники.Спец_Базы);
	#КонецЕсли
	
	Возврат Кэш;
	
КонецФункции

Функция РассчитатьТипОС() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	Если СистемнаяИнфо.ТипПлатформы = ТипПлатформы.Windows_x86 Или СистемнаяИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
		
		#Если ВебКлиент Тогда
			
			Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows");
			
		#Иначе
			
			Если НайтиФайлы("\etc", "sysctl.conf", Ложь).Количество() > 0 Тогда
				Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine");
			Иначе
				Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows");
			КонецЕсли;
			
		#КонецЕсли
		
	ИначеЕсли СистемнаяИнфо.ТипПлатформы = ТипПлатформы.Linux_x86 Или СистемнаяИнфо.ТипПлатформы = ТипПлатформы.Linux_x86_64 Тогда
		
		Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.UNIX");
		
	Иначе
		
		Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.ПустаяСсылка");
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  ТипОСКэш - ПеречислениеСсылка.Спец_ОперационныеСистемы, Неопределено - Тип ОСКэш
// 
// Возвращаемое значение:
//  Строка
Функция ВычислитьТекущегоПользователяСистемы(Знач ТипОСКэш = Неопределено) Экспорт
	
	Если ТипОСКэш <> Неопределено Тогда
		
		Если ТипОСКэш = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows")
			Или ТипОСКэш = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine") Тогда
			
			ИмяПользователяОС = ВыполнитьКомандуСистемы("echo %username%", , , , ТипОСКэш); // Строка
			
		Иначе
			
			ИмяПользователяОС = ВыполнитьКомандуСистемы("whoami", , , , ТипОСКэш); // Строка
			
		КонецЕсли;
		
	ИначеЕсли ЭтоWindows() Или ЭтоWine() Тогда
		
		ИмяПользователяОС = ВыполнитьКомандуСистемы("echo %username%"); // Строка
		
	Иначе
		
		ИмяПользователяОС = ВыполнитьКомандуСистемы("whoami");
		
	КонецЕсли;
	
	Возврат СокрЛП(ИмяПользователяОС);
	
КонецФункции

// Параметры:
//  КодОтвета - Число
//  ДополнительныеПараметры - см. ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКоманды
// 
// Возвращаемое значение:
//  Булево, Строка - Выполнить команду системы после выполнения с результатом
Функция ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом(Знач КодОтвета, Знач ДополнительныеПараметры) Экспорт
	
	СтрокаРезультат = ПрочитатьЧтениеТекста(ДополнительныеПараметры.ВременныйФайл, ДополнительныеПараметры.КодировкаДляЧтения);
	СтрокаРезультат = Спец_СтроковыеФункцииКлиентСервер.УдалитьНедопустимыеСимволыXMLПрограммно(СтрокаРезультат); // На всякий случай
	
	УдалитьФайлыНеМешаяРаботе(ДополнительныеПараметры.ВременныйФайл);
	
	#Если Клиент Тогда
		
		Если ДополнительныеПараметры.ОписаниеОповещенияРезультат <> Неопределено Тогда
			
			//@skip-check invocation-parameter-type-intersect
			ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ОписаниеОповещенияРезультат, СтрокаРезультат);
			Возврат Истина;
			
		КонецЕсли;
		
	#КонецЕсли
	
	Возврат СтрокаРезультат;
	
КонецФункции

// Структура дополнительных параметров для выполнения команды системы.
// 
// Параметры:
//  НужнаяКодировка - Строка, КодировкаТекста - Кодировка для чтения результата
//  ОписаниеОповещениеРезультат - Неопределено, ОписаниеОповещения -
// 
// Возвращаемое значение:
//  Структура:
// * ОписаниеОповещенияРезультат - Неопределено, ОписаниеОповещения -
// * ВременныйФайл - Строка
// * КодировкаДляЧтения - Строка, КодировкаТекста -
Функция ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКоманды(Знач НужнаяКодировка = "UTF-8", Знач ОписаниеОповещениеРезультат = Неопределено) Экспорт
	
	Возврат Новый Структура("ОписаниеОповещенияРезультат, ВременныйФайл, КодировкаДляЧтения",
			ОписаниеОповещениеРезультат,
			ПолучитьИмяВременногоФайлаПоНормальному("txt"),
			НужнаяКодировка);
	
КонецФункции

// Параметры:
//  ИнформацияОбОшибке - ИнформацияОбОшибке
//  СмещениеТекста - Строка
// 
// Возвращаемое значение:
//  Строка
Функция ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(Знач ИнформацияОбОшибке, Знач СмещениеТекста = "") Экспорт
	
	// ++ Спец_БСП.Версия1С_17_ВышеИлиРавно
	//@skip-check unknown-method-property
	Возврат Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке), СмещениеТекста);
	// -- Спец_БСП.Версия1С_17_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_17_Ниже
	////Возврат Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке), СмещениеТекста);
	// -- Спец_БСП.Версия1С_17_Ниже
	
КонецФункции

// Параметры:
//  ИнформацияОбОшибке - ИнформацияОбОшибке
//  СмещениеТекста - Строка
// 
// Возвращаемое значение:
//  Строка
Функция КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(Знач ИнформацияОбОшибке, Знач СмещениеТекста = "") Экспорт
	
	// ++ Спец_БСП.Версия1С_17_ВышеИлиРавно
	//@skip-check unknown-method-property
	Возврат Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СмещениеТекста);
	// -- Спец_БСП.Версия1С_17_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_17_Ниже
	////Возврат Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СмещениеТекста);
	// -- Спец_БСП.Версия1С_17_Ниже
	
КонецФункции

// Картинка восклицательный знак по нормальному.
// 
// Возвращаемое значение:
//  Картинка - Картинка восклицательный знак по нормальному
Функция КартинкаВосклицательныйЗнакПоНормальному() Экспорт
	
	// ++ Спец_БСП.Версия1С_16_Ниже
	////Возврат БиблиотекаКартинок.Справка;
	// -- Спец_БСП.Версия1С_16_Ниже
	
	// ++ Спец_БСП.Версия1С_16_ВышеИлиРавно
	// ++ Спец_БСП.Версия1С_21_Ниже
	////Возврат БиблиотекаКартинок.ОформлениеВоcклицательныйЗнак;
	// -- Спец_БСП.Версия1С_21_Ниже
	// -- Спец_БСП.Версия1С_16_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_21_ВышеИлиРавно
	Возврат БиблиотекаКартинок.ОформлениеВосклицательныйЗнак;
	// -- Спец_БСП.Версия1С_21_ВышеИлиРавно
	
КонецФункции

// Параметры:
//  ИдентификаторЗапроса - Строка
//  URL - Строка
//  ТипЗапроса - Строка
//
//@skip-check structure-consructor-too-many-keys
//@skip-check constructor-function-return-section
//
// Возвращаемое значение:
//	Структура:
//		* ИдентификаторЗапроса - Строка
//		* URL - Строка
//		* ТипЗапроса - Строка
//		* КодОтвета - Число
//		* ВремяОтвета - Число
//		* Успешно - Булево
//		* ФайлРезультат - Строка
//		* ТелоРезультат - Строка
//		* UnixTimestampОтвета - Число
//		* ЗаголовкиРезультат - Соответствие из КлючИЗначение:
//			** Ключ - Строка
//			** Значение - Строка
//
Функция НоваяСтруктураРезультатаHTTPЗапроса(Знач ИдентификаторЗапроса, Знач URL, Знач ТипЗапроса) Экспорт
	
	Возврат Новый Структура(
			
			"ИдентификаторЗапроса,
			|URL,
			|ТипЗапроса,
			|КодОтвета,
			|ВремяОтвета,
			|Успешно,
			|UnixTimestampОтвета,
			|ЗаголовкиРезультат",
			
			ИдентификаторЗапроса,
			URL,
			ТипЗапроса,
			0,
			0,
			Ложь,
			0,
			Новый Соответствие());
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)
	
	Для Каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			
			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе
			
			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			
			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
//  ОбъектXDTO - ОбъектXDTO
//  ВСоответствие - Булево
//
//@skip-check typed-value-adding-to-untyped-collection
//
Функция ОбъектXDTOВСтруктуру_Рекурсия(Знач ОбъектXDTO, Знач ВСоответствие)
	
	#Если Не ВебКлиент Тогда
		
		Результат = ?(ВСоответствие, Новый Соответствие(), Новый Структура());
		Для Каждого Свойство Из ОбъектXDTO.Свойства() Цикл
			
			ТипСвойства = ТипЗнч(ОбъектXDTO[Свойство.Имя]);
			Если ТипСвойства = Тип("ОбъектXDTO") Тогда
				
				Результат.Вставить(Свойство.Имя, ОбъектXDTOВСтруктуру_Рекурсия(ОбъектXDTO[Свойство.Имя], ВСоответствие));
				
			ИначеЕсли ТипСвойства = Тип("СписокXDTO") Тогда
				
				Результат.Вставить(Свойство.Имя, Новый Массив());
				//@skip-check variable-value-type
				Для Каждого ЭлементСпискаXDTO Из ОбъектXDTO[Свойство.Имя] Цикл Результат[Свойство.Имя].Добавить(?(ТипЗнч(ЭлементСпискаXDTO) = Тип("ОбъектXDTO"), ОбъектXDTOВСтруктуру_Рекурсия(ЭлементСпискаXDTO, ВСоответствие), ЭлементСпискаXDTO)); КонецЦикла;
				
			Иначе
				
				Результат.Вставить(Свойство.Имя, ОбъектXDTO[Свойство.Имя]);
				
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Результат;
		
	#Иначе
		
		Возврат ?(ВСоответствие, Новый Соответствие(), Новый Структура());
		
	#КонецЕсли
	
КонецФункции

//@skip-check structure-consructor-too-many-keys
//@skip-check constructor-function-return-section
#Область Типизация

// Возвращаемое значение:
//	см. СтруктураURI
Функция НоваяСтруктураURIСсылки()
	
	Возврат Новый Структура(
			
			"Порт,
			|Схема,
			|Логин,
			|Пароль,
			|ИмяСервера,
			|Хост,
			|ПутьНаСервере",
			
			Неопределено,
			"",
			"",
			"",
			"",
			"",
			"");
	
КонецФункции

// Возвращаемое значение:
//	см. СтруктураИмениАдресаТипаБазыДанных
Функция НоваяСтруктураИмениАдресаТипаБазыДанных()
	
	Возврат Новый Структура("ИмяСервераИБ, ИмяБазыИБ, ЭтоФайловаяБаза",
			"",
			"",
			Ложь);
	
КонецФункции

// Возвращаемое значение:
//	см. Спец_ОбщегоНазначения.СтруктураПараметровБазы
Функция НоваяСтруктураПараметровБазы()
	
	Возврат Новый Структура(
			
			"ИмяБазы,
			|НаименованиеБазы,
			|ПолныйАдресFTP,
			|АдресСервераИБ,
			|ВидБазы,
			|ПортКластераИБ,
			|ПутьФайловВеб,
			|СтрокаПодключенияКБазеДанных,
			|ТипБазыДанных",
			
			"<Ошибка в транзакции>",
			"<Ошибка в транзакции>",
			"<Ошибка в транзакции>",
			"<Ошибка в транзакции>",
			"<Ошибка в транзакции>",
			0,
			"<Ошибка в транзакции>",
			"<Ошибка в транзакции>",
			ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.Неизвестный"));
	
КонецФункции

#КонецОбласти

#КонецОбласти
