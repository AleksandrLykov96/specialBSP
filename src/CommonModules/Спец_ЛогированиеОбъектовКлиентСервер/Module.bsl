// @strict-types

#Область ПрограммныйИнтерфейс

// Если переданный уровень логирования нужно записывать в регистр, то вернёт ИСТИНА
// 
// Параметры:
//  УровеньЛогирования - Строка, ПеречислениеСсылка.Спец_УровниЛогирования - Уровень логирования
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  
// Возвращаемое значение:
//  Булево - Данный уровень логирования нужно писать
//
Функция ДанныйУровеньЛогированияНужноПисать(Знач УровеньЛогирования, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	Возврат Не Кэш.ПропуститьЛогирование И Кэш.УровниЛогирования[УровеньЛогирования] = Истина;
	
КонецФункции

// Основной метод для записи лога
// 
// Параметры:
//  Источник - Строка - Источник лога
//  УровеньЛога - ПеречислениеСсылка.Спец_УровниЛогирования, Строка - Уровень лога. Если строка, то нужно передать имя перечисления
//  ТекстИлиОбъект - Произвольный - Текст лога или объект, представление которого нужно записать в логи
//  UnixTimestamp - Число - UnixTimestamp для записи
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ЗаписатьЛог(Знач Источник, Знач УровеньЛога, Знач ТекстИлиОбъект, Знач UnixTimestamp = 0, Кэш = Неопределено) Экспорт

	Если Не ДанныйУровеньЛогированияНужноПисать(УровеньЛога, Кэш) Тогда Возврат; КонецЕсли;
	
	Кэш.ПропуститьЛогирование = Истина;
	ЗаписатьГотовыйЛогВРегистр(Источник,
			УровеньЛога,
			Спец_СтроковыеФункцииКлиентСервер.СформироватьТекстовоеПредставлениеОбъекта(ТекстИлиОбъект),
			UnixTimestamp,
			Неопределено,
			Кэш);
	Кэш.ПропуститьЛогирование = Ложь;
	
КонецПроцедуры

// Записать содержимое файла в лог.
// 
// Параметры:
//  Источник - Строка - Источник лога
//  УровеньЛога - ПеречислениеСсылка.Спец_УровниЛогирования, Строка - Уровень лога. Если строка, то нужно передать имя перечисления
//  ИмяФайла - Строка - Имя файла для записи в логи
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ЗаписатьСодержимоеФайлаВЛог(Знач Источник, Знач УровеньЛога, Знач ИмяФайла, Кэш = Неопределено) Экспорт
	
	ФайлДляПроверки = Новый Файл(ИмяФайла);
	Если Не ФайлДляПроверки.Существует() Тогда
		
		ТекстСообщения = СтрШаблон("Передан файл '%1', но он не существует.", ИмяФайла);
		ЗаписатьЛог(Источник, УровеньЛога, ТекстСообщения, 0, Кэш);
		
		Возврат;
		
	КонецЕсли;
	
	Если Не ДанныйУровеньЛогированияНужноПисать(УровеньЛога, Кэш) Тогда
		Возврат;
	КонецЕсли;
	
	ТекстСообщения = СтрШаблон(
			
			"Имя файла: %1
			|Размер: %2
			|Время изменения: %3
			|Только чтение: %4",
			
			ФайлДляПроверки.ПолноеИмя,
			ФайлДляПроверки.Размер(),
			Формат(ФайлДляПроверки.ПолучитьВремяИзменения(), "ДЛФ=DT;"),
			ФайлДляПроверки.ПолучитьТолькоЧтение());
	
	ЗаписатьГотовыйЛогВРегистр(Источник, УровеньЛога, ТекстСообщения, 0, Новый ДвоичныеДанные(ИмяФайла), Кэш);
	
КонецПроцедуры

// Метод для начала замера лога
// 
// Параметры:
//  Источник - Строка - Источник лога
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура НачатьЗамерДляЛогирования(Знач Источник, Кэш = Неопределено) Экспорт

	Если Не ДанныйУровеньЛогированияНужноПисать("Предупреждение", Кэш) Тогда Возврат; КонецЕсли;
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.НачатьЗамер(Источник, Кэш);
	
КонецПроцедуры

// Метод для записи в лог окончание замера. Если указано количество секунд предел,
// то если время выполнения больше, чем данное число, то лог будет записан.
// Если данное число не указано, лог будет записан в любом случае. 
// ВНИМАНИЕ: если НачатьЗамерДляЛогирования был вызван на сервере, то и данный метод нужно вызывать на сервере
// или передать НачалоЛогированияНаСервере = Истина
// 
// Параметры:
//  Источник - Строка - Источник лога
//  КоличествоСекундПределДляЗаписи - Число - Количество секунд предел
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  НачалоЛогированияНаСервере - Булево - Флаг того, что начало замера было запущено на сервере
//  ДополнительнаяИнформация - Произвольный - Дополнительная информация для записи в лог (например, ссылку на объект, чтобы понимать - какой объект открывали)
//
//@skip-check method-too-many-params
Процедура ЛогироватьЗавершениеЗамера(Знач Источник, Знач КоличествоСекундПределДляЗаписи = 0, Кэш = Неопределено,
		Знач НачалоЛогированияНаСервере = Ложь, Знач ДополнительнаяИнформация = Неопределено) Экспорт
	
	Если Не ДанныйУровеньЛогированияНужноПисать("Предупреждение", Кэш) Тогда Возврат; КонецЕсли;
	Если НачалоЛогированияНаСервере Тогда
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			ВремяВыполнения = Спец_КомпонентаДополнительныеФункцииВызовСервера.ЗавершитьЗамер(Источник);
		#Иначе
			ВремяВыполнения = Спец_КомпонентаДополнительныеФункцииКлиентСервер.ЗавершитьЗамер(Источник, Кэш);
		#КонецЕсли
		
	Иначе
		
		ВремяВыполнения = Спец_КомпонентаДополнительныеФункцииКлиентСервер.ЗавершитьЗамер(Источник, Кэш);
		
	КонецЕсли;
		
	ЭтоПревышение = КоличествоСекундПределДляЗаписи > 0 И ВремяВыполнения >= КоличествоСекундПределДляЗаписи;
	
	// ???
	//@skip-check unknown-method-property
	Если ЭтоПревышение Или ДанныйУровеньЛогированияНужноПисать("Информация", Кэш) Тогда

		УровеньЛогаДляЗаписи = ?(ЭтоПревышение,
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Информация"));
		
		ТекстЛога = "Окончание замера, время выполнения: " + Спец_СтроковыеФункцииКлиентСервер.ПеревестиСекундыВЧитемыйВид(ВремяВыполнения);
		
		ПредставлениеДополнительнойИнформации = Спец_СтроковыеФункцииКлиентСервер.СформироватьТекстовоеПредставлениеОбъекта(ДополнительнаяИнформация);
		Если Не ПустаяСтрока(ПредставлениеДополнительнойИнформации) Тогда
			Спец_СтроковыеФункцииКлиентСервер.ДобавитьСтрокуВТекст("Дополнительная информация: " + ПредставлениеДополнительнойИнформации, ТекстЛога, Символы.ПС);
		КонецЕсли;
		
		ЗаписатьГотовыйЛогВРегистр(Источник,
				УровеньЛогаДляЗаписи,
				ТекстЛога,
				0,
				Неопределено,
				Кэш);
	
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

//@skip-check unknown-method-property
//
// Параметры:
//  Форма - см. Спец_РаботаСФормами.ПриСозданииНаСервере.Форма
//  ЭтоУправляемаяФорма - см. Спец_ЛогированиеОбъектов.ДобавитьНаФормуКнопкуОткрытияЛогов.ЭтоУправляемаяФорма
// 
// Возвращаемое значение:
//  Булево
//
Функция ЛогиДоступныПоФорме(Знач Форма, Знач ЭтоУправляемаяФорма) Экспорт
	
	Возврат (ЭтоУправляемаяФорма И (Форма.Спец_ЭтоСсылочныйОбъект Или Форма.Спец_ЭтоРегистр)
					И Спец_ЛогированиеОбъектовВызовСервераПовтИсп.ТипЛогированияОбъекта(Форма.Спец_ПолноеИмяМетаданных) = 2)
			Или (Не ЭтоУправляемаяФорма И (Форма.ЭлементыФормы.Спец_ЭтоСсылочныйОбъект.Значение Или Форма.ЭлементыФормы.Спец_ЭтоРегистр.Значение)
					И Спец_ЛогированиеОбъектовВызовСервераПовтИсп.ТипЛогированияОбъекта(Форма.ЭлементыФормы.Спец_ПолноеИмяМетаданных.Значение) > 0);
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Параметры:
//  Источник - Строка
//  УровеньЛога - ПеречислениеСсылка.Спец_УровниЛогирования, Строка -
//  ТекстДляЗаписи - Строка
//  UnixTimestamp - Число
//  ДвоичныеДанныеФайла - Неопределено, ДвоичныеДанные - 
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ЗаписатьГотовыйЛогВРегистр(Знач Источник, Знач УровеньЛога, Знач ТекстДляЗаписи, Знач UnixTimestamp, Знач ДвоичныеДанныеФайла, Знач Кэш)
	
	// ++ Спец_БСП.Версия1С_18_ВышеИлиРавно
	
	#Если Клиент Тогда
		ЗаписатьГотовыйЛогВРегистрАсинх(Источник, УровеньЛога, ТекстДляЗаписи, UnixTimestamp, ДвоичныеДанныеФайла, Кэш);
	#Иначе
		ЗаписатьГотовыйЛогВРегистрСинх(Источник, УровеньЛога, ТекстДляЗаписи, UnixTimestamp, ДвоичныеДанныеФайла, Кэш);
	#КонецЕсли
	
	// -- Спец_БСП.Версия1С_18_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_18_Ниже
	////ЗаписатьГотовыйЛогВРегистрСинх(Источник, УровеньЛога, ТекстДляЗаписи, UnixTimestamp, ДвоичныеДанныеФайла, Кэш);
	// -- Спец_БСП.Версия1С_18_Ниже
	
КонецПроцедуры

Процедура ЗаписатьГотовыйЛогВРегистрСинх(Знач Источник, Знач УровеньЛога, Знач ТекстДляЗаписи, Знач UnixTimestamp, Знач ДвоичныеДанныеФайла, Знач Кэш)
	
	ТекстДляЗаписи = Спец_СтроковыеФункцииКлиентСервер.УдалитьНедопустимыеСимволыXMLПрограммно(ТекстДляЗаписи);
	Если Не Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна()
		Или ДвоичныеДанныеФайла <> Неопределено Тогда // Быстрее через 1С (в любом случае)
	
		ЗаписатьГотовыйЛогЧерез1СВызовСервераЕслиНужно(Источник, УровеньЛога, ТекстДляЗаписи, UnixTimestamp, ДвоичныеДанныеФайла, Кэш);
		Возврат;
	
	КонецЕсли;
	
	// Для записи напрямую инициализируем отдельную компоненту
	Если Не Кэш.Свойство("КомпонентаPostgreSQLДляЛогирования") Тогда
		
		Попытка
			
			Кэш.Вставить("КомпонентаPostgreSQLДляЛогирования", Новый Структура("КомпонентаPostgreSQL, КомпонентаPostgreSQL_УжеПодключали",
					Спец_PostgreSQLКлиентСервер.ПодключитьКомпонентуСИнициализированнымПодключением(Ложь),
					Истина));
			
			#Если Клиент Тогда
				Кэш.КомпонентаPostgreSQLДляЛогирования.КомпонентаPostgreSQL.ТихийРежим = Истина;
			#КонецЕсли
			
		Исключение
			
			Кэш.Вставить("КомпонентаPostgreSQLДляЛогирования", Новый Структура("КомпонентаPostgreSQL, КомпонентаPostgreSQL_УжеПодключали",
					Неопределено,
					Истина));
			
		КонецПопытки;
		
	КонецЕсли;
	
	Если Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLСоединениеУспешноУстановлено(Кэш.КомпонентаPostgreSQLДляЛогирования) Тогда
		
		ТекстГотовыйЗапрос = СформироватьТекстЗапросаДляЗаписиНапрямую(Источник, ТекстДляЗаписи, УровеньЛога, UnixTimestamp, Кэш);
		Если Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ТекстГотовыйЗапрос, "", Кэш.КомпонентаPostgreSQLДляЛогирования) Тогда
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
	
	ЗаписатьГотовыйЛогЧерез1СВызовСервераЕслиНужно(Источник, УровеньЛога, ТекстДляЗаписи, UnixTimestamp, ДвоичныеДанныеФайла, Кэш);
	
КонецПроцедуры

// ++ Спец_БСП.Версия1С_18_ВышеИлиРавно
#Если Клиент Тогда

//@skip-check undefined-variable
//@skip-check unknown-method-property
Асинх Процедура ЗаписатьГотовыйЛогВРегистрАсинх(Знач Источник, Знач УровеньЛога, Знач ТекстДляЗаписи, Знач UnixTimestamp, Знач ДвоичныеДанныеФайла, Знач Кэш)
	
	ТекстДляЗаписи = Спец_СтроковыеФункцииКлиентСервер.УдалитьНедопустимыеСимволыXMLПрограммно(ТекстДляЗаписи);
	Если Не Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна()
		Или ДвоичныеДанныеФайла <> Неопределено Тогда // Быстрее через 1С (в любом случае)
	
		ЗаписатьГотовыйЛогЧерез1СВызовСервераЕслиНужно(Источник, УровеньЛога, ТекстДляЗаписи, UnixTimestamp, ДвоичныеДанныеФайла, Кэш);
		Возврат;
	
	КонецЕсли;
	
	// Для записи напрямую инициализируем отдельную компоненту
	ОбещаниеКомпонентаДляЛогирования = Неопределено;
	
	Если Не Кэш.Свойство("КомпонентаPostgreSQLДляЛогирования") Тогда
		ОбещаниеКомпонентаДляЛогирования = Спец_PostgreSQLКлиент.ПодключитьКомпонентуСИнициализированнымПодключениемАсинх(Ложь);
	КонецЕсли;
	
	ТекстГотовыйЗапрос = СформироватьТекстЗапросаДляЗаписиНапрямую(Источник, ТекстДляЗаписи, УровеньЛога, UnixTimestamp, Кэш);
	Если ОбещаниеКомпонентаДляЛогирования <> Неопределено Тогда
		
		Попытка
			
			Кэш.Вставить("КомпонентаPostgreSQLДляЛогирования", Новый Структура("КомпонентаPostgreSQL, КомпонентаPostgreSQL_УжеПодключали",
					Ждать ОбещаниеКомпонентаДляЛогирования,
					Истина));
			
			Ждать Спец_КомпонентаДополнительныеФункцииКлиент.УстановитьПараметрВКомпонентеАсинх(Кэш.КомпонентаPostgreSQLДляЛогирования.КомпонентаPostgreSQL, "ТихийРежим", Истина);
			
		Исключение
			
			Кэш.Вставить("КомпонентаPostgreSQLДляЛогирования", Новый Структура("КомпонентаPostgreSQL, КомпонентаPostgreSQL_УжеПодключали",
					Неопределено,
					Истина));
			
		КонецПопытки;
		
	КонецЕсли;
	
	СоединениеУспешноУстановлено = Ждать Спец_КомпонентаДополнительныеФункцииКлиент.PostgreSQLСоединениеУспешноУстановленоАсинх(Кэш.КомпонентаPostgreSQLДляЛогирования);
	Если СоединениеУспешноУстановлено = Истина Тогда
		Спец_КомпонентаДополнительныеФункцииКлиент.PostgreSQLВыполнитьЗапросБезРезультатаАсинх(ТекстГотовыйЗапрос, "", Кэш.КомпонентаPostgreSQLДляЛогирования);
	КонецЕсли;
	
КонецПроцедуры

#КонецЕсли
// -- Спец_БСП.Версия1С_18_ВышеИлиРавно

// Возвращаемое значение:
//  Строка
//
Функция СформироватьТекстЗапросаДляЗаписиНапрямую(Знач Источник, Знач ТекстДляЗаписи, Знач УровеньЛога, Знач UnixTimestamp, Знач Кэш)
	
	UnixTimestampДляЗаписи = ?(UnixTimestamp = 0, Спец_КонстантыКлиентСервер.ТекущийUnixTimestampВPostrgeSQL(), UnixTimestamp);
	Если ТипЗнч(УровеньЛога) = Тип("Строка") Тогда
		
		УровеньЛогаДляЗаписи = ?(ПустаяСтрока(УровеньЛога),
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.ПустаяСсылка"),
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования." + УровеньЛога));
		
	ИначеЕсли УровеньЛога = Неопределено Тогда
		
		УровеньЛогаДляЗаписи = ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Информация");
		
	Иначе
		
		УровеньЛогаДляЗаписи = УровеньЛога;
		
	КонецЕсли;
	
	Если Кэш.КэшПараметровЗаполненияТаблиц["ТекстЗапросаЗаписьЛога"] = Неопределено Тогда
		Кэш.КэшПараметровЗаполненияТаблиц["ТекстЗапросаЗаписьЛога"] = ПодготовитьШаблонЗапросаЗаписиНапрямую(Кэш);
	КонецЕсли;
	
	ТекстГотовыйЗапрос = СтрЗаменить(Кэш.КэшПараметровЗаполненияТаблиц["ТекстЗапросаЗаписьЛога"], "[&UnixTimestamp]", Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(UnixTimestampДляЗаписи));
	ТекстГотовыйЗапрос = СтрЗаменить(ТекстГотовыйЗапрос, "[&Источник]"       , СтрЗаменить(Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(Источник), "'", "''")); 
	ТекстГотовыйЗапрос = СтрЗаменить(ТекстГотовыйЗапрос, "[&УровеньЛога]"    , Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьГУИДПредопределенногоЭлементаВБазе(УровеньЛогаДляЗаписи)); 
	ТекстГотовыйЗапрос = СтрЗаменить(ТекстГотовыйЗапрос, "[&ТекстИзменений]" , СтрЗаменить(ТекстДляЗаписи, "'", "''")); 
	
	Возврат ТекстГотовыйЗапрос;
	
КонецФункции

// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
//
Функция ПодготовитьШаблонЗапросаЗаписиНапрямую(Кэш)

	СтруктураИнформацииПоКомпьютеру = Спец_ЛогированиеОбъектовКлиентСерверПовтИсп.ПолучитьСтруктуруИнформацииПоТекущемуКомпьютеруДляЗаписи();
	
	ТекстЗапроса = 
	
	"INSERT INTO [РегистрСведений.Спец_ЛогиПоОбъектам]
	|(
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.UnixTimestamp],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.Источник],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.НомерСеанса],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.УровеньЛога],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.ВерсияОС],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.ВерсияПриложения],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.ИмяКомпьютера],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.ИмяПользователя],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.ИмяПользователяОперационнойСистемы],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.ОперативнаяПамять],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.Процессор],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.ТекстИзменений],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.ТипКлиента],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.ТипОперационнойСистемы],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.СодержимоеФайла]
	|) VALUES
	|(
	|	[&UnixTimestamp],
	|	'[&Источник]'::mvarchar(1024),
	|	[&НомерСеанса],
	|	lykov_UIDToRRef('[&УровеньЛога]'),
	|	'[&ВерсияОС]'::mvarchar(256),
	|	'[&ВерсияПриложения]'::mvarchar(64),
	|	'[&ИмяКомпьютера]'::mvarchar(128),
	|	'[&ИмяПользователя]'::mvarchar(128),
	|	'[&ИмяПользователяОперационнойСистемы]'::mvarchar(128),
	|	[&ОперативнаяПамять],
	|	'[&Процессор]'::mvarchar(256),
	|	'[&ТекстИзменений]'::mvarchar,
	|	'[&ТипКлиента]'::mvarchar(64),
	|	lykov_UIDToRRef('[&ТипОперационнойСистемы]'),
	|	lykov_DDToBytea('')
	|)
	|ON CONFLICT
	|(
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.UnixTimestamp],
	|	[РегистрСведений.Спец_ЛогиПоОбъектам.Источник]
	|) DO NOTHING";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&НомерСеанса]"                        , Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(СтруктураИнформацииПоКомпьютеру.НомерСеанса));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&ВерсияОС]"                           , Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(СтруктураИнформацииПоКомпьютеру.ВерсияОС));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&ВерсияПриложения]"                   , Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(СтруктураИнформацииПоКомпьютеру.ВерсияПриложения));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&ИмяКомпьютера]"                      , Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(СтруктураИнформацииПоКомпьютеру.ИмяКомпьютера));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&ИмяПользователя]"                    , Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(СтруктураИнформацииПоКомпьютеру.ИмяПользователя));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&ИмяПользователяОперационнойСистемы]" , Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(СтруктураИнформацииПоКомпьютеру.ИмяПользователяОперационнойСистемы));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&ОперативнаяПамять]"                  , Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(СтруктураИнформацииПоКомпьютеру.ОперативнаяПамять));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&Процессор]"                          , Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(СтруктураИнформацииПоКомпьютеру.Процессор));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&ТипКлиента]"                         , Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(СтруктураИнформацииПоКомпьютеру.ТипКлиента));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[&ТипОперационнойСистемы]"             , Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьГУИДПредопределенногоЭлементаВБазе(СтруктураИнформацииПоКомпьютеру.ТипОперационнойСистемы));
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		
		Возврат Спец_РаботаСБазойДанныхНапрямуюВызовСервера.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(ТекстЗапроса);
		
	#Иначе
		
		Возврат Спец_РаботаСБазойДанныхНапрямую.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(ТекстЗапроса, Кэш);
		
	#КонецЕсли
	
КонецФункции

// Параметры:
//  Источник - см. ЗаписатьГотовыйЛогВРегистр.Источник
//  УровеньЛога - см. ЗаписатьГотовыйЛогВРегистр.УровеньЛога
//  ТекстДляЗаписи - см. ЗаписатьГотовыйЛогВРегистр.ТекстДляЗаписи
//  UnixTimestamp - см. ЗаписатьГотовыйЛогВРегистр.UnixTimestamp
//  ДвоичныеДанныеФайла - см. ЗаписатьГотовыйЛогВРегистр.ДвоичныеДанныеФайла
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ЗаписатьГотовыйЛогЧерез1СВызовСервераЕслиНужно(Знач Источник, Знач УровеньЛога, Знач ТекстДляЗаписи, Знач UnixTimestamp, Знач ДвоичныеДанныеФайла, Кэш)
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		//@skip-check transfer-object-between-client-server
		Спец_ЛогированиеОбъектовВызовСервера.ЗаписатьГотовыйЛогВРегистрЧерез1С(Источник, УровеньЛога, ТекстДляЗаписи, UnixTimestamp, ДвоичныеДанныеФайла);
	#Иначе
		Спец_ЛогированиеОбъектов.ЗаписатьГотовыйЛогВРегистрЧерез1С(Источник, УровеньЛога, ТекстДляЗаписи, UnixTimestamp, ДвоичныеДанныеФайла, Кэш);
	#КонецЕсли
	
КонецПроцедуры

#КонецОбласти
