// @strict-types

// EDT не умеет с внешними компонентами, глушим.
//@skip-check dynamic-access-method-not-found
//@skip-check method-too-many-params
//@skip-check doc-comment-collection-item-type
//@skip-check Undefined variable

#Область ПрограммныйИнтерфейс

// Процедура для установки параметра в компоненте (с учётом вызова ошибок).
// 
// Параметры:
//  ОбъектКомпоненты - ОбъектВнешнейКомпоненты - объект компоненты:
//  	* ТекстПоследнейОшибки - Строка
//  ИмяПараметра - Строка - имя параметра (на любом языке)
//  ЗначениеПараметра - Произвольный - значение параметра
//
Процедура УстановитьПараметрВКомпоненте(Знач ОбъектКомпоненты, Знач ИмяПараметра, Знач ЗначениеПараметра) Экспорт
	
	Если ОбъектКомпоненты = Неопределено Или ПустаяСтрока(ИмяПараметра) Тогда Возврат; КонецЕсли;
	ОбъектКомпоненты[ИмяПараметра] = ЗначениеПараметра;
	Спец_Проверить(ПустаяСтрока(ОбъектКомпоненты.ТекстПоследнейОшибки), ОбъектКомпоненты.ТекстПоследнейОшибки);
	
КонецПроцедуры

#Область BaseFunction

// Пауза при выполнении кода без нагрузки на процессор (sleep)
//
// Параметры:
//  Миллисекунд - Число - количество миллисекунд для задержки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура Пауза(Знач Миллисекунд = 500, Кэш = Неопределено) Экспорт
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Если Кэш.КомпонентаBaseFunction = Неопределено Тогда
		
		Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоWindows() Тогда
			
			// Самая Не точная пауза из всех, но зато в миллисекундах. Стабильно выполняется на 100-200 миллисекунд дольше (из-за powershell).
			// Все остальные паузы только в секундах.
			
			ТекстКоманды = "powershell start-sleep -Milliseconds " + Формат(Миллисекунд, "ЧРД=.; ЧГ=");
			#Если Клиент И Не ВебКлиент Тогда
				
				Попытка
					
					WShell = Новый COMОбъект("Wscript.Shell");
					WShell.Run(ТекстКоманды, 0, 1);
					
				Исключение
					
					КомандаСистемы(ТекстКоманды);
					
				КонецПопытки;
				
			#Иначе
				
				ЗапуститьПриложение(ТекстКоманды, , Истина);
				
			#КонецЕсли
			
		ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоLinux() Тогда
			
			ТекстКоманды = "sleep " + Формат(Миллисекунд / 1000, "ЧРД=.; ЧГ=");
			
			#Если Клиент И Не ВебКлиент Тогда
				КомандаСистемы(ТекстКоманды);
			#Иначе
				ЗапуститьПриложение(ТекстКоманды, , Истина);
			#КонецЕсли
			
		ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоWine() Тогда
			
			ТекстКоманды = СтрШаблон("ping -n %1 127.0.0.1", Формат(Окр(Миллисекунд / 1000 + 0.5, 0) + 1, "ЧН=1; ЧГ="));
			ЗапуститьПриложение(ТекстКоманды, , Истина);
			
		Иначе
			
			Окончание = ТекущаяУниверсальнаяДатаВМиллисекундах() + Миллисекунд;
			Пока Окончание > ТекущаяУниверсальнаяДатаВМиллисекундах() Цикл
			КонецЦикла;
			
		КонецЕсли;
		
	Иначе
		
		Кэш.КомпонентаBaseFunction.Пауза(Миллисекунд);
		
	КонецЕсли;
	
КонецПроцедуры

// Преобразует строку в число
//
// Параметры:
//  ИсходнаяСтрока - Строка - строка для преобразования
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Число - полученное в результате преобразования число.
//
Функция СтрокаВЧисло(Знач ИсходнаяСтрока, Кэш = Неопределено) Экспорт
	
	Если ПустаяСтрока(ИсходнаяСтрока) Тогда Возврат 0; КонецЕсли;
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Возврат ?(Кэш.КомпонентаBaseFunction = Неопределено,
			Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ИсходнаяСтрока),
			Кэш.КомпонентаBaseFunction.СтрокаВЧисло(ИсходнаяСтрока));
	
КонецФункции

// Оставляет из "ИсходнаяСтрока" только символы из "СимволыКоторыеНеТрогать"
//
// Параметры:
//  ИсходнаяСтрока - Строка - строка для преобразования
//  СимволыКоторыеНеТрогать - Строка - символы, которые останутся в строке.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Строка - полученная в результате преобразования строка.
//
Функция ТолькоБуквыВСтроку(Знач ИсходнаяСтрока, Знач СимволыКоторыеНеТрогать = " _", Кэш = Неопределено) Экспорт
	
	Если ПустаяСтрока(ИсходнаяСтрока) Тогда Возврат ""; КонецЕсли;
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Возврат ?(Кэш.КомпонентаBaseFunction = Неопределено,
			ТолькоБуквыВСтроку_БезКомпоненты(ИсходнаяСтрока, СимволыКоторыеНеТрогать),
			Кэш.КомпонентаBaseFunction.ТолькоБуквыВСтроку(ИсходнаяСтрока, СимволыКоторыеНеТрогать));
	
КонецФункции

// Преобразует ключи JSON по принципу "ТолькоБуквыВСтроку" (рекурсивно)
//
// Параметры:
//  ИсходнаяСтрокаИлиИмяФайла - Строка - строка для преобразования (или имя файла для преобразования)
//  СимволыКоторыеНеТрогать - Строка - символы, которые останутся в ключе.
//  ПрефиксКолонки - Строка - если строка начинается с цифры, то добавляет данный префикс к ключу.
//  ИмяКолонкиПоУмолчанию - Строка - если после преобразования остается пустая строка, то имя ключа будет задано из данного параметра.
//  ЧитатьИзФайла - Булево - флаг того, читаем JSON из файла или из строки. Если указано ИСТИНА, то в "ИсходнаяСтрокаИлиИмяФайла" необходимо передать имя файла.
//  ТекстОшибки - Строка - в данный параметр будет добавлен текст ошибки во время выполнения.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Строка - полученная в результате преобразования строка.
//
Функция ТолькоБуквыВСтрокуJSON(Знач ИсходнаяСтрокаИлиИмяФайла, Знач СимволыКоторыеНеТрогать = "_", Знач ПрефиксКолонки = "_def", Знач ИмяКолонкиПоУмолчанию = "default",
		Знач ЧитатьИзФайла = Ложь, ТекстОшибки = "", Кэш = Неопределено) Экспорт
	
	Если ПустаяСтрока(ИсходнаяСтрокаИлиИмяФайла) Тогда Возврат ""; КонецЕсли;
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Если Кэш.КомпонентаBaseFunction = Неопределено Тогда
		
		JSONДляОбработки = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(ИсходнаяСтрокаИлиИмяФайла, ЧитатьИзФайла);
		Если JSONДляОбработки = Неопределено Тогда
			
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось прочитать JSON",
					"Спец_КомпонентаДополнительныеФункцииКлиентСервер.ТолькоБуквыВСтрокуJSON(...)",
					ТекстОшибки);
			
			Возврат ИсходнаяСтрокаИлиИмяФайла;
			
		КонецЕсли;
		
		РекурсивноИсправитьJSON(JSONДляОбработки, СимволыКоторыеНеТрогать, ПрефиксКолонки, ИмяКолонкиПоУмолчанию);
		Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(JSONДляОбработки);
		
	Иначе
		
		Результат = Кэш.КомпонентаBaseFunction.ТолькоБуквыВСтрокуJSON(ИсходнаяСтрокаИлиИмяФайла,
				СимволыКоторыеНеТрогать,
				ПрефиксКолонки,
				ИмяКолонкиПоУмолчанию,
				ЧитатьИзФайла); // Строка
		
		ДобавитьОшибкуЕслиЕсть("ТолькоБуквыВСтрокуJSON(...)", Кэш.КомпонентаBaseFunction, ТекстОшибки);
		Возврат Результат;
		
	КонецЕсли;
	
КонецФункции

// Сжимает данные по алгоритму Deflate (ТОЛЬКО ДЛЯ ФАЙЛОВ)
//
// Параметры:
//  ИмяФайлаДляЧтения - Строка - имя файла, содержащего данные для сжатия.
//  ИмяФайлаРезультат - Строка - имя файла для помещения результата
//  УровеньСжатия - Число - уровень сжатия (от 0 до 9)
//  НомерСтратегии - Число - номер стратегии (от 0 до 4, подробнее тут: https://www.zlib.net/manual.html (Compression strategy))
//  ТекстОшибки - Строка - в данный параметр будет добавлен текст ошибки во время выполнения.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Булево - успешность выполнения.
//
Функция СжатьDeflate(Знач ИмяФайлаДляЧтения, Знач ИмяФайлаРезультат, Знач УровеньСжатия = 4, Знач НомерСтратегии = 0,
		ТекстОшибки = "", Кэш = Неопределено) Экспорт
	
	Если ПустаяСтрока(ИмяФайлаДляЧтения) Или ПустаяСтрока(ИмяФайлаРезультат) Тогда Возврат Ложь; КонецЕсли;
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Спец_Проверить(Кэш.КомпонентаBaseFunction <> Неопределено, "Не удалось подключить внешнюю компоненту BaseFunction!");
	
	Результат = Кэш.КомпонентаBaseFunction.СжатьДанные(ИмяФайлаДляЧтения, ИмяФайлаРезультат, УровеньСжатия, НомерСтратегии); // Булево
	ДобавитьОшибкуЕслиЕсть("СжатьDeflate(...)", Кэш.КомпонентаBaseFunction, ТекстОшибки);
	Возврат Результат;
	
КонецФункции

// Разжимает данные по алгоритму Deflate (ТОЛЬКО ДЛЯ ФАЙЛОВ)
//
// Параметры:
//  ИмяФайлаДляЧтения - Строка - имя файла, содержащего данные для разжатия.
//  ИмяФайлаРезультат - Строка - имя файла для помещения результата
//  ТекстОшибки - Строка - в данный параметр будет добавлен текст ошибки во время выполнения.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Булево - успешность выполнения.
//
Функция РазжатьDeflate(Знач ИмяФайлаДляЧтения, Знач ИмяФайлаРезультат, ТекстОшибки = "", Кэш = Неопределено) Экспорт
	
	Если ПустаяСтрока(ИмяФайлаДляЧтения) Или ПустаяСтрока(ИмяФайлаРезультат) Тогда Возврат Ложь; КонецЕсли;
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Спец_Проверить(Кэш.КомпонентаBaseFunction <> Неопределено, "Не удалось подключить внешнюю компоненту BaseFunction!");
	
	Результат = Кэш.КомпонентаBaseFunction.РазжатьДанные(ИмяФайлаДляЧтения, ИмяФайлаРезультат); // Булево
	ДобавитьОшибкуЕслиЕсть("РазжатьDeflate(...)", Кэш.КомпонентаBaseFunction, ТекстОшибки);
	Возврат Результат;
	
КонецФункции

// Получает текущий Unix timestamp с точностью до 5 знаков (остальное 1С ограничивает) (https://www.unixtimestamp.com/).
// Если не передали кэш (или компонента недоступна), то возвращается 1С-кий Unix timestamp (точность 0 знаков)
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Число - Текущий Unix timestamp.
//
Функция ТекущийUnixTimestamp(Кэш = Неопределено) Экспорт
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Возврат ?(Кэш.КомпонентаBaseFunction = Неопределено,
			Спец_ОбщегоНазначенияКлиентСервер.UnixTimestamp(),
			Кэш.КомпонентаBaseFunction.ТекущийUnixTimestamp());
	
КонецФункции

// Получаеь текущий Unix timestamp сервера (см. ТекущийUnixTimestamp)
//
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Число - Текущий Unix timestamp.
//
Функция ТекущийUnixTimestampСервера(Кэш = Неопределено) Экспорт
	
	#Если Сервер Тогда
		Возврат ТекущийUnixTimestamp(Кэш);
	#Иначе
		Возврат Спец_КомпонентаДополнительныеФункцииВызовСервера.ТекущийUnixTimestamp();
	#КонецЕсли
	
КонецФункции

// Получает новый уникальный идентификатор (всегда 4 версии)
// Если не передали кэш (или компонента недоступна), то возвращается 1С-кую реализацию
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Строка - Уникальный идентификатор.
//
Функция ПолучитьУникальныйИдентификатор(Кэш = Неопределено) Экспорт
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Возврат ?(Кэш.КомпонентаBaseFunction = Неопределено,
			Спец_СтроковыеФункцииКлиентСервер.ПолучитьУникальныйИдентификатор(),
			Кэш.КомпонентаBaseFunction.УникальныйИдентификатор());
	
КонецФункции

// Фиксирует текущую дату для замера времени чего-либо (точность 9 знаков (наносекунды)).
// Если не передали кэш (или компонента недоступна), то делается через 1С (точность 3 знака (миллисекунды)).
// 
// Параметры:
// ИдентификаторЗамера - Строка - Идентификатор замера
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура НачатьЗамер(Знач ИдентификаторЗамера = "default", Кэш = Неопределено) Экспорт
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Если Кэш.КомпонентаBaseFunction <> Неопределено Тогда
		
		Кэш.КомпонентаBaseFunction.НачатьЗамер(ИдентификаторЗамера);
		
	Иначе
		
		Если Не Кэш.Свойство("ВремяНачалаЗамера") Тогда Кэш.Вставить("ВремяНачалаЗамера", Новый Соответствие()); КонецЕсли;
		Кэш.ВремяНачалаЗамера[ИдентификаторЗамера] = ТекущаяУниверсальнаяДатаВМиллисекундах();
		
	КонецЕсли;
	
КонецПроцедуры

// Завершает замер (см. НачатьЗамер)
// ВНИМАНИЕ: Для обеих процедур нужно передавать один и тот же кэш! Иначе замер будет испорчен и будет вызвано исключение.
// Параметры:
//  ИдентификаторЗамера - Строка - Идентификатор замера
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Число - Количество СЕКУНД (результат замера).
//
Функция ЗавершитьЗамер(Знач ИдентификаторЗамера = "default", Кэш = Неопределено) Экспорт
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Возврат ?(Кэш.КомпонентаBaseFunction <> Неопределено,
			Кэш.КомпонентаBaseFunction.ЗавершитьЗамер(ИдентификаторЗамера),
			(ТекущаяУниверсальнаяДатаВМиллисекундах() - Кэш.ВремяНачалаЗамера[ИдентификаторЗамера]) / 1000);
	
КонецФункции

// Проверяет указанную строку на соответствие заданному регулярному выражению.
// Базовые знания для проверки (есть хорошая статья https://habr.com/ru/articles/545150/, но кому лень):
//	. - любой символ
//	+ - один или более раз, пример ".+" - один или более любой символ.
//	* - ноль или более раз, пример ".*" - любое количество любых символов (даже ни одного).
//	[n-m] - символ от m до n, пример: "[0-9]+" - одна или более цифр(а).
//	\d - цифра, пример \d+ - одна или более цифр(а).
//	\D - не цифра.
//	\s - пробельный символ - ТАБ, пробел, перенос строки, возврат каретки и т.п.
//	\S - непробельный символ.
//	\w - буква, цифра, подчеркивание.
//	\W - не буква, не цифра и не подчеркивание соответственно.
//	^ - начало текста, например "^\d+" - строка начинается с цифры.
//	$ - конец текста, например "\D+$" - строка заканчивается НЕ цифрой.
//	{m,n} - шаблон для от m до n символов, например "\d{2,4}" - от двух до четырех цифр. Можно указать одну и всего цифру для строгого соответвия.
//	\ - экранирует спецсимволы. Например, "\." - символ точки.
//	
// Параметры:
//  СтрокаДляПроверки - Строка - Строка для проверки на соответствие
//  РегулярноеВыражение - Строка - Регулярное выражение (regex)
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево - Флаг того, что переданная строка соответствует регулярному выражению
//
Функция СтрокаСоответствуетРегулярномуВыражению(Знач СтрокаДляПроверки, Знач РегулярноеВыражение, Кэш = Неопределено) Экспорт
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Возврат ?(Кэш.КомпонентаBaseFunction <> Неопределено,
			Кэш.КомпонентаBaseFunction.СтрокаСоответствуетРегулярномуВыражению(СтрокаДляПроверки, РегулярноеВыражение),
			Спец_СтроковыеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению(СтрокаДляПроверки, РегулярноеВыражение));
	
КонецФункции

// Тип текущего клиента
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка - Тип приложения клиента, где вызван данный код
//
Функция ПолучитьТипКлиента(Кэш = Неопределено) Экспорт
	
	BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Если Кэш.КомпонентаBaseFunction <> Неопределено Тогда
		Возврат Кэш.КомпонентаBaseFunction.ТипПриложения;
	КонецЕсли;
	
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
        Возврат "Толстый клиент";
    #ИначеЕсли Сервер Тогда
        Возврат "Сервер";
    #ИначеЕсли ВнешнееСоединение Тогда
        Возврат "Внешнее соединение";
    #ИначеЕсли ТонкийКлиент Тогда
        Возврат "Тонкий клиент";
    #ИначеЕсли ВебКлиент Тогда
        Возврат "Веб-клиент";
    #ИначеЕсли МобильноеПриложениеКлиент Или МобильныйКлиент Тогда
    	Возврат "Мобильный клиент";
    #КонецЕсли
	
	Возврат "Неизвестный";
	
КонецФункции

#КонецОбласти

#Область HTTPClient

// Подготавливает структуру HTTP запроса для передачи в компоненту.
// 
// Параметры:
//  URL - Строка - URL запроса
//  ИдентификаторЗапроса - Строка - Идентификатор запроса
//  ТипЗапроса - Строка - Метод запроса
//  ТелоЗапроса - Массив, ФиксированныйМассив, Структура, ФиксированнаяСтруктура, Соответствие, ФиксированноеСоответствие - Преобразуется в JSON
//				- ДвоичныеДанные, ФайловыйПоток, Файл, ПотокВПамяти - Передаётся через файлы
//				- ЗаписьJSON, ЗаписьXML, ИнформацияОбОшибке - В виде строки
//				- Строка, Булево, Дата, Число - Через XML строку
//  СоответствиеЗаголовков - Соответствие - Соответствие заголовков
//  ИмяФайлаДляЧтения - Строка - Имя файла для чтения тела запроса
//  ИмяФайлаРезультат - Строка - Имя файла результат
// 
// Возвращаемое значение:
//  Структура:
//		* ИдентификаторЗапроса - Строка
//		* ТелоЗапроса - Строка
//		* URL - Строка
//		* МетодЗапроса - Строка
//		* ИмяФайлаЧтения - Строка
//		* ИмяФайлаРезультат - Строка
//		* Заголовки - Соответствие из КлючИЗначение:
//			** Ключ - Строка
//			** Значение - Строка
//
Функция HTTPClientПолучитьСтруктуруЗапроса(Знач URL, Знач ИдентификаторЗапроса = "default", Знач ТипЗапроса = "POST", Знач ТелоЗапроса = "",
		Знач СоответствиеЗаголовков = Неопределено, Знач ИмяФайлаДляЧтения = "", Знач ИмяФайлаРезультат = "") Экспорт
	
	СтруктураЗапроса = НоваяСтруктураHTTPЗапроса();
	
	СтруктураЗапроса.ИдентификаторЗапроса = ИдентификаторЗапроса;
	СтруктураЗапроса.URL = URL;
	СтруктураЗапроса.МетодЗапроса = ТипЗапроса;
	СтруктураЗапроса.ИмяФайлаЧтения = ИмяФайлаДляЧтения;
	СтруктураЗапроса.ИмяФайлаРезультат = ИмяФайлаРезультат;;
	
	Если СоответствиеЗаголовков <> Неопределено Тогда
		Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьОбъект(СоответствиеЗаголовков, СтруктураЗапроса.Заголовки, Истина);
	КонецЕсли;
	
	НуженContentType = СтруктураЗапроса.Заголовки["Content-Type"] = Неопределено;
	
	ТипТела = ТипЗнч(ТелоЗапроса);
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ТелоЗапроса, ТипТела)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ТелоЗапроса, ТипТела)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(ТелоЗапроса, ТипТела) Тогда
		
		ФайловыйПоток = Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьФайловыйПотокСИменемФайла();
		ЗаписьJSON = Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьЗаписьJSONПоПотоку(ФайловыйПоток);
		
		#Если Не ВебКлиент Тогда
			ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
		#КонецЕсли
		
		ЗаписьJSON.Закрыть();
		Спец_ОбщегоНазначенияКлиентСервер.ЗакрытьПотокНеМешаяРаботе(ФайловыйПоток, Истина);
		
		СтруктураЗапроса.ИмяФайлаЧтения = ФайловыйПоток.ИмяФайла;
		
		Если НуженContentType Тогда
			СтруктураЗапроса.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипТела = Тип("ДвоичныеДанные") Тогда
		
		СтруктураЗапроса.ИмяФайлаЧтения = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьИмяВременногоФайлаПоНормальному();
		ТелоЗапроса.Записать(СтруктураЗапроса.ИмяФайлаЧтения);
		
	ИначеЕсли ТипТела = Тип("ФайловыйПоток") Тогда
		
		СтруктураЗапроса.ИмяФайлаЧтения = ТелоЗапроса.ИмяФайла;
		Спец_ОбщегоНазначенияКлиентСервер.ЗакрытьПотокНеМешаяРаботе(ТелоЗапроса, Истина);
		
	ИначеЕсли ТипТела = Тип("Файл") Тогда
		
		СтруктураЗапроса.ИмяФайлаЧтения = ТелоЗапроса.ПолноеИмя;
		
	ИначеЕсли ТипТела = Тип("ПотокВПамяти") Тогда
		
		ТелоЗапроса.Перейти(0, ПозицияВПотоке.Начало);
		
		СтруктураЗапроса.ИмяФайлаЧтения = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьИмяВременногоФайлаПоНормальному();
		ТелоЗапроса.ЗакрытьИПолучитьДвоичныеДанные().Записать(СтруктураЗапроса.ИмяФайлаЧтения);
		
	ИначеЕсли ТипТела = Тип("ЗаписьJSON") Тогда
		
		СтруктураЗапроса.ТелоЗапроса = ТелоЗапроса.Закрыть();
		
		Если НуженContentType Тогда
			СтруктураЗапроса.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипТела = Тип("ЗаписьXML") Тогда
		
		СтруктураЗапроса.ТелоЗапроса = ТелоЗапроса.Закрыть();
		
		Если НуженContentType Тогда
			СтруктураЗапроса.Заголовки.Вставить("Content-Type", "application/xml;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипТела = Тип("ИнформацияОбОшибке") Тогда
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТелоЗапроса, , СтруктураЗапроса.ТелоЗапроса);
		
		Если НуженContentType Тогда
			СтруктураЗапроса.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
		КонецЕсли;
		
	Иначе
		
		Попытка
			
			СтруктураЗапроса.ТелоЗапроса = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(ТелоЗапроса);
			Если НуженContentType Тогда
				СтруктураЗапроса.Заголовки.Вставить("Content-Type", "application/xml;charset=utf-8");
			КонецЕсли;
			
		Исключение
			
			СтруктураЗапроса.ТелоЗапроса = СокрЛП(ТелоЗапроса);
			
			Если НуженContentType Тогда
				СтруктураЗапроса.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
			КонецЕсли;
			
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат СтруктураЗапроса;
	
КонецФункции

// Подчистить данные HTTP запроса (удаляет созданные файлы)
// 
// Параметры:
//  СтруктураЗапроса - см. HTTPClientПолучитьСтруктуруЗапроса
//
Процедура HTTPClientПодчиститьДанныеЗапроса(Знач СтруктураЗапроса) Экспорт
	
	Спец_ОбщегоНазначенияКлиентСервер.УдалитьФайлыНеМешаяРаботе(HTTPClientМассивФайловДляЧисткиПослеВыполнения(СтруктураЗапроса));
	
КонецПроцедуры

// Отправить HTTP запросы асинхронно.
// 
// Параметры:
//  МассивИлиСтруктураЗапросов - Массив из см. HTTPClientПолучитьСтруктуруЗапроса - Массив структур запросов или структура запроса для выполнения
//  						   - см. HTTPClientПолучитьСтруктуруЗапроса
//  ТекстОшибки - Строка - Текст ошибки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. HTTPClientПреобразоватьJsonВРезультат
//
Функция HTTPClientОтправитьЗапросыАсинхронно(Знач МассивИлиСтруктураЗапросов, ТекстОшибки = "", Кэш = Неопределено) Экспорт
	
	HTTPClient_ПодключитьЕслиНеПодключали(Кэш);
	Если Кэш.КомпонентаHTTPClient = Неопределено Тогда
		Возврат Спец_ОбщегоНазначенияКлиентСервер.ОтправитьHTTPЗапросы(МассивИлиСтруктураЗапросов, Кэш);
	КонецЕсли;
	
	РезультатВыполнения = Кэш.КомпонентаHTTPClient.ОтправитьЗапросыАсинхронно(Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(МассивИлиСтруктураЗапросов, Ложь)); // Строка
	ДобавитьОшибкуЕслиЕсть("HTTPClientОтправитьЗапросыАсинхронно(...)", Кэш.КомпонентаHTTPClient, ТекстОшибки);
	
	Возврат HTTPClientПреобразоватьJsonВРезультат(РезультатВыполнения);
	
КонецФункции

// Отправляет HTTP запросы (последовательно) и ожидает результаты.
//
// Параметры:
//  МассивИлиСтруктураЗапросов - см. HTTPClientОтправитьЗапросыАсинхронно.МассивИлиСтруктураЗапросов
//  ЗадержкаМеждуОтправками - Число - задержка между отправками запросов (миллисекунд)
//  ТекстОшибки - Строка - в данный параметр будет добавлен текст ошибки во время выполнения.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  см. HTTPClientПреобразоватьJsonВРезультат
//
Функция HTTPClientОтправитьЗапросыСинхронно(Знач МассивИлиСтруктураЗапросов, Знач ЗадержкаМеждуОтправками = 0, ТекстОшибки = "", Кэш = Неопределено) Экспорт
	
	HTTPClient_ПодключитьЕслиНеПодключали(Кэш);
	Если Кэш.КомпонентаHTTPClient = Неопределено Тогда
		Возврат Спец_ОбщегоНазначенияКлиентСервер.ОтправитьHTTPЗапросы(МассивИлиСтруктураЗапросов, Кэш);
	КонецЕсли;
	
	РезультатВыполнения = Кэш.КомпонентаHTTPClient.ОтправитьЗапросыПоследовательно(
			Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(МассивИлиСтруктураЗапросов, Ложь),
			ЗадержкаМеждуОтправками); // Строка
	
	ДобавитьОшибкуЕслиЕсть("HTTPClientОтправитьЗапросыСРезультатом(...)", Кэш.КомпонентаHTTPClient, ТекстОшибки);
	
	Возврат HTTPClientПреобразоватьJsonВРезультат(РезультатВыполнения);
	
КонецФункции

// Регистрирует HTTP запрос к выполнению. Если ЧерезВнешнееСобытие = ИСТИНА, то создаёт отдельный поток для выполнения.
//
// Параметры:
//  МассивИлиСтруктураЗапросов - см. HTTPClientОтправитьЗапросыАсинхронно.МассивИлиСтруктураЗапросов
//  ЧерезВнешнееСобытие - Булево - если ИСТИНА, то результат запроса будет получен через "ВнешнееСобытие" (ТОЛЬКО НА КЛИЕНТЕ!)
//  ТекстОшибки - Строка - в данный параметр будет добавлен текст ошибки во время выполнения.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура HTTPClientЗарегистрироватьЗапросыКВыполнению(Знач МассивИлиСтруктураЗапросов, Знач ЧерезВнешнееСобытие = Ложь, ТекстОшибки = "", Кэш = Неопределено) Экспорт
	
	#Если Не Клиент Тогда
		Спец_Проверить(Не ЧерезВнешнееСобытие, "Внешние события можно инициализировать только на клиенте!");
	#КонецЕсли
	
	HTTPClient_ПодключитьЕслиНеПодключали(Кэш);
	Если Кэш.КомпонентаHTTPClient = Неопределено Тогда
		
		Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивИлиСтруктураЗапросов);
		Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьМассив(МассивИлиСтруктураЗапросов, Кэш.МассивЗарегистрированныхЗапросов);
		
	Иначе
		
		#Если Клиент Тогда
			
			Кэш.КомпонентаHTTPClient.ЗарегистрироватьЗапросыКВыполнению(
					Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(МассивИлиСтруктураЗапросов, Ложь),
					ЧерезВнешнееСобытие);
					
		#Иначе
			
			Кэш.КомпонентаHTTPClient.ЗарегистрироватьЗапросыКВыполнению(Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(МассивИлиСтруктураЗапросов, Ложь));
			ДобавитьОшибкуЕслиЕсть("HTTPClientЗарегистрироватьЗапросКВыполнению(...)", Кэш.КомпонентаHTTPClient, ТекстОшибки);
			
		#КонецЕсли
		
	КонецЕсли;
	
КонецПроцедуры

// Получает результаты выполнения запросов, зарегистрированных через HTTPClientЗарегистрироватьЗапросКВыполнению.
// Только для тех запросов, для которых ЧерезВнешнееСобытие = Ложь.
//
// Параметры:
//  ТекстОшибки - Строка - в данный параметр будет добавлен текст ошибки во время выполнения.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  см. HTTPClientПреобразоватьJsonВРезультат
//
Функция HTTPClientПолучитьРезультатыЗарегистрированныхЗапросов(ТекстОшибки = "", Кэш = Неопределено) Экспорт
	
	HTTPClient_ПодключитьЕслиНеПодключали(Кэш);
	Если Кэш.КомпонентаHTTPClient = Неопределено Тогда
		
		РезультатВыполнения = Спец_ОбщегоНазначенияКлиентСервер.ОтправитьHTTPЗапросы(Кэш.МассивЗарегистрированныхЗапросов, Кэш);
		Кэш.МассивЗарегистрированныхЗапросов.Очистить();
		
		Возврат РезультатВыполнения;
		
	Иначе
		
		РезультатВыполнения = Кэш.КомпонентаHTTPClient.ПолучитьРезультатыЗарегистрированныхЗапросов(); // Строка
		ДобавитьОшибкуЕслиЕсть("HTTPClientПолучитьРезультатыЗарегистрированныхЗапросов(...)", Кэш.КомпонентаHTTPClient, ТекстОшибки);
		
		Возврат HTTPClientПреобразоватьJsonВРезультат(РезультатВыполнения);
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область MySQL

// Устанавливает соединение с базой MySQL
// 
// Параметры:
//  Хост - Строка - Хост базы
//  ИмяПользователя - Строка - Имя пользователя базы
//  Пароль - Строка - Пароль пользователя базы
//  ИмяБазыДанных - Строка - Наименование базы данных
//  Порт - Число - Порт базы для подключения
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура MySQLУстановитьСоединение(Знач Хост, Знач ИмяПользователя, Знач Пароль, Знач ИмяБазыДанных, Знач Порт = 0, Кэш = Неопределено) Экспорт
	
	MySQL_ПодключитьЕслиНеПодключали(Кэш);
	Спец_Проверить(Кэш.КомпонентаMySQL <> Неопределено, "Не удалось подключить внешнюю компоненту MySQL");
	
	Кэш.КомпонентаMySQL.УстановитьСоединение(Хост, ИмяПользователя, Пароль, ИмяБазыДанных, Порт);
	Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаMySQL.ТекстПоследнейОшибки), Кэш.КомпонентаMySQL.ТекстПоследнейОшибки);
	
КонецПроцедуры

// Выполняет запрос в базе MySQL
// 
// Параметры:
//  ТекстЗапроса - Строка - Текст запроса для выполнения
//  ИмяФайлаРезультат - Строка - Если указано, то результат запроса будет сохранён в файл (в формате JSON)
//  ТекстОшибки - Строка - в данный параметр будет добавлен текст ошибки во время выполнения.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Массив из Соответствие - массив строк результата запроса
//
Функция MySQLВыполнитьЗапрос(Знач ТекстЗапроса, Знач ИмяФайлаРезультат = "", ТекстОшибки = "", Кэш = Неопределено) Экспорт
	
	MySQL_ПодключитьЕслиНеПодключали(Кэш);
	Спец_Проверить(Кэш.КомпонентаMySQL <> Неопределено, "Не удалось подключить внешнюю компоненту MySQL");
	
	РезультатВыполнения = Кэш.КомпонентаMySQL.ВыполнитьЗапрос(ТекстЗапроса, ИмяФайлаРезультат); // Строка
	ДобавитьОшибкуЕслиЕсть("MySQLВыполнитьЗапрос(...)", Кэш.КомпонентаMySQL, ТекстОшибки);
	
	Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(РезультатВыполнения);
	
КонецФункции

#КонецОбласти

#Область PostgreSQL

// Устанавливает соединение с базой в PostgreSQL
//
// Параметры:
//  СтрокаПодключения - Строка - строка подключения к базе. См. https://postgrespro.ru/docs/postgresql/9.6/libpq-connect#libpq-connstring
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура PostgreSQLУстановитьСоединение(Знач СтрокаПодключения, Кэш = Неопределено) Экспорт
	
	PostgreSQL_ПодключитьЕслиНеПодключали(Кэш, Истина);
	Спец_Проверить(Кэш.КомпонентаPostgreSQL <> Неопределено, "Не удалось подключить внешнюю компоненту PostgreSQL");
	
	Кэш.КомпонентаPostgreSQL.УстановитьСоединение(СтрокаПодключения);
	Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки), Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки);
	
КонецПроцедуры

// Выполняет запрос к базе PostgreSQL. Если это SQL команда без результатов (количество строк в результате = 0),
// то лучше использовать см. PostgreSQLВыполнитьЗапросБезРезультата.
// 
// Параметры:
//	ТекстЗапроса - Строка - Текст запроса к базе PostgreSQL
//	КоличествоСтрокВРезультате - Число - Число строк в результате запроса. Если количество строк неизвестно, то оставить -1.
//	ИмяФайлаРезультат - Строка - Если указано, то результат запроса будет записан в файл
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//	Структура - Структура строки результата запроса:
//		* Успешно - Булево - Флаг успешности выполнения запроса
//		* РезультатЗапроса - Массив из Структура - Массив строк результата запроса
//		* ТекстОшибки - Строка - Если запрос не был выполнен, то в данном поле будет лежать текст ошибки
//
Функция PostgreSQLВыполнитьЗапрос(Знач ТекстЗапроса, Знач КоличествоСтрокВРезультате = -1, Знач ИмяФайлаРезультат = "", Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	
	Попытка
		
		РезультатВыполнения = Кэш.КомпонентаPostgreSQL.ВыполнитьЗапрос(ТекстЗапроса, КоличествоСтрокВРезультате, ИмяФайлаРезультат); // Строка
		Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки), Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки);
		Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(РезультатВыполнения, , Ложь);
		
	Исключение
		
		Возврат Новый Структура("Успешно, ТекстОшибки, РезультатЗапроса", Ложь, Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке()), Новый Массив);
		
	КонецПопытки;
	
КонецФункции

// Выполняет запрос к базе PostgreSQL (с учётом того, что КоличествоСтрокВРезультате = 0)
// (см. PostgreSQLВыполнитьЗапрос)
// 
// Параметры:
//  ТекстЗапроса - Строка - Текст запроса к базе PostgreSQL
//  ТекстОшибки - Строка - Если запрос не был выполнен, то в данном поле будет лежать текст ошибки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//	Булево - Флаг успешности выполнения запроса
//
Функция PostgreSQLВыполнитьЗапросБезРезультата(Знач ТекстЗапроса, ТекстОшибки = "", Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	
	Попытка
		
		Кэш.КомпонентаPostgreSQL.ВыполнитьЗапрос(ТекстЗапроса, 0, "");
		Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки), Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки);
		
		Возврат Истина;
		
	Исключение
		
		ШаблонСообщения = "Не удалось выполнить запрос!%1%2";
		ТекстСообщения  = СтрШаблон(ШаблонСообщения,
				Символы.ПС,
				Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб));
		
		Спец_СтроковыеФункцииКлиентСервер.ДобавитьСтрокуВТекст(ТекстСообщения, ТекстОшибки);
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции

// Инициализирует отдельный поток для запроса к базе PostgreSQL
// 
// Параметры:
//  ТекстЗапроса - Строка - Текст запроса к базе PostgreSQL
//  ИдентификаторЗапроса - Строка - Идентификатор запроса. Не может выполняться 2 запроса с одинаковым идентификатором
//  ЧерезВнешнееСобытие - Булево - если истина, то результат запроса будет получен через "ВнешнееСобытие" (ТОЛЬКО НА КЛИЕНТЕ!)
//  КоличествоСтрокВРезультате - Число - Число строк в результате запроса. Если количество строк неизвестно, то оставить -1.
//  ИмяФайлаРезультат - Строка - Если указано, то результат запроса будет записан в файл
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура PostgreSQLНачатьВыполнениеЗапросаВОтдельномПотоке(Знач ТекстЗапроса, Знач ИдентификаторЗапроса = "default", Знач ЧерезВнешнееСобытие = Ложь,
		Знач КоличествоСтрокВРезультате = -1, Знач ИмяФайлаРезультат = "", Кэш = Неопределено) Экспорт
	
	#Если Не Клиент Тогда
		Спец_Проверить(Не ЧерезВнешнееСобытие, "Внешние события можно инициализировать только на клиенте!");
	#КонецЕсли
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	Кэш.КомпонентаPostgreSQL.НачатьВыполнениеЗапроса(ТекстЗапроса, ИдентификаторЗапроса, ЧерезВнешнееСобытие, КоличествоСтрокВРезультате, ИмяФайлаРезультат);
	Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки), Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки);
	
КонецПроцедуры

// Получает результаты зарегистрированных запросов к базе PostgreSQL (см. PostgreSQLНачатьВыполнениеЗапросаВОтдельномПотоке)
// 
// Параметры:
//  ИдентификаторЗапроса - Строка - Идентификатор запроса. Если указан, то будет получен только результат с указанным идентификатором
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//	Массив из см. PostgreSQLВыполнитьЗапрос - Массив из структур результатов запросов
//
Функция PostgreSQLПолучитьРезультатыЗарегистрированныхЗапросов(Знач ИдентификаторЗапроса = "", Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	РезультатВыполнения = Кэш.КомпонентаPostgreSQL.ПолучитьРезультатыЗарегистрированныхЗапросов(ИдентификаторЗапроса); // Строка
	Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки), Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки);
	
	Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(РезультатВыполнения, , Ложь);
	
КонецФункции

// Записывает данные в таблицу (COPY TO)
// 
// Параметры:
//  ИмяТаблицы - Строка - Наименование таблицы, куда нужно вставить данные
//  ДанныеДляВставкиИлиИмяФайла - Строка - Данные для вставки (МАССИВ МАССИВОВ СТРОК, каждое значение колонки должно иметь тип "Строка", формат JSON), либо имя файла
//  ИменаКолонок - Строка - Имена колонок для вставки данных (разделение через запятую)
//  ЧитатьИзФайла - Булево - Флаг того, что данные нужно читать из файла. Если ИСТИНА, то ДанныеДляВставкиИлиИмяФайла должен содержать имя файла.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура PostgreSQLВставитьДанныеВТаблицу(Знач ИмяТаблицы, Знач ДанныеДляВставкиИлиИмяФайла, Знач ИменаКолонок = "", Знач ЧитатьИзФайла = Ложь, Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	Кэш.КомпонентаPostgreSQL.ВставитьДанныеВТаблицу(ИмяТаблицы, ДанныеДляВставкиИлиИмяФайла, ИменаКолонок, ЧитатьИзФайла);
	Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки), Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки);
	
КонецПроцедуры

// Читает данные из таблицы (COPY FROM)
// 
// Параметры:
//  ИмяТаблицы - Строка - Наименование таблицы, откуда нужно прочитать данные
//  ИменаКолонок - Строка - Имена колонок для вставки данных (разделение через запятую)
//  ИмяФайлаРезультат - Строка - Если указано, то результат будет записан в файл
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Булево, Массив из Массив - Массив массивов строк (колонки состоят только из строк). Если указано ИмяФайлаРезультат, то результатом будет ИСТИНА
//
Функция PostgreSQLПрочитатьДанныеИзТаблицы(Знач ИмяТаблицы, Знач ИменаКолонок = "", Знач ИмяФайлаРезультат = "", Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	РезультатВыполнения = Кэш.КомпонентаPostgreSQL.ПрочитатьДанныеИзТаблицы(ИмяТаблицы, ИменаКолонок, ИмяФайлаРезультат); // Строка
	Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки), Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки);
	
	Возврат ?(ПустаяСтрока(ИмяФайлаРезультат),
			Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(РезультатВыполнения, , Ложь),
			РезультатВыполнения);
	
КонецФункции

// Читает данные из запроса (COPY FROM)
// Параметры:
//  ТекстЗапроса - Строка - Текст запроса, из которого нужно прочитать данные
//  ИмяФайлаРезультат - Строка - Если указано, то результат будет записан в файл
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Булево, Массив из Массив - Массив массивов строк (колонки состоят только из строк). Если указано ИмяФайлаРезультат, то результатом будет ИСТИНА
//
Функция PostgreSQLПрочитатьДанныеИзЗапроса(Знач ТекстЗапроса, Знач ИмяФайлаРезультат = "", Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	РезультатВыполнения = Кэш.КомпонентаPostgreSQL.ПрочитатьДанныеИзЗапроса(ТекстЗапроса, ИмяФайлаРезультат); // Строка
	Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки), Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки);
	
	Возврат ?(ПустаяСтрока(ИмяФайлаРезультат),
			Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(РезультатВыполнения, , Ложь),
			РезультатВыполнения);
	
КонецФункции

// Сбрасывает все текущие транзакции и переподключается к базе PostgreSQL
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура PostgreSQLСброситьСоединение(Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	Кэш.КомпонентаPostgreSQL.СброситьСоединение();
	
КонецПроцедуры

// Инициализирует дополнительные функции в базе PostgreSQL (для работы с 1С).
// Добавляет следующие функции:
//  - lykov_HexToInt - преобразует число HEX to INT
//  - lykov_RRefToUID - преобразует ссылку в формате PostgreSQL в УникальныйИдентификатор ссылки.
//  - lykov_UIDToRRef - преобразует УникальныйИдентификатор ссылки в формат PostgreSQL
//  - lykov_TypeToBytea - преобразует номер типа таблицы из числа в формат PostgreSQL
//  - lykov_ByteaToType - преобразует тип таблицы из формата PostgreSQL в число
//  - lykov_DDToBytea - преобразует строку из XMLСтрока (ДвоичныеДанные, ХранилищеЗначения) в формат PostgreSQL
//  - lykov_ByteaToDD - преобразует ДвоичныеДанные, ХранилищеЗначения из формата PostgreSQL в формат XMLЗначение
//  - lykov_DDToText - пытается преобразовать ДвоичныеДанные, ХранилищеЗначения, и т.д. в текстовый формат.
//  - lykov_RTRefToBytea - преобразует числовой номер таблицы в формат PostgreSQL
//  - lykov_RTRefToInteger - преобразует номер таблицы в формате PostgreSQL в число
//  - lykov_VersionToInteger - преобразует поле "Версия" из 1С-го формата в формат PostgreSQL
//  - lykov_VersionTo1C - преобразует поле "Версия" из формата PostgreSQL в формат 1С
//  - lykov_KeyFieldToBytea - преобразует поле "НомерСтроки" из формата 1С в формат PostgreSQL
//  - lykov_KeyFieldToInteger - преобразует поле "НомерСтроки" из формата PostgreSQL в формат 1С
//
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура PostgreSQLИнициализироватьДополнительныеФункцииДляРаботыС1С(Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	Кэш.КомпонентаPostgreSQL.ИнициализироватьФункцииДля1С();
	Спец_Проверить(ПустаяСтрока(Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки), Кэш.КомпонентаPostgreSQL.ТекстПоследнейОшибки);
	
КонецПроцедуры

// Начинает транзакцию для данного подключения.
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура PostgreSQLНачатьТранзакцию(Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	Если PostgreSQLВыполнитьЗапросБезРезультата("BEGIN", "", Кэш) <> Истина Тогда
		
		PostgreSQLСброситьСоединение(Кэш);
		Спец_Проверить(PostgreSQLВыполнитьЗапросБезРезультата("BEGIN", "", Кэш), "Не удалось начать транзакцию");
		
	КонецЕсли;
	
КонецПроцедуры

// Фиксирует транзакцию для данного подключения.
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Булево - Флаг успешности выполнения
//
Функция PostgreSQLЗафиксироватьТранзакцию(Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	Если PostgreSQLВыполнитьЗапросБезРезультата("COMMIT", "", Кэш) <> Истина Тогда
		
		PostgreSQLОтменитьТранзакцию(Кэш);
		Возврат Ложь;
		
	Иначе
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// Отменяет транзакцию для данного подключения.
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура PostgreSQLОтменитьТранзакцию(Кэш = Неопределено) Экспорт
	
	Спец_Проверить(PostgreSQLСоединениеУспешноУстановлено(Кэш), "Не удалось подключить внешнюю компоненту PostgreSQL");
	Если PostgreSQLВыполнитьЗапросБезРезультата("ROLLBACK", "", Кэш) <> Истина Тогда
		PostgreSQLСброситьСоединение(Кэш);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// BaseFunction - подключить компоненту (если не подключали).
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура BaseFunction_ПодключитьЕслиНеПодключали(Кэш) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	// ++ Спец_БСП.Версия1С_20_Ниже
	// До 20 версии 1С ооочень криво работают возвращаемые (вместо поля КомпонентаBaseFunction может вернуться любое значение).
	// Причём на тип внешней компоненты не проверить, поэтому обращаемся к любому свойству.
	Если Кэш.Свойство("КомпонентаBaseFunction") И Кэш.КомпонентаBaseFunction <> Неопределено И Не Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(Кэш.КомпонентаBaseFunction, "ТекстПоследнейОшибки") Тогда Кэш.Удалить("КомпонентаBaseFunction"); КонецЕсли;
	// -- Спец_БСП.Версия1С_20_Ниже
	
	Если Не Кэш.Свойство("КомпонентаBaseFunction") Тогда Кэш.Вставить("КомпонентаBaseFunction", Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьКомпонентуBaseFunction()); КонецЕсли;
	
КонецПроцедуры

// HTTPClient - подключить компоненту (если не подключали).
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура HTTPClient_ПодключитьЕслиНеПодключали(Кэш) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	// ++ Спец_БСП.Версия1С_20_Ниже
	// До 20 версии 1С ооочень криво работают возвращаемые (вместо поля КомпонентаHTTPClient может вернуться любое значение).
	// Причём на тип внешней компоненты не проверить, поэтому обращаемся к любому свойству.
	Если Кэш.Свойство("КомпонентаHTTPClient") И Кэш.КомпонентаHTTPClient <> Неопределено И Не Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(Кэш.КомпонентаHTTPClient, "ТекстПоследнейОшибки") Тогда Кэш.Удалить("КомпонентаHTTPClient"); КонецЕсли;
	// -- Спец_БСП.Версия1С_20_Ниже
	
	Если Не Кэш.Свойство("КомпонентаHTTPClient") Тогда
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.НачатьЗамерДляЛогирования("Подключение компоненты HTTP client");
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Кэш.Вставить("КомпонентаHTTPClient", Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьКомпонентуHTTPClient());
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Подключение компоненты HTTP client", 1, Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
	КонецЕсли;

КонецПроцедуры

// Подключает кэш и возвращает флаг того, что соединение с PostgreSQL текущей базы успешно установлено
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево - Компонента PostgreSQL полностью готова к записи в БД
//
Функция PostgreSQLСоединениеУспешноУстановлено(Кэш = Неопределено) Экспорт
	
	PostgreSQL_ПодключитьЕслиНеПодключали(Кэш);
	Возврат Кэш.КомпонентаPostgreSQL <> Неопределено И Кэш.КомпонентаPostgreSQL.СоединениеУстановлено;
	
КонецФункции

// PostgreSQL - подключить компоненту (если не подключали).
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  БезИнициализацииПодключения - Булево - Без инициализации подключения
//
Процедура PostgreSQL_ПодключитьЕслиНеПодключали(Кэш, Знач БезИнициализацииПодключения = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	// ++ Спец_БСП.Версия1С_20_Ниже
	// До 20 версии 1С ооочень криво работают возвращаемые (вместо поля КомпонентаPostgreSQL может вернуться любое значение).
	// Причём на тип внешней компоненты не проверить, поэтому обращаемся к любому свойству.
	Если Кэш.Свойство("КомпонентаPostgreSQL") И Кэш.КомпонентаPostgreSQL <> Неопределено И Не Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(Кэш.КомпонентаPostgreSQL, "ТекстПоследнейОшибки") Тогда Кэш.Удалить("КомпонентаPostgreSQL"); КонецЕсли;
	// -- Спец_БСП.Версия1С_20_Ниже
	
	Если Кэш.Свойство("КомпонентаPostgreSQL") Тогда Возврат; КонецЕсли;
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.НачатьЗамерДляЛогирования("Подключение компоненты PostgreSQL");
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	Если Не БезИнициализацииПодключения Тогда
		
		Попытка
			Кэш.Вставить("КомпонентаPostgreSQL", Спец_PostgreSQLКлиентСервер.ПодключитьКомпонентуСИнициализированнымПодключением());
		Исключение
			Кэш.Вставить("КомпонентаPostgreSQL", Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьКомпонентуPostgreSQL());
		КонецПопытки;
		
	Иначе
		
		Кэш.Вставить("КомпонентаPostgreSQL", Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьКомпонентуPostgreSQL());
		
	КонецЕсли;
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Подключение компоненты PostgreSQL", 1, Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
КонецПроцедуры

// Массив файлов для чистки после выполнения HTTP запроса.
// 
// Параметры:
//  СтруктураЗапроса - см. HTTPClientПолучитьСтруктуруЗапроса
// 
// Возвращаемое значение:
//  Массив из Строка - Массив имён файлов
//
Функция HTTPClientМассивФайловДляЧисткиПослеВыполнения(Знач СтруктураЗапроса) Экспорт
	
	МассивРезультат = Новый Массив; // Массив из Строка
	
	Если Не ПустаяСтрока(СтруктураЗапроса.ИмяФайлаЧтения) Тогда
		МассивРезультат.Добавить(СтруктураЗапроса.ИмяФайлаЧтения);
	КонецЕсли;
	Если Не ПустаяСтрока(СтруктураЗапроса.ИмяФайлаРезультат) Тогда
		МассивРезультат.Добавить(СтруктураЗапроса.ИмяФайлаРезультат);
	КонецЕсли;
	
	Возврат МассивРезультат;
	
КонецФункции

// Преобразовать JSON из компоненты в результат.
// 
// Параметры:
//  РезультатВыполнения - Строка - Результат выполнения из компоненты
// 
// Возвращаемое значение:
//  Массив из Структура - массив результатов запросов (или соответствие результата запроса) со следующими полями:
//		* ИдентификаторЗапроса - Строка - Идентификатор запроса
//		* URL - Строка - URL, на который запрос был отправлен
//		* ТипЗапроса - Строка - Метод запроса (POST, GET, и т.п.)
//		* КодОтвета - Число - Код HTTP ответа
//		* ВремяОтвета - Число - время, в течение которого запрос выполнялся (секунд)
//		* Успешно - Булево - Флаг успешности выполнения запроса + КодОтвета >= 200 И КодОтвета < 300
//		* ФайлРезультат - Строка - Имя файла результат запроса (если результат запроса в файл)
//		* ТелоРезультат - Строка - Тело результат (если результат запроса не в файл)
//		* ЗаголовкиРезультат - Соответствие из КлючИЗначение - Заголовки HTTP ответа (только если у компоненты был включён параметр ВозвращатьЗаголовки):
//			** Ключ - Строка
//			** Значение - Строка
//		* ОтладочнаяИнформация - Структура - Информация для отладки запроса (только если у компоненты был включён параметр РежимОтладки):
//			** ОбщаяИнформация - Строка - Общая информация
//			** ПолученныеДанные - Строка - Все полученные данные
//			** ОтправленныеДанные - Строка - Все отправленные данные
//			** ПолученныеЗаголовки - Строка - Все полученные заголовки
//			** ОтправленныеЗаголовки - Строка - Все отправленные заголовки
//			** ОтправленныеДанныеПоSSL - Строка - Все отправленные данные SSL
//			** ПолученныеДанныеПоSSL - Строка - Все полученные данные SSL
//
Функция HTTPClientПреобразоватьJsonВРезультат(Знач РезультатВыполнения) Экспорт
	
	РезультатJSON = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(РезультатВыполнения, , Ложь);
	Возврат ?(РезультатJSON <> Неопределено,
			РезультатJSON,
			HTTPClientПреобразоватьJsonВРезультат_ПреобразоватьСоответствиеВСтруктуру(Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(РезультатВыполнения)));
	
КонецФункции

// MySQL - подключить компоненту (если не подключали).
// 
// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура MySQL_ПодключитьЕслиНеПодключали(Кэш) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	// ++ Спец_БСП.Версия1С_20_Ниже
	// До 20 версии 1С ооочень криво работают возвращаемые (вместо поля КомпонентаBaseFunction может вернуться любое значение).
	// Причём на тип внешней компоненты не проверить, поэтому обращаемся к любому свойству.
	Если Кэш.Свойство("КомпонентаMySQL") И Кэш.КомпонентаMySQL <> Неопределено И Не Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(Кэш.КомпонентаMySQL, "ТекстПоследнейОшибки") Тогда Кэш.Удалить("КомпонентаMySQL"); КонецЕсли;
	// -- Спец_БСП.Версия1С_20_Ниже
	
	Если Не Кэш.Свойство("КомпонентаMySQL") Тогда
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.НачатьЗамерДляЛогирования("Подключение компоненты MySQL");
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Кэш.Вставить("КомпонентаMySQL", Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьКомпонентуMySQL());
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Подключение компоненты MySQL", 1, Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  Местоположение - Строка
//  ИмяКомпоненты - Строка
// 
// Возвращаемое значение:
//  Булево
//
Функция ПодключитьКомпоненту(Знач Местоположение, Знач ИмяКомпоненты) Экспорт
	
	// ++ Спец_БСП.Версия1С_21_ВышеИлиРавно
	Попытка
		
		Возврат ПодключитьВнешнююКомпоненту(Местоположение, ИмяКомпоненты, , ТипПодключенияВнешнейКомпоненты.НеИзолированно);
		
	Исключение
		
		Спец_ЗаписатьЛог("Подключение внешней компоненты",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Ошибка"),
				Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке()));
		
	КонецПопытки;
	// -- Спец_БСП.Версия1С_21_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_21_Ниже
	////Попытка
	////	
	////	Возврат ПодключитьВнешнююКомпоненту(Местоположение, ИмяКомпоненты);
	////	
	////Исключение
	////	
	////	Спец_ЗаписатьЛог("Подключение внешней компоненты",
	////			ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Ошибка"),
	////			Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке()));
	////	
	////КонецПопытки;
	// -- Спец_БСП.Версия1С_21_Ниже
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Параметры:
//  ИсходнаяСтрока - см. ТолькоБуквыВСтроку.ИсходнаяСтрока
//  СимволыКоторыеНеТрогать - см. ТолькоБуквыВСтроку.СимволыКоторыеНеТрогать
// 
// Возвращаемое значение:
//  Строка
//
Функция ТолькоБуквыВСтроку_БезКомпоненты(Знач ИсходнаяСтрока, Знач СимволыКоторыеНеТрогать) Экспорт
	
	ЧистыйАлфавит = Спец_КонстантыКлиентСервер.АнглийскийАлфавит() + Спец_КонстантыКлиентСервер.РусскийАлфавит()
			+ НРег(Спец_КонстантыКлиентСервер.АнглийскийАлфавит() + Спец_КонстантыКлиентСервер.РусскийАлфавит())
			+ Спец_КонстантыКлиентСервер.ВсеЦифры()
			+ СимволыКоторыеНеТрогать;
	
	Возврат Спец_СтроковыеФункцииКлиентСервер.ОставитьТолькоНужныеСимволыВСтроке(ИсходнаяСтрока, ЧистыйАлфавит);
	
КонецФункции

// Параметры:
//  JSON - см. Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON
//  СимволыКоторыеНеТрогать - см. ТолькоБуквыВСтрокуJSON.СимволыКоторыеНеТрогать
//  ПрефиксКолонки - см. ТолькоБуквыВСтрокуJSON.ПрефиксКолонки
//  ИмяКолонкиПоУмолчанию - см. ТолькоБуквыВСтрокуJSON.ИмяКолонкиПоУмолчанию
//
Процедура РекурсивноИсправитьJSON(JSON, Знач СимволыКоторыеНеТрогать, Знач ПрефиксКолонки, Знач ИмяКолонкиПоУмолчанию) Экспорт
	
	ТипЭлемента = ТипЗнч(JSON);
	Если ТипЭлемента = Тип("Массив") Тогда
		
		Для Каждого ЭлементJSON Из JSON Цикл
			//@skip-check invocation-parameter-type-intersect
			РекурсивноИсправитьJSON(ЭлементJSON, СимволыКоторыеНеТрогать, ПрефиксКолонки, ИмяКолонкиПоУмолчанию);
		КонецЦикла;
		
	ИначеЕсли ТипЭлемента = Тип("Соответствие") Тогда
		
		СоответствиеКлючейДляПереименования = НовоеСоответствиеКлючейДляПереименования();
		Для Каждого КлючЗначение Из JSON Цикл
			
			НовыйКлюч = ТолькоБуквыВСтроку_БезКомпоненты(КлючЗначение.Ключ, СимволыКоторыеНеТрогать);
			Если ПустаяСтрока(НовыйКлюч) Тогда
				
				НовыйКлюч = ИмяКолонкиПоУмолчанию;
				
			Иначе
				
				Алфавит = Спец_КонстантыКлиентСервер.РусскийАлфавит()
					+ Спец_КонстантыКлиентСервер.АнглийскийАлфавит()
					+ "_";
				
				ПервыйСимвол = Сред(НовыйКлюч, 1, 1);
				Если СтрНайти(Алфавит, ПервыйСимвол) = 0 Тогда
					НовыйКлюч = ПрефиксКолонки + ПрефиксКолонки;
				КонецЕсли;
				
			КонецЕсли;
			
			Если НовыйКлюч <> КлючЗначение.Ключ Тогда
				СоответствиеКлючейДляПереименования[КлючЗначение.Ключ] = НовыйКлюч;
			КонецЕсли;
			
		КонецЦикла;
		
		Для Каждого КлючЗначение Из СоответствиеКлючейДляПереименования Цикл
			
			JSON[КлючЗначение.Значение] = JSON[КлючЗначение.Ключ];
			JSON.Удалить(КлючЗначение.Ключ);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  ИсточникВызова - Строка
//  ОбъектКомпоненты - ОбъектВнешнейКомпоненты:
//		* ТекстПоследнейОшибки - Строка
//  ТекстОшибки - Строка
//
Процедура ДобавитьОшибкуЕслиЕсть(Знач ИсточникВызова, Знач ОбъектКомпоненты, ТекстОшибки)
	
	Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ОбъектКомпоненты.ТекстПоследнейОшибки, ИсточникВызова, ТекстОшибки);
	
КонецПроцедуры

// Параметры:
//  ВходныеДанные - см. Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON
//
Функция HTTPClientПреобразоватьJsonВРезультат_ПреобразоватьСоответствиеВСтруктуру(Знач ВходныеДанные)
	
	ТипВходныеДанные = ТипЗнч(ВходныеДанные);
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(ВходныеДанные) Тогда
		
		СтруктураРезультат = Новый Структура;
		Для Каждого КлючЗначение Из ВходныеДанные Цикл
			
			Если КлючЗначение.Ключ = "ЗаголовкиРезультат" Тогда
				
				СтруктураРезультат.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
				
			Иначе
				
				Попытка
					//@skip-check invocation-parameter-type-intersect
					СтруктураРезультат.Вставить(КлючЗначение.Ключ, HTTPClientПреобразоватьJsonВРезультат_ПреобразоватьСоответствиеВСтруктуру(КлючЗначение.Значение));
				Исключение
					СтруктураРезультат.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
				КонецПопытки;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат СтруктураРезультат;
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ВходныеДанные, ТипВходныеДанные) Тогда
		
		МассивРезультат = Новый Массив; // Массив из см. Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON
		Для Каждого СтрокаСоответствие Из ВходныеДанные Цикл
			//@skip-check invocation-parameter-type-intersect
			МассивРезультат.Добавить(HTTPClientПреобразоватьJsonВРезультат_ПреобразоватьСоответствиеВСтруктуру(СтрокаСоответствие));
		КонецЦикла;
		Возврат МассивРезультат;
		
	Иначе
		
		Возврат ВходныеДанные;
		
	КонецЕсли;
	
КонецФункции

//@skip-check structure-consructor-too-many-keys
#Область Типизация

// Возвращаемое значение:
//	см. HTTPClientПолучитьСтруктуруЗапроса
//  
Функция НоваяСтруктураHTTPЗапроса()

	Возврат Новый Структура(
			
			"ИдентификаторЗапроса,
			|ТелоЗапроса,
			|URL,
			|МетодЗапроса,
			|ИмяФайлаЧтения,
			|ИмяФайлаРезультат,
			|Заголовки",
			
			"",
			"",
			"",
			"",
			"",
			"",
			Спец_ОбщегоНазначенияКлиентСервер.ЗаголовкиДляHTTPЗапросовПоУмолчанию());

КонецФункции

// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//		* Ключ - Строка
//		* Значение - Произвольный
//
Функция НовоеСоответствиеКлючейДляПереименования()

	Возврат Новый Соответствие();

КонецФункции

#КонецОбласти

#КонецОбласти
