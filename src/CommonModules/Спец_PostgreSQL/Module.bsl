// @strict-types

//@skip-check method-too-many-params

#Область ПрограммныйИнтерфейс

// Обновить структуру всех таблиц базы данных PostgreSQL для текущей базы.
// 
// Параметры:
//	ИдентификаторЗадания - Строка - Идентификатор фонового задания из Спец_РаботаСФоновымиЗаданиямиКлиентСервер.ПолучитьСтруктуруПараметровВыполненияФоновогоЗадания
//
Процедура ОбновитьСтруктуруТаблицPostgreSQL(Знач ИдентификаторЗадания = "") Экспорт
	
	// Только при любой реструктуризации базы. В остальных случаях незачем.
	Кэш = Спец_ПолучитьКэш(); // см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.НачатьЗамерДляЛогирования("Обновление структуры таблиц PostgreSQL", Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLСоединениеУспешноУстановлено(Кэш),
			"Не удалось подключиться к базе PostgreSQL!",
			"Обновление структуры таблиц PostgreSQL");
	
	ТекстОшибки = "";

	Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLИнициализироватьДополнительныеФункцииДляРаботыС1С(Кэш);
	
	ОбновитьОсновныеТаблицыИзPostgreSQL(Новый Массив(), ИдентификаторЗадания, Кэш, 5, 1);
	РеструктуризироватьТаблицыВPostgreSQL(ИдентификаторЗадания, ТекстОшибки, Кэш, 5, 2);
	ПерестроитьИндексыFillFactors(ИдентификаторЗадания, Кэш, 5, 4);

	Если ПустаяСтрока(ИдентификаторЗадания) Тогда
		
		Спец_ОбщегоНазначения.ЗаписатьОшибки("Обновление структуры таблиц PostgreSQL", ТекстОшибки);
		
	Иначе
		
		Спец_Проверить(ПустаяСтрока(ТекстОшибки), ТекстОшибки);
		Спец_РаботаСФоновымиЗаданиями.ЗавершитьРаботуПоФоновомуЗаданию(ИдентификаторЗадания);

	КонецЕсли;
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Обновление структуры таблиц PostgreSQL", , Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
КонецПроцедуры

// Кластеризация очистка всех таблиц базы данных PostgreSQL для текущей базы.
// 
// Параметры:
//	ИдентификаторЗадания - Строка - Идентификатор фонового задания из Спец_РаботаСФоновымиЗаданиямиКлиентСервер.ПолучитьСтруктуруПараметровВыполненияФоновогоЗадания
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура КластеризацияОчисткаВсехТаблиц(Знач ИдентификаторЗадания = "", Кэш = Неопределено) Экспорт
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.НачатьЗамерДляЛогирования("Кластеризация / очистка всех таблиц (PostgreSQL)", Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLСоединениеУспешноУстановлено(Кэш),
			"Не удалось подключиться к базе PostgreSQL!",
			"Спец_PostgreSQL.КластеризацияОчисткаВсехТаблиц");
	
	ТекстСообщений = "";
	
	КластеризацияОчисткаВсехТаблицVACUUM(ИдентификаторЗадания, ТекстСообщений, Кэш);
	КластеризацияОчисткаВсехТаблицCLUSTER(ИдентификаторЗадания, ТекстСообщений, Кэш);
	КластеризацияОчисткаВсехТаблицREINDEX(ИдентификаторЗадания, ТекстСообщений, Кэш);
	КластеризацияОчисткаВсехТаблицСбросСтатистики(ИдентификаторЗадания, ТекстСообщений, Кэш);
	
	Спец_ОбщегоНазначения.ЗаписатьОшибки("Кластеризация / очистка всех таблиц (PostgreSQL)", ТекстСообщений);
	Спец_РаботаСФоновымиЗаданиями.ЗавершитьРаботуПоФоновомуЗаданию(ИдентификаторЗадания);
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Кластеризация / очистка всех таблиц (PostgreSQL)", , Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов

КонецПроцедуры

// Закинуть часто используемые таблицы в оперативную память на сервере PostgreSQL (pg_prewarm).
// 
// Параметры:
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ЗакинутьТаблицыВОперативнуюПамять(Кэш = Неопределено) Экспорт
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.НачатьЗамерДляЛогирования("Помещение таблиц в оперативную память PostgreSQL сервера", Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLСоединениеУспешноУстановлено(Кэш),
			"Не удалось подключиться к базе PostgreSQL!",
			"Спец_PostgreSQL.ЗакинутьТаблицыВОперативнуюПамять");
	
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос("SELECT autoprewarm_dump_now()", 1, , Кэш);
	
	ВыборкаРезультат = ПолучитьТаблицыДляПомещенияВОпертивнуюПамять();
	Пока ВыборкаРезультат.Следующий() Цикл
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос("SELECT pg_prewarm('" + ВыборкаРезультат.ИмяТаблицыХранения + "')", 1, , Кэш);
	КонецЦикла;
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Помещение таблиц в оперативную память PostgreSQL сервера", , Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов

КонецПроцедуры

// Cтруктура для установки параметров таблицы в PostgreSQL.
// 
// Параметры:
//	ПолноеИмяМетаданных - Строка - Полное имя метаданных
// 
// Возвращаемое значение:
//	Структура - Подготовить структуру для установки в PostrgeSQL:
//		* ПолноеИмяМетаданных - Строка - Полное имя метаданных таблицы
//		* МассивИндексов - Массив из см. ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL
//						 - ФиксированныйМассив из см. ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL - Массив структур индексов для установки
//		* МассивОграничений - Массив из см. ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL
//							- ФиксированныйМассив из см. ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL - Массив структур ограничений для установки
//		* СоответствиеТриггеров - Соответствие из КлючИЗначение:
//			** Ключ - Строка - Имя триггера
//			** Значение - Строка - Текст запроса триггера
//		* Fillfactor - Число - Fillfactor таблицы
//		* ИмяТабличногоПространства - Строка - Имя табличного пространства в PostgreSQL
//		* ТабличныеЧасти - Массив из Структура:
//			** ПолноеИмяМетаданных - Строка - Полное имя метаданных таблицы
//			** МассивИндексов - Массив из см. ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL - Массив структур индексов для установки
//			** МассивОграничений - Массив из см. ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL - Массив структур ограничений для установки
//			** СоответствиеТриггеров - Соответствие из КлючИЗначение - Триггеры для установки:
//				*** Ключ - Строка - Имя триггера
//				*** Значение - Строка - Текст запроса триггера
//			** Fillfactor - Число - Fillfactor таблицы
//			** ИмяТабличногоПространства - Строка - Имя табличного пространства в PostgreSQL
//		* НазначениеТаблицы - Строка - Назначение таблицы в 1С
//
Функция ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Знач ПолноеИмяМетаданных) Экспорт
	
	//@skip-check structure-consructor-too-many-keys
	Возврат Новый Структура("ПолноеИмяМетаданных, МассивИндексов, МассивОграничений, СоответствиеТриггеров, Fillfactor, ИмяТабличногоПространства, ТабличныеЧасти, НазначениеТаблицы",
			ПолноеИмяМетаданных,
			Новый Массив(),
			Новый Массив(),
			Новый Соответствие(),
			100,
			"",
			Новый Массив(),
			"Основная");

КонецФункции

// Структура для установки индекса в PostgreSQL.
// 
// Параметры:
//	ИменаСтолбцовДляИндексации - Строка - Имена полей для индексации, разделённые запятыми
// 
// Возвращаемое значение:
//	Структура - Структура для создания нового индекса в PostgreSQL:
//		* МассивПолей - Массив из Строка - Массив полей для установки индекса
//		* Уникальный - Булево - Индекс будет создан уникальным
//		* КлассОператоров - Строка - Класс операторов индекса
//		* Fillfactor - Число - Fillfactor индекса
//		* Кластер - Булево - Индекс будет создан кластеризованным
//		* ИмяТабличногоПространства - Строка - Имя табличного пространства для индекса
//		* МассивУсловий - Массив из Строка - Массив условий для частичного индекса
//
Функция ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL(Знач ИменаСтолбцовДляИндексации) Экспорт
	
	//@skip-check structure-consructor-too-many-keys
	СтруктураИндекса = Новый Структура("МассивПолей, Уникальный, КлассОператоров, Fillfactor, Кластер, ИмяТабличногоПространства, МассивУсловий",
										СтрРазделить(ИменаСтолбцовДляИндексации, ",", Ложь),
										Ложь,
										"",
										95,
										Ложь,
										"", 
										Новый Массив());
	
	// Подчищаем лишние пробелы (если есть)
	Для i = 0 По СтруктураИндекса.МассивПолей.ВГраница() Цикл СтруктураИндекса.МассивПолей[i] = СокрЛП(СтруктураИндекса.МассивПолей[i]); КонецЦикла;

	СтруктураИндекса.МассивПолей = Спец_РаботаСКоллекциямиКлиентСервер.СвернутьМассив(СтруктураИндекса.МассивПолей);
	Возврат СтруктураИндекса;

КонецФункции

// Структура ограничения для установки в PostgreSQL.
// 
// Параметры:
//	ИменаСтолбцовДляОграничения - Строка - Имена столбцов для ограничения, разделённые запятыми
// 
// Возвращаемое значение:
//	Структура - Структура для создания нового ограничения в PostgreSQL:
//		* МассивПолей - Массив из Строка - Массив полей в ограничении
//		* Fillfactor - Число - FillFactor ограничения
//		* Кластер - Булево - Ограничение будет создано кластеризованным
//		* ТипОграничения - Строка - Тип создаваемого ограничения
//		* ИмяТабличногоПространства - Строка - Имя табличного пространства для ограничения
//
Функция ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL(Знач ИменаСтолбцовДляОграничения) Экспорт
	
	//@skip-check structure-consructor-too-many-keys
	СтруктураОграничения = Новый Структура("МассивПолей, Fillfactor, Кластер, ТипОграничения, ИмяТабличногоПространства",
			СтрРазделить(ИменаСтолбцовДляОграничения, ",", Ложь),
			90,
			Ложь,
			"PRIMARY KEY",
			"");
	
	// Подчищаем лишние пробелы (если есть)
	Для i = 0 По СтруктураОграничения.МассивПолей.ВГраница() Цикл СтруктураОграничения.МассивПолей[i] = СокрЛП(СтруктураОграничения.МассивПолей[i]); КонецЦикла;

	СтруктураОграничения.МассивПолей = Спец_РаботаСКоллекциямиКлиентСервер.СвернутьМассив(СтруктураОграничения.МассивПолей);
	Возврат СтруктураОграничения;

КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Обновить основные таблицы по данным из PostgreSQL.
// 
// Параметры:
//	МассивИменТаблиц - Массив из Строка - Массив имен таблиц отбор (имена таблиц в PostgreSQL)
//					 - ФиксированныйМассив из Строка
//	ИдентификаторЗадания - Строка - см. Спец_РаботаСФоновымиЗаданиямиКлиентСервер.ПолучитьСтруктуруПараметровВыполненияФоновогоЗадания
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//	ВсегоПунктов - Число - Всего пунктов для выполнения текущего фонового задания
//	ТекущийПункт - Число - Текущий пункт выполнения фонового задания для расчёта состояния
//
Процедура ОбновитьОсновныеТаблицыИзPostgreSQL(Знач МассивИменТаблиц, Знач ИдентификаторЗадания = "", Кэш = Неопределено, Знач ВсегоПунктов = 1, Знач ТекущийПункт = 1) Экспорт
	
	Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLСоединениеУспешноУстановлено(Кэш),
			"Не удалось подключиться к базе PostgreSQL!",
			"Спец_PostgreSQL.ОбновитьОсновныеТаблицыИзPostgreSQL");
	
	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания("Обновляем структуру таблиц (получаем данные)",
																  ИдентификаторЗадания,
																  Спец_РаботаСФоновымиЗаданиямиКлиентСервер.РассчитатьКоэффициентСостояния(1,
																																		   ТекущийПункт,
																																		   ВсегоПунктов));
	ТаблицаДанныеИз1С = ПодготовитьДанныеИз1СПоТаблицам();
	СтруктураТаблиц = ПодготовитьДанныеИзPostgreSQLПоТаблицам(МассивИменТаблиц, Кэш);
	
	// Обрабатываем данные
	ВсегоТаблиц = СтруктураТаблиц.ТаблицаИменаТаблиц.Количество();
	ТекущаяТаблица = -1;

	Для Каждого СтрокаТаблица Из СтруктураТаблиц.ТаблицаИменаТаблиц Цикл
		
		ТекущаяТаблица = ТекущаяТаблица + 1;

		ТекстСтатуса = СтрШаблон("Обновляем структуру таблиц (данные по %1)", СтрокаТаблица.tableName);
		
		Спец_ЗаписатьЛог("Обновление структуры таблиц PostgreSQL", Перечисления.Спец_УровниЛогирования.Информация, ТекстСтатуса);
		Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания(ТекстСтатуса,
																	  ИдентификаторЗадания,
																	  Спец_РаботаСФоновымиЗаданиямиКлиентСервер.РассчитатьКоэффициентСостояния((ТекущаяТаблица / ВсегоТаблиц) * 100,
																																			   ТекущийПункт,
																																			   ВсегоПунктов));

		ОбновитьДанныеПоТаблицеВСтруктуреТаблицPostgreSQL(СтрокаТаблица, СтруктураТаблиц, ТаблицаДанныеИз1С, Кэш);

	КонецЦикла;
	
	// Удаляем удаленные.
	Если МассивИменТаблиц.Количество() = 0 Тогда

		Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания("Обновляем структуру таблиц (удаляем старые таблицы)",
																	  ИдентификаторЗадания,
																	  Спец_РаботаСФоновымиЗаданиямиКлиентСервер.РассчитатьКоэффициентСостояния(100,
																																			   ТекущийПункт,
																																			   ВсегоПунктов));

		ВыборкаРезультат = ПолучитьВыборкуПоТаблицамДляУдаления(СтруктураТаблиц.ТаблицаИменаТаблиц.ВыгрузитьКолонку("tableName"));
		Пока ВыборкаРезультат.Следующий() Цикл
			
			Спец_ЗаписатьЛог("Обновление структуры таблиц PostgreSQL", Перечисления.Спец_УровниЛогирования.Информация, "Пометка на удаление устаревшей таблицы " + ВыборкаРезультат.Ссылка);
			СправочникОбъект = Спец_ОбщегоНазначения.ПолучитьОбъектСБлокированием(ВыборкаРезультат.Ссылка, Кэш);
			
			Спец_Проверить(СправочникОбъект <> Неопределено,
					"Что-то блокирует элемент " + СправочникОбъект.Ссылка,
					"Спец_PostgreSQL.ОбновитьОсновныеТаблицыИзPostgreSQL");
			
			СправочникОбъект.ОбщийРазмерТаблицы       = 0;
			СправочникОбъект.РазмерТаблицыБезИндексов = 0;
			СправочникОбъект.ДатаПоследнейОчистки     = Дата(1, 1, 1);
			СправочникОбъект.ВремяПоследнейОчистки    = 0;
			СправочникОбъект.ПометкаУдаления          = Истина;
			
			Спец_ОбщегоНазначения.ЗаписатьОбъект(СправочникОбъект, , , , Кэш);

		КонецЦикла;

	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ОбновлениеСтруктурТаблицPostgreSQL

// Возвращаемое значение:
//	Массив из см. ПодготовитьСтруктуруДляУстановкиВPostgreSQL
//
Функция МассивСтандартныхИндексовДляУстановки()

	МассивСтруктурДляОбновления = Новый Массив(); // Массив из см. ПодготовитьСтруктуруДляУстановкиВPostgreSQL

#Область Справочники
	
	// ++ Спец_БСП.ВнешниеОбработки
	// Справочник.Спец_ВнешниеОбработки
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.Справочники.Спец_ВнешниеОбработки.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 99;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка");
	СтруктураОграничения.Fillfactor = 99;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Наименование, Ссылка");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураИндекса.Уникальный = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Родитель, Ссылка");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураИндекса.Уникальный = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	// -- Спец_БСП.ВнешниеОбработки
	
	// ++ Спец_БСП.ОбменСДругимиБазами_ЕстьМодульОтправителя
	// Справочник.Спец_ГруппыБазДляОбщихОбменов
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.Справочники.Спец_ГруппыБазДляОбщихОбменов.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("БазаДляОбщихПараметровОбмена");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Наименование, Ссылка");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураИндекса.Уникальный = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);
	
	// Справочник.Спец_ГруппыБазДляОбщихОбменов.ОбщиеБазы
	СтруктураДляИндексацииТЧ = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(СтруктураДляИндексации.ПолноеИмяМетаданных + ".ОбщиеБазы");
	СтруктураДляИндексацииТЧ.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка, _keyfield");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураДляИндексацииТЧ.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("База, Ссылка");
	СтруктураИндекса.Кластер    = Истина;
	СтруктураИндекса.Fillfactor = 100;
	СтруктураДляИндексацииТЧ.МассивИндексов.Добавить(СтруктураИндекса);

	СтруктураДляИндексации.ТабличныеЧасти.Добавить(СтруктураДляИндексацииТЧ);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	// -- Спец_БСП.ОбменСДругимиБазами_ЕстьМодульОтправителя
	
	// Справочник.Спец_Базы
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.Справочники.Спец_Базы.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 95;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка");
	СтруктураОграничения.Fillfactor = 95;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Код, Ссылка");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураИндекса.Уникальный = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Наименование, ВключитьОбмен, Ссылка");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураИндекса.Уникальный = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ГУИД");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);
	
	// Справочник.Спец_Базы.HTTP
	СтруктураДляИндексацииТЧ = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(СтруктураДляИндексации.ПолноеИмяМетаданных + ".HTTP");
	СтруктураДляИндексацииТЧ.Fillfactor = 99;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка, _keyfield");
	СтруктураОграничения.Fillfactor = 99;
	СтруктураДляИндексацииТЧ.МассивОграничений.Добавить(СтруктураОграничения);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ЭтоЛокальныйАдрес, Ссылка");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураДляИндексацииТЧ.МассивИндексов.Добавить(СтруктураИндекса);
	
	СтруктураДляИндексации.ТабличныеЧасти.Добавить(СтруктураДляИндексацииТЧ);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// Справочник.Спец_МассивЗначенийКонстант
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.Справочники.Спец_МассивЗначенийКонстант.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 99;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка");
	СтруктураОграничения.Fillfactor = 99;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Владелец, Наименование, Ссылка");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураИндекса.Кластер = Истина;
	СтруктураИндекса.Уникальный = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);
	
	// Справочник.Спец_МассивЗначенийКонстант.ЗначенияКонстанты
	СтруктураДляИндексацииТЧ = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(СтруктураДляИндексации.ПолноеИмяМетаданных + ".ЗначенияКонстанты");
	СтруктураДляИндексацииТЧ.Fillfactor = 90;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка, _keyfield");
	СтруктураОграничения.Fillfactor = 90;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексацииТЧ.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураДляИндексации.ТабличныеЧасти.Добавить(СтруктураДляИндексацииТЧ);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// Справочник.Спец_Пользователи
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.Справочники.Спец_Пользователи.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Наименование, Ссылка");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураИндекса.Уникальный = Истина;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);

	// Справочник.Спец_Пользователи.ПараметрыРаботыСКомпонентами
	СтруктураДляИндексацииТЧ = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(СтруктураДляИндексации.ПолноеИмяМетаданных + ".ПараметрыРаботыСКомпонентами");
	СтруктураДляИндексацииТЧ.Fillfactor = 90;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка, _keyfield");
	СтруктураОграничения.Fillfactor = 90;
	СтруктураДляИндексацииТЧ.МассивОграничений.Добавить(СтруктураОграничения);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("НаименованиеКомпоненты, Ссылка");
	СтруктураИндекса.Fillfactor = 90;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураДляИндексацииТЧ.МассивИндексов.Добавить(СтруктураИндекса);
	
	СтруктураДляИндексации.ТабличныеЧасти.Добавить(СтруктураДляИндексацииТЧ);
	
	
	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// Справочник.Спец_СтруктураТаблицБазыДанных
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.Справочники.Спец_СтруктураТаблицБазыДанных.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 99;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка");
	СтруктураОграничения.Fillfactor = 99;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Наименование");
	СтруктураОграничения.ТипОграничения = "UNIQUE";
	СтруктураОграничения.Fillfactor     = 99;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("НаименованиеВ1С, Метаданные, Ссылка");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураИндекса.Уникальный = Истина;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Родитель, Код, Ссылка");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураИндекса.Уникальный = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);
	
	// Справочник.Спец_СтруктураТаблицБазыДанных.Столбцы
	СтруктураДляИндексацииТЧ = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(СтруктураДляИндексации.ПолноеИмяМетаданных + ".Столбцы");
	СтруктураДляИндексацииТЧ.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка, _keyfield");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураДляИндексацииТЧ.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ИмяСтолбцаВ1С, ИмяСтолбца");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураДляИндексацииТЧ.МассивИндексов.Добавить(СтруктураИндекса);

	СтруктураДляИндексации.ТабличныеЧасти.Добавить(СтруктураДляИндексацииТЧ);
	
	// Справочник.Спец_СтруктураТаблицБазыДанных.Индексы
	СтруктураДляИндексацииТЧ = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(СтруктураДляИндексации.ПолноеИмяМетаданных + ".Индексы");
	СтруктураДляИндексацииТЧ.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка, _keyfield");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексацииТЧ.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ИмяИндекса");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураДляИндексацииТЧ.МассивИндексов.Добавить(СтруктураИндекса);

	СтруктураДляИндексации.ТабличныеЧасти.Добавить(СтруктураДляИндексацииТЧ);
	
	// Справочник.Спец_СтруктураТаблицБазыДанных.Ограничения
	СтруктураДляИндексацииТЧ = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(СтруктураДляИндексации.ПолноеИмяМетаданных + ".Ограничения");
	СтруктураДляИндексацииТЧ.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка, _keyfield");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексацииТЧ.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ИмяОграничения");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураДляИндексацииТЧ.МассивИндексов.Добавить(СтруктураИндекса);

	СтруктураДляИндексации.ТабличныеЧасти.Добавить(СтруктураДляИндексацииТЧ);
	
	// Справочник.Спец_СтруктураТаблицБазыДанных.Триггеры
	СтруктураДляИндексацииТЧ = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(СтруктураДляИндексации.ПолноеИмяМетаданных + ".Триггеры");
	СтруктураДляИндексацииТЧ.Fillfactor = 100;

	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка, _keyfield");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексацииТЧ.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ИмяТриггера");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураДляИндексацииТЧ.МассивИндексов.Добавить(СтруктураИндекса);

	СтруктураДляИндексации.ТабличныеЧасти.Добавить(СтруктураДляИндексацииТЧ);
	
	// Справочник.Спец_СтруктураТаблицБазыДанных.ПредопределенныеДанные
	СтруктураДляИндексацииТЧ = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(СтруктураДляИндексации.ПолноеИмяМетаданных + ".ПредопределенныеДанные");
	СтруктураДляИндексацииТЧ.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка, _keyfield");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураДляИндексацииТЧ.МассивОграничений.Добавить(СтруктураОграничения);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ЭлементСсылка(ТипТаблицы), ЭлементСсылка(НомерТаблицы), ЭлементСсылка(ИдентификаторСсылки)");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураДляИндексацииТЧ.МассивИндексов.Добавить(СтруктураИндекса);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ГУИДВБазеДанных");
	СтруктураИндекса.Fillfactor = 100;

	СтруктураДляИндексации.ТабличныеЧасти.Добавить(СтруктураДляИндексацииТЧ);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);

#КонецОбласти

#Область Перечисления
	
	// Все перечисления
	Для Каждого МетаданныеПеречисления Из Метаданные.Перечисления Цикл

		СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(МетаданныеПеречисления.ПолноеИмя());
		СтруктураДляИндексации.Fillfactor = 100;
		
		СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка");
		СтруктураОграничения.Fillfactor = 100;
		СтруктураОграничения.Кластер    = Истина;
		СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

		СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Порядок, Ссылка");
		СтруктураИндекса.Fillfactor = 100;
		СтруктураИндекса.Уникальный = Истина;
		СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);

		МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);

	КонецЦикла;

#КонецОбласти

#Область ПланыВидовХарактеристик
	
	// ПланВидовХарактеристик.Спец_Константы
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.ПланыВидовХарактеристик.Спец_Константы.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 99;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Ссылка");
	СтруктураОграничения.Fillfactor = 99;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("Наименование, Родитель");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураИндекса.Кластер    = Истина;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);
	
	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ГУИД");
	СтруктураИндекса.Fillfactor = 99;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);
	
	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);

#КонецОбласти

#Область РегистрыСведений
	
	// ++ Спец_БСП.ОбменСДругимиБазами_ЕстьМодульОтправителя
	
	// РегистрСведений.Спец_ГУИДыОбъектовДругихБаз
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ГУИДыОбъектовДругихБаз.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 95;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("База, Объект(ТипТаблицы), Объект(НомерТаблицы), Объект(ИдентификаторСсылки), ДополнительныйПараметр");
	СтруктураОграничения.Fillfactor = 95;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ГУИД, МетаданныеПолноеИмя, База");
	СтруктураИндекса.Fillfactor = 95;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);
	
	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	// -- Спец_БСП.ОбменСДругимиБазами_ЕстьМодульОтправителя
	
	// ++ Спец_БСП.ОбменСДругимиБазами_ЧтоТоЕсть
	// РегистрСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Регистры
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Регистры.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 75;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("База, Объект_1, Объект_2, Объект_3, Объект_4, Объект_5, UnixTimestamp");
	СтруктураОграничения.Fillfactor = 75;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);
	
	СтруктураДляИндексации.СоответствиеТриггеров["lykov_special_exchange_reg_before_insert"] =
	
	"CREATE OR REPLACE FUNCTION lykov_special_exchange_reg_before_insert_function() RETURNS TRIGGER AS $lykov_special_exchange_reg_before_insert_function$
	|	BEGIN
	|		-- Заполняем UnixTimestamp
	|		IF NEW.[РегистрСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Регистры.UnixTimestamp] <= 0 THEN
	|			NEW.[РегистрСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Регистры.UnixTimestamp] = [ТекущийUnixTimestampВPostrgeSQL];
	|		END IF;
	|		
	|		RETURN NEW;
	|	END;
	|$lykov_special_exchange_reg_before_insert_function$ LANGUAGE plpgsql;
	|
	|
	|CREATE TRIGGER lykov_special_exchange_reg_before_insert
	|	BEFORE INSERT OR UPDATE
	|	ON public.[РегистрСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Регистры]
	|	FOR EACH ROW
	|	EXECUTE PROCEDURE lykov_special_exchange_reg_before_insert_function()";

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// РегистрСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Ссылки
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Ссылки.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 75;

	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("База, Объект(ТипТаблицы), Объект(НомерТаблицы), Объект(ИдентификаторСсылки), UnixTimestamp");
	СтруктураОграничения.Fillfactor = 75;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);
	
	СтруктураДляИндексации.СоответствиеТриггеров["lykov_special_exchange_rref_before_insert"] =
	
	"CREATE OR REPLACE FUNCTION lykov_special_exchange_rref_before_insert_function() RETURNS TRIGGER AS $lykov_special_exchange_rref_before_insert_function$
	|	BEGIN
	|		-- Заполняем UnixTimestamp
	|		IF NEW.[РегистрСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Ссылки.UnixTimestamp] <= 0 THEN
	|			NEW.[РегистрСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Ссылки.UnixTimestamp] = [ТекущийUnixTimestampВPostrgeSQL];
	|		END IF;
	|		
	|		RETURN NEW;
	|	END;
	|$lykov_special_exchange_rref_before_insert_function$ LANGUAGE plpgsql;
	|
	|
	|CREATE TRIGGER lykov_special_exchange_rref_before_insert
	|	BEFORE INSERT OR UPDATE
	|	ON public.[РегистрСведений.Спец_ЗарегистрированныеОбъектыДляОбмена_Ссылки]
	|	FOR EACH ROW
	|	EXECUTE PROCEDURE lykov_special_exchange_rref_before_insert_function()";
	
	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	// -- Спец_БСП.ОбменСДругимиБазами_ЧтоТоЕсть
	
	// РегистрСведений.Спец_КэшДляФоновыхЗаданий
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_КэшДляФоновыхЗаданий.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 90;

	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("ИдентификаторЗадания");
	СтруктураОграничения.Fillfactor = 90;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	// РегистрСведений.Спец_ЛогиПоОбъектам
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ЛогиПоОбъектам.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 85;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("UnixTimestamp, Источник");
	СтруктураОграничения.Fillfactor = 85;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);
	
	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	// ++ Спец_БСП.Спец_НочнойРасчет
	// РегистрСведений.Спец_НастройкиНочногоРасчета
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_НастройкиНочногоРасчета.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("ИмяПроцедурыВыполнения, ИмяМетаданныхРегламента");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	// -- Спец_БСП.Спец_НочнойРасчет
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	// РегистрСведений.Спец_ОбъектыДляЛогирования
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ОбъектыДляЛогирования.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("ИмяМетаданных");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	// ++ Спец_БСП.ОбменСДругимиБазами_ЕстьМодульПолучателя
	// РегистрСведений.Спец_ОбъектыДляРегистрацииДляОбменов
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ОбъектыДляРегистрацииДляОбменов.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("ПолноеИмяОбъектаМетаданных, База");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	// -- Спец_БСП.ОбменСДругимиБазами_ЕстьМодульПолучателя
	
	// ++ Спец_БСП.ОбменСДругимиБазами_ЕстьМодульОтправителя
	// РегистрСведений.Спец_ПараметрыОбменовСДругимиБазами
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ПараметрыОбменовСДругимиБазами.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("База, ПолноеИмяОбъектаМетаданныхИсточник");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ПолноеИмяОбъектаМетаданныхПриемник, ОбменВключен");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// РегистрСведений.Спец_ПривязкаКлючевыхОбъектовКБазам
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ПривязкаКлючевыхОбъектовКБазам.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("База, КлючевойОбъект(ТипТаблицы), КлючевойОбъект(НомерТаблицы), КлючевойОбъект(ИдентификаторСсылки)");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// РегистрСведений.Спец_СоответствиеОбъектовДляОбмена
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_СоответствиеОбъектовДляОбмена.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("База, ИмяОбъектаМетаданныхИсточник, ИмяТабличнойЧастиИсточник, ИмяРеквизитаИсточник");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	СтруктураИндекса = ПодготовитьСтруктуруИндексаДляУстановкиВPostgreSQL("ИмяОбъектаМетаданныхПриемник, ИмяТабличнойЧастиПриемник, ИмяРеквизитаПриемник");
	СтруктураИндекса.Fillfactor = 100;
	СтруктураДляИндексации.МассивИндексов.Добавить(СтруктураИндекса);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// РегистрСведений.Спец_СтруктураТаблицБДИзДругихБаз
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_СтруктураТаблицБДИзДругихБаз.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 100;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("База, ИмяОбъектаМетаданных, ИмяТабличнойЧасти, ИмяРеквизита, ИмяТаблицыВБД, ИмяСтолбцаВБД");
	СтруктураОграничения.Fillfactor = 100;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	// -- Спец_БСП.ОбменСДругимиБазами_ЕстьМодульОтправителя
	
	// РегистрСведений.Спец_РегистрОшибок
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_РегистрОшибок.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 85;

	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Период, Источник");
	СтруктураОграничения.Fillfactor = 85;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// РегистрСведений.Спец_УведомленияДляПользователей
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_УведомленияДляПользователей.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 90;

	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Период, ИмяПользователя");
	СтруктураОграничения.Fillfactor = 90;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);

	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// РегистрСведений.Спец_ХранимыеЗначенияКонстант
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ХранимыеЗначенияКонстант.ПолноеИмя());
	СтруктураДляИндексации.Fillfactor = 90;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Константа, Период");
	СтруктураОграничения.Fillfactor = 90;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);
	
	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);
	
	// РегистрСведений.Спец_ХранимыеЗначенияКонстант.СрезПоследних
	СтруктураДляИндексации = ПодготовитьСтруктуруДляУстановкиВPostgreSQL(Метаданные.РегистрыСведений.Спец_ХранимыеЗначенияКонстант.ПолноеИмя());
	СтруктураДляИндексации.НазначениеТаблицы = "ИтогиСрезПоследних";
	СтруктураДляИндексации.Fillfactor = 90;
	
	СтруктураОграничения = ПодготовитьСтруктуруОграниченияДляУстановкиВPostgreSQL("Константа, Период");
	СтруктураОграничения.Fillfactor = 90;
	СтруктураОграничения.Кластер    = Истина;
	СтруктураДляИндексации.МассивОграничений.Добавить(СтруктураОграничения);
	
	МассивСтруктурДляОбновления.Добавить(СтруктураДляИндексации);

#КонецОбласти

	Возврат МассивСтруктурДляОбновления;

КонецФункции

// Параметры:
//	ИдентификаторЗадания - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//	ВсегоПунктов - Число
//	ТекущийПункт - Число
//
Процедура ПерестроитьИндексыFillFactors(Знач ИдентификаторЗадания, Знач Кэш, Знач ВсегоПунктов, Знач ТекущийПункт)

	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания("Перестроение индексов (проставляем fill factor по умолчанию)",
																  ИдентификаторЗадания,
																  Спец_РаботаСФоновымиЗаданиямиКлиентСервер.РассчитатьКоэффициентСостояния(1, ТекущийПункт, ВсегоПунктов));
	
	МассивИндексовДляПерестроения = ПолучитьМассивИндексовДляПерестроения(Кэш);
	УстановитьFillFactorДляИндексовПоУмолчанию(МассивИндексовДляПерестроения, Кэш);

	МассивИменИндексов = Новый Массив(); // Массив из Строка
	Для Каждого СтрокаИндекс Из МассивИндексовДляПерестроения Цикл МассивИменИндексов.Добавить(СокрЛП(СтрокаИндекс.name)); КонецЦикла;

	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	СтруктураТаблицБазыДанных.Наименование КАК Наименование
	|ИЗ
	|	Справочник.Спец_СтруктураТаблицБазыДанных.Индексы КАК СтруктураТаблицБазыДанныхИндексы
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Спец_СтруктураТаблицБазыДанных КАК СтруктураТаблицБазыДанных
	|		ПО СтруктураТаблицБазыДанныхИндексы.Ссылка = СтруктураТаблицБазыДанных.Ссылка
	|ГДЕ
	|	СтруктураТаблицБазыДанныхИндексы.ИмяИндекса В(&МассивИменИндексов)
	|	И НЕ СтруктураТаблицБазыДанных.ПометкаУдаления";

	Запрос.УстановитьПараметр("МассивИменИндексов", МассивИменИндексов);

	РезультатЗапроса = Запрос.Выполнить();
	Если Не РезультатЗапроса.Пустой() Тогда

		ОбновитьОсновныеТаблицыИзPostgreSQL(РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("Наименование"),
											ИдентификаторЗадания,
											Кэш,
											ВсегоПунктов,
											ТекущийПункт + 1);

	КонецЕсли;

КонецПроцедуры

// Параметры:
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  
// Возвращаемое значение:
//	Массив из см. НоваяСтруктураСтрокиИндексаДляПерестроения
//
Функция ПолучитьМассивИндексовДляПерестроения(Знач Кэш)
	
	Спец_ЗаписатьЛог("Обновление структуры таблиц PostgreSQL", Перечисления.Спец_УровниЛогирования.Информация, "Получение массива контрейнстов из PostgreSQL");
	
	МассивКонстрейнтовДляЗапроса = Новый Массив(); // Массив из Строка
	МассивКонстрейнтов           = ПолучитьМассивСуществующихКонстрейнтов(Кэш);

	Для Каждого Констрейнт Из МассивКонстрейнтов Цикл
		МассивКонстрейнтовДляЗапроса.Добавить(СтрШаблон("'%1'", Констрейнт));
	КонецЦикла;

	ТекстЗапроса =
	"SELECT C.RELNAME AS NAME,
	|	PG_GET_INDEXDEF(C.OID) AS SCRYPT
	|FROM PG_CATALOG.PG_CLASS AS C
	|	JOIN PG_CATALOG.PG_NAMESPACE AS N
	|	ON N.OID = C.RELNAMESPACE
	|WHERE C.RELKIND = 'i'
	|	AND N.NSPNAME = 'public'
	| 	AND NOT c.relname IN ([МассивКонстрейнтов])";

	Если МассивКонстрейнтовДляЗапроса.Количество() = 0 Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "AND NOT c.relname IN ([МассивКонстрейнтов])", "");
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[МассивКонстрейнтов]", СтрСоединить(МассивКонстрейнтовДляЗапроса, ","));
	КонецЕсли;

	СтруктураРезультатЗапроса = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Если Не СтруктураРезультатЗапроса.Успешно Тогда
		Возврат Новый Массив();
	КонецЕсли;
	
	Спец_ЗаписатьЛог("Обновление структуры таблиц PostgreSQL", Перечисления.Спец_УровниЛогирования.Информация, "Формирование массива индексов PostrgeSQL для перестроения");
	МассивКластеров = ПолучитьМассивСуществующихКластеров(Кэш);
	МассивРезультат = Новый Массив(); // Массив из см. НоваяСтруктураСтрокиИндексаДляПерестроения:

	Для Каждого СтруктураСтроки Из СтруктураРезультатЗапроса.РезультатЗапроса Цикл

		СтруктураСтрокиРезультат = НоваяСтруктураСтрокиИндексаДляПерестроения(СтруктураСтроки);
		Если ПустаяСтрока(СтруктураСтрокиРезультат.scrypt) Тогда
			Продолжить;
		КонецЕсли;

		ЗаполнитьСкриптКластераДляИндекса(МассивКластеров, СтруктураСтрокиРезультат);
		Если УжеЕстьПереопределенияИндекса(ВРег(СтруктураСтрокиРезультат.scrypt)) Тогда
			Продолжить;
		КонецЕсли;

		МассивРезультат.Добавить(СтруктураСтрокиРезультат);

	КонецЦикла;

	Возврат МассивРезультат;

КонецФункции

// Параметры:
//	МассивКластеров - см. ПолучитьМассивСуществующихКластеров
//	СтрокаИндекс - см. НоваяСтруктураСтрокиИндексаДляПерестроения
//
Процедура ЗаполнитьСкриптКластераДляИндекса(Знач МассивКластеров, СтрокаИндекс)

	Если МассивКластеров.Найти(СтрокаИндекс.name) = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ПозицияС = СтрНайти(ВРег(СтрокаИндекс.scrypt), "ON ");
	Если ПозицияС > 0 Тогда

		ИмяКластернойТаблицы = Сред(СтрокаИндекс.scrypt, ПозицияС + 3);

		ПозицияПо = СтрНайти(ИмяКластернойТаблицы, "USING ");
		Если ПозицияПо > 0 Тогда

			ИмяКластернойТаблицы = СокрЛП(Лев(ИмяКластернойТаблицы, ПозицияПо - 1));
			СтрокаИндекс.СкриптКластера = " ALTER TABLE " + ИмяКластернойТаблицы + " CLUSTER ON " + СтрокаИндекс.name;

		КонецЕсли;

	КонецЕсли;

КонецПроцедуры

// Параметры:
//	МассивИндексовДляПерестроения - см. ПолучитьМассивИндексовДляПерестроения
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура УстановитьFillFactorДляИндексовПоУмолчанию(Знач МассивИндексовДляПерестроения, Знач Кэш)

	Если МассивИндексовДляПерестроения.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	ШаблонСкрипта =
	"DROP INDEX %1;
	|
	|
	|%2 WITH (fillfactor=92);
	|
	|
	|%3;";

	Для Каждого СтрокаИндекс Из МассивИндексовДляПерестроения Цикл
		
		Спец_ЗаписатьЛог("Обновление структуры таблиц PostgreSQL", Перечисления.Спец_УровниЛогирования.Информация, "Установка fillfactor по умолчанию для индекса " + СтрокаИндекс.name);
		
		ТекстЗапроса = СтрШаблон(ШаблонСкрипта, СокрЛП(СтрокаИндекс.name), СокрЛП(СтрокаИндекс.scrypt), СокрЛП(СтрокаИндекс.СкриптКластера));
		ТекстОшибки = ""; 
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ТекстЗапроса, ТекстОшибки, Кэш);
		
		Если Не Успешно Тогда
			Спец_ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// Возвращаемое значение:
//	см. Спец_ОбщегоНазначения.ПолучитьТаблицуСтруктурыХраненияБД
//
Функция ПодготовитьДанныеИз1СПоТаблицам()
	
	Спец_ЗаписатьЛог("Обновление структуры таблиц PostgreSQL", Перечисления.Спец_УровниЛогирования.Информация, "Получение данных по таблицам из 1С");
	
	ТаблицаДанныеИз1С = Спец_ОбщегоНазначения.ПолучитьТаблицуСтруктурыХраненияБД();
	Для Каждого СтрокаИз1С Из ТаблицаДанныеИз1С Цикл

		СтрокаИз1С.ИмяТаблицыХранения = ВРег(СтрокаИз1С.ИмяТаблицыХранения);
		Для Каждого СтрокаПолеИз1С Из СтрокаИз1С.Поля Цикл
			СтрокаПолеИз1С.ИмяПоляХранения = ВРег(СтрокаПолеИз1С.ИмяПоляХранения);
		КонецЦикла;

	КонецЦикла;

	ТаблицаДанныеИз1С.Индексы.Добавить("ИмяТаблицыХранения");
	Возврат ТаблицаДанныеИз1С;

КонецФункции

// Параметры:
//	МассивИменТаблиц - Массив из Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Структура:
//		* ТаблицаИменаТаблиц - см. НоваяТаблицаИменТаблиц
//		* ТаблицаСтолбцы - см. НоваяТаблицаСтолбцы
//		* ТаблицаИндексы - см. НоваяТаблицаИндексы
//		* ТаблицаТриггеры - см. НоваяТаблицаТриггеры
//
Функция ПодготовитьДанныеИзPostgreSQLПоТаблицам(Знач МассивИменТаблиц, Знач Кэш)
	
	Спец_ЗаписатьЛог("Обновление структуры таблиц PostgreSQL", Перечисления.Спец_УровниЛогирования.Информация, "Получение данных по таблицам из PostgreSQL");
	
	//@skip-check structure-consructor-too-many-keys
	СтруктураДляВозврата = Новый Структура("ТаблицаИменаТаблиц,
										   |ТаблицаСтолбцы,
										   |ТаблицаИндексы,
										   |ТаблицаТриггеры",
										   
										   НоваяТаблицаИменТаблиц(),
										   НоваяТаблицаСтолбцы(),
										   НоваяТаблицаИндексы(),
										   НоваяТаблицаТриггеры());
	
	// 1. Начинаем транзакцию
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLНачатьТранзакцию(Кэш);
	
	// 2. Данные по временной таблице
	ТекстЗапроса =
	"CREATE TEMPORARY TABLE vt_nametables ON COMMIT DROP AS
	|SELECT DISTINCT pgtables.tablename AS tablename,
	|	upper(pgtables.tablename) AS tablenameupper,
	|	coalesce(pgtables.tablespace, 'pg_default') AS tablespacetable,
	|	pgtables.tableowner AS ownertable,
	|	coalesce(translate(classinfo.reloptions::text, '{}', ''), '') AS optionstable,
	|	classinfo.oid AS oidtable
	|FROM pg_tables AS pgtables
	|	JOIN information_schema.tables AS tablesinfo ON pgtables.schemaname = tablesinfo.table_schema
	|		AND pgtables.tablename = tablesinfo.table_name
	|	JOIN pg_class AS classinfo ON pgtables.tablename = classinfo.relname
	|WHERE pgtables.schemaname = 'public'
	|	AND tablesinfo.table_type = 'BASE TABLE'
	|	AND &ИмяТаблицыОтбор";

	ТекстДляЗамены = "";
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивИменТаблиц);
	Если МассивИменТаблиц.Количество() > 0 Тогда

		МассивДляСоединения = Новый Массив(); // Массив из Строка
		Для Каждого ИмяТаблицы Из МассивИменТаблиц Цикл
			МассивДляСоединения.Добавить(СтрШаблон("'%1'", ИмяТаблицы));
		КонецЦикла;
		ТекстДляЗамены = "AND pgTables.tablename IN (" + СтрСоединить(МассивДляСоединения, ",") + ")";

	КонецЕсли;

	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "AND &ИмяТаблицыОтбор", ТекстДляЗамены);
	ТекстОшибки  = "";
	
	Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ТекстЗапроса, ТекстОшибки, Кэш),
			 "Не удалось создать временную таблицу!",
			 "Спец_PostgreSQL.ПодготовитьДанныеИзPostgreSQLПоТаблицам");
	
	// 3. Данные по именам таблиц
	ТекстЗапроса =
	
	"SELECT tablename,
	|	tablenameupper,
	|	tablespacetable,
	|	ownertable,
	|	optionstable
	|FROM vt_nametables";
	
	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Спец_Проверить(СтруктураРезультат.Успешно,
			СтруктураРезультат.ТекстОшибки,
			"Спец_PostgreSQL.ПодготовитьДанныеИзPostgreSQLПоТаблицам");
	
	Спец_ОбщегоНазначения.ПреобразоватьМассивСтрокВТаблицуЗначений(СтруктураРезультат.РезультатЗапроса, СтруктураДляВозврата.ТаблицаИменаТаблиц);
	
	// 4. Данные по столбцам таблиц
	ТекстЗапроса =
	"SELECT columnsinfo.table_name AS tablename,
	|	columnsinfo.ordinal_position AS numbercolumn,
	|	columnsinfo.column_name AS columnname,
	|	upper(columnsinfo.column_name) AS columnupper,
	|	columnsinfo.udt_name AS typecolumn,
	|	NOT columnsinfo.is_nullable :: bool AS nullablecolumn,
	|	columnsinfo.numeric_precision AS columnprecision,
	|	columnsinfo.numeric_scale AS columnscale
	|FROM information_schema.columns AS columnsinfo
	|	JOIN vt_nametables AS vt_nametables ON columnsinfo.table_name = vt_nametables.tablename";

	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Спец_Проверить(СтруктураРезультат.Успешно,
			СтруктураРезультат.ТекстОшибки,
			"Спец_PostgreSQL.ПодготовитьДанныеИзPostgreSQLПоТаблицам");
	
	Спец_ОбщегоНазначения.ПреобразоватьМассивСтрокВТаблицуЗначений(СтруктураРезультат.РезультатЗапроса, СтруктураДляВозврата.ТаблицаСтолбцы);
	
	// 5. Данные по индексам
	ТекстЗапроса =
	"SELECT classes.relname AS tablename,
	|	classes2.relname AS indexname,
	|	NOT constraintsinfo.constraint_name ISNULL AS itsconstraint,
	|	am.amname AS typeindex,
	|	indexesinfo.indnkeyatts AS keyatts,
	|	indexesinfo.indkey AS columnsindex,
	|	indexesinfo.indisunique AS uniqueindex,
	|	indexesinfo.indisclustered AS clustered,
	|	coalesce(tablespases.spcname, 'pg_default') AS tablespacetable,
	|	coalesce(pg_get_expr(indexesinfo.indpred, indexesinfo.indrelid), '') AS predicat,
	|	coalesce(translate(classes2.reloptions::text, '{}', ''), '') AS optionstable
	|FROM pg_class AS classes
	|	JOIN vt_nametables AS vt_nametables ON classes.relname = vt_nametables.tablename
	|	JOIN pg_index AS indexesinfo ON classes.oid = indexesinfo.indrelid
	|	JOIN pg_class AS classes2 ON classes2.oid = indexesinfo.indexrelid
	|	LEFT JOIN information_schema.table_constraints AS constraintsinfo ON classes.relname = constraintsinfo.table_name
	|		AND classes2.relname = constraintsinfo.constraint_name
	|	LEFT JOIN pg_tablespace AS tablespases ON classes2.reltablespace = tablespases.oid
	|	JOIN pg_am AS am ON classes2.relam = am.oid";

	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Спец_Проверить(СтруктураРезультат.Успешно,
			СтруктураРезультат.ТекстОшибки,
			"Спец_PostgreSQL.ПодготовитьДанныеИзPostgreSQLПоТаблицам");
	
	Спец_ОбщегоНазначения.ПреобразоватьМассивСтрокВТаблицуЗначений(СтруктураРезультат.РезультатЗапроса, СтруктураДляВозврата.ТаблицаИндексы);
	
	// 6. Данные по триггерам
	ТекстЗапроса =
	"SELECT vt_nametables.tablename AS tablename,
	|	triggersinfo.tgname AS triggername,
	|	proc.prosrc AS functioncode
	|FROM pg_trigger AS triggersinfo
	|	JOIN vt_nametables AS vt_nametables ON triggersinfo.tgrelid = vt_nametables.oidtable
	|	JOIN pg_proc AS proc ON triggersinfo.tgfoid = proc.oid";

	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Спец_Проверить(СтруктураРезультат.Успешно,
			СтруктураРезультат.ТекстОшибки,
			"Спец_PostgreSQL.ПодготовитьДанныеИзPostgreSQLПоТаблицам");

	СтруктураДляВозврата.ТаблицаТриггеры = Спец_ОбщегоНазначения.ПреобразоватьМассивСтрокВТаблицуЗначений(СтруктураРезультат.РезультатЗапроса);
	
	// 7. Завершаем транзакцию
	Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLЗафиксироватьТранзакцию(Кэш),
			"Не удалось завершить транзакцию!",
			"Спец_PostgreSQL.ПодготовитьДанныеИзPostgreSQLПоТаблицам");
	
	Возврат СтруктураДляВозврата;

КонецФункции

// Параметры:
//	СтрокаТаблица - СтрокаТаблицыЗначений: см. НоваяТаблицаИменТаблиц
//	СтруктураТаблицPostgreSQL - см. ПодготовитьДанныеИзPostgreSQLПоТаблицам
//	ТаблицаДанныеИз1С - см. ПодготовитьДанныеИз1СПоТаблицам
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ОбновитьДанныеПоТаблицеВСтруктуреТаблицPostgreSQL(Знач СтрокаТаблица, Знач СтруктураТаблицPostgreSQL, Знач ТаблицаДанныеИз1С, Знач Кэш)

	ЭлементСправочникОбъект = НайтиДанныеПоТаблицеВСтруктуреТаблицPostgreSQL(СтрокаТаблица, Кэш);
	Если ЭлементСправочникОбъект = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ЭлементСправочникОбъект.ПометкаУдаления = Ложь;
	
	СтрокаДанныеИз1С = ТаблицаДанныеИз1С.Найти(СтрокаТаблица.tableNameUpper, "ИмяТаблицыХранения");
	
	// Если это виртуальная таблица регистра, то 1С не возвращает имена полей в 1С.
	
	Если СтрокаДанныеИз1С <> Неопределено
		И Не ПустаяСтрока(СтрокаДанныеИз1С.Метаданные)
		И (СтрНачинаетсяС(СтрокаДанныеИз1С.Назначение, "Итоги")
				Или СтрокаДанныеИз1С.Назначение = "Обороты"
				Или СтрокаДанныеИз1С.Назначение = "НовыеОбороты"
				Или СтрокаДанныеИз1С.Назначение = "БуферОборотов") Тогда
		
		СтруктураОтбора = Новый Структура("Метаданные, Назначение", СтрокаДанныеИз1С.Метаданные, "Основная");
		
		МассивСтрокИз1С = ТаблицаДанныеИз1С.НайтиСтроки(СтруктураОтбора);
		Если МассивСтрокИз1С.Количество() > 0 Тогда
			СтрокаДанныеИз1С.Поля = МассивСтрокИз1С.Получить(0).Поля;
		КонецЕсли;
		
	КонецЕсли;

	ОбновитьОсновныеДанныеПоТаблицеВСтруктуреТаблицPostgreSQL(ЭлементСправочникОбъект, СтрокаТаблица, СтрокаДанныеИз1С, Кэш);
	ОбновитьДанныеПоСтобцамВСтруктуреТаблицPostgreSQL(СтрокаТаблица, ЭлементСправочникОбъект, СтруктураТаблицPostgreSQL.ТаблицаСтолбцы, СтрокаДанныеИз1С);
	ОбновитьДанныеПоИндексамВСтруктуреТаблицPostgreSQL(ЭлементСправочникОбъект, СтрокаТаблица, СтруктураТаблицPostgreSQL.ТаблицаИндексы);
	ОбновитьДанныеПоТриггерамВСтруктуреТаблицPostgreSQL(ЭлементСправочникОбъект, СтрокаТаблица, СтруктураТаблицPostgreSQL.ТаблицаТриггеры);
	ОбновитьДанныеПоПредопределеннымВСтруктуреТаблицPostgreSQL(ЭлементСправочникОбъект, Кэш);
	ОбновитьДанныеПоРазмеруТаблицыВСтруктуреТаблицPostgreSQL(ЭлементСправочникОбъект, Кэш);

	Спец_ОбщегоНазначения.ЗаписатьОбъект(ЭлементСправочникОбъект, , , , Кэш);

КонецПроцедуры

// Параметры:
//	СтрокаТаблица - СтрокаТаблицыЗначений: см. НоваяТаблицаИменТаблиц
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	СправочникОбъект.Спец_СтруктураТаблицБазыДанных
//
Функция НайтиДанныеПоТаблицеВСтруктуреТаблицPostgreSQL(Знач СтрокаТаблица, Знач Кэш)

	МассивИмяТаблицы = СтрРазделить(СтрокаТаблица.tableName, "_", Ложь);
	Если МассивИмяТаблицы.Количество() > 1 Тогда

		ИмяРодителя = "_" + МассивИмяТаблицы.Получить(0);

		ЭлементРодитель = Справочники.Спец_СтруктураТаблицБазыДанных.НайтиПоНаименованию(ИмяРодителя,
																						 Истина,
																						 Справочники.Спец_СтруктураТаблицБазыДанных.ПустаяСсылка());

		Если Не ЗначениеЗаполнено(ЭлементРодитель) Тогда

			ЭлементРодительОбъект = Справочники.Спец_СтруктураТаблицБазыДанных.СоздатьЭлемент();

			ЭлементРодительОбъект.Наименование = ИмяРодителя;
			ЭлементРодительОбъект.Код = Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаВЧисло(ИмяРодителя, Кэш);
			ЭлементРодительОбъект.Родитель = Справочники.Спец_СтруктураТаблицБазыДанных.ПустаяСсылка();

			Спец_ОбщегоНазначения.ЗаписатьОбъект(ЭлементРодительОбъект, , , , Кэш);
			ЭлементРодитель = ЭлементРодительОбъект.Ссылка;

		КонецЕсли;

	Иначе

		ЭлементРодитель = Справочники.Спец_СтруктураТаблицБазыДанных.ПустаяСсылка();

	КонецЕсли;

	ЭлементСправочник = Справочники.Спец_СтруктураТаблицБазыДанных.НайтиПоНаименованию(СтрокаТаблица.tableName, Истина, ЭлементРодитель);
	Если Не ЗначениеЗаполнено(ЭлементСправочник) Тогда
		
		ЭлементСправочникОбъект = Справочники.Спец_СтруктураТаблицБазыДанных.СоздатьЭлемент();
		
	Иначе

		ТекстыОшибок = "";
		
		ЭлементСправочникОбъект = Спец_ОбщегоНазначения.ПолучитьОбъектСБлокированием(ЭлементСправочник, Кэш, ТекстыОшибок); // СправочникОбъект.Спец_СтруктураТаблицБазыДанных
		Спец_Проверить(ЭлементСправочникОбъект <> Неопределено,
				ТекстыОшибок,
				"Спец_PostgreSQL.ОбновитьОсновныеТаблицыИзPostgreSQL");

	КонецЕсли;

	ЭлементСправочникОбъект.Родитель = ЭлементРодитель;
	Возврат ЭлементСправочникОбъект;

КонецФункции

// Параметры:
//	ЭлементСправочникОбъект - СправочникОбъект.Спец_СтруктураТаблицБазыДанных
//	СтрокаТаблица - СтрокаТаблицыЗначений: см. НоваяТаблицаИменТаблиц
//	СтрокаДанныеИз1С - Неопределено - Если нет данных из 1С
//  				 - СтрокаТаблицыЗначений: см. Спец_ОбщегоНазначения.ПолучитьТаблицуСтруктурыХраненияБД
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ОбновитьОсновныеДанныеПоТаблицеВСтруктуреТаблицPostgreSQL(Знач ЭлементСправочникОбъект, Знач СтрокаТаблица, Знач СтрокаДанныеИз1С, Кэш)

	МассивИмяТаблицы = СтрРазделить(СтрокаТаблица.tableName, "_", Ложь);

	ЭлементСправочникОбъект.Код = 0;
	Если СтрНачинаетсяС(СтрокаТаблица.tableName, "_") Тогда
		
		Попытка
			ЭлементСправочникОбъект.Код = Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаВЧисло(МассивИмяТаблицы.Получить(0), Кэш);
		Исключение
			ЭлементСправочникОбъект.Код = 0;
		КонецПопытки;
		
	КонецЕсли;

	ЭлементСправочникОбъект.ПометкаУдаления = Ложь;
	ЭлементСправочникОбъект.Наименование = СтрокаТаблица.tableName;
	ЭлементСправочникОбъект.ТабличноеПространство = СтрокаТаблица.tablespaceTable;
	ЭлементСправочникОбъект.ВладелецТаблицы = СтрокаТаблица.ownerTable;
	ЭлементСправочникОбъект.ПараметрыХранения = СтрокаТаблица.optionsTable;

	НачалоFillfactor = СтрНайти(ВРег(ЭлементСправочникОбъект.ПараметрыХранения), "FILLFACTOR");
	Если НачалоFillfactor > 0 Тогда

		КонецFillFactor = СтрНайти(ВРег(ЭлементСправочникОбъект.ПараметрыХранения), ",", , НачалоFillfactor);
		ЭлементСправочникОбъект.ПроцентЗаполнения = Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаВЧисло(?(КонецFillFactor = 0,
																													Сред(ЭлементСправочникОбъект.ПараметрыХранения,
																														 НачалоFillfactor + 11),
																													Сред(ЭлементСправочникОбъект.ПараметрыХранения,
																														 НачалоFillfactor + 11,
																														 КонецFillFactor
																														 - НачалоFillfactor
																														 - 11)), Кэш);

	КонецЕсли;

	Если ЭлементСправочникОбъект.ПроцентЗаполнения = 0 Тогда
		ЭлементСправочникОбъект.ПроцентЗаполнения = 100;
	КонецЕсли;

	Если СтрокаДанныеИз1С <> Неопределено Тогда

		ЭлементСправочникОбъект.НаименованиеВ1С = СтрокаДанныеИз1С.ИмяТаблицы;
		ЭлементСправочникОбъект.Метаданные = СтрокаДанныеИз1С.Метаданные;
		ЭлементСправочникОбъект.Назначение = СтрокаДанныеИз1С.Назначение;

	КонецЕсли;

КонецПроцедуры

// Параметры:
//	СтрокаТаблица - СтрокаТаблицыЗначений: см. НоваяТаблицаИменТаблиц
//	ЭлементСправочникОбъект - СправочникОбъект.Спец_СтруктураТаблицБазыДанных
//	ТаблицаСтолбцы - см. НоваяТаблицаСтолбцы
//	СтрокаДанныеИз1С - Неопределено - Если нет данных из 1С
//  				 - СтрокаТаблицыЗначений: см. Спец_ОбщегоНазначения.ПолучитьТаблицуСтруктурыХраненияБД
//
Процедура ОбновитьДанныеПоСтобцамВСтруктуреТаблицPostgreSQL(Знач СтрокаТаблица, Знач ЭлементСправочникОбъект, Знач ТаблицаСтолбцы, Знач СтрокаДанныеИз1С)
	
	// Поля
	ЭлементСправочникОбъект.Столбцы.Очистить();
	ЭлементСправочникОбъект.ТекстЗапросаДляСозданияКопииВременнойТаблицы = "";

	Если ТаблицаСтолбцы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	СтруктураОтбора = Новый Структура("tableName", СтрокаТаблица.tableName);

	ТаблицаСтолбцыПоТаблице = ТаблицаСтолбцы.Скопировать(СтруктураОтбора);
	ТаблицаСтолбцыПоТаблице.Сортировать("numberColumn ВОЗР");

	Для Каждого СтрокаСтолбец Из ТаблицаСтолбцыПоТаблице Цикл

		НоваяСтрокаСтолбец = ЭлементСправочникОбъект.Столбцы.Добавить();

		Если СтрокаДанныеИз1С <> Неопределено Тогда

			СтрокаПолеИз1С = СтрокаДанныеИз1С.Поля.Найти(СтрокаСтолбец.columnUpper, "ИмяПоляХранения");
			Если СтрокаПолеИз1С <> Неопределено Тогда

				НоваяСтрокаСтолбец.ИмяСтолбцаВ1С = СтрокаПолеИз1С.ИмяПоля;
				НоваяСтрокаСтолбец.Метаданные = СтрокаПолеИз1С.Метаданные;

			КонецЕсли;

		КонецЕсли;

		НоваяСтрокаСтолбец.ИмяСтолбца = СтрокаСтолбец.columnName;
		НоваяСтрокаСтолбец.НеNull = СтрокаСтолбец.nullableColumn;
		НоваяСтрокаСтолбец.ТипДанных = ПолучитьТипДанныхПоДаннымИзPostgreSQL(СтрокаСтолбец.typeColumn);
		
		// Суффиксы составного типа
		Если (СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "_TYPE") И СтрокаСтолбец.columnUpper <> "_TYPE") Тогда
			НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.ТипТаблицы;
		ИначеЕсли СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "_L") Тогда
			НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.Булево;
		ИначеЕсли СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "_N") Тогда
			НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.Число;
		ИначеЕсли СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "_T") Тогда
			НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.Дата;
		ИначеЕсли СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "_S") Тогда
			НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.Строка;
		ИначеЕсли СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "_B") Тогда
			НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.ДвоичныеДанные;
		ИначеЕсли СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "_RTREF") Или СтрокаСтолбец.columnUpper = "_RECORDERTREF" // Поле регистратор
				  Или СтрокаСтолбец.columnUpper = "_NODETREF" // Поле узел у зарегистрированных изменений
				  Или СтрокаСтолбец.columnUpper = "_DOCUMENTTREF" Тогда // Поле документ у журнала документов

			НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.НомерТаблицы;

		ИначеЕсли СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "_RRREF") Или СтрокаСтолбец.columnUpper = "_RECORDERRREF" // Поле регистратор у РН
				  Или СтрокаСтолбец.columnUpper = "_NODERREF" // Поле ссылка узла для зарегистрированных объектов
				  Или СтрокаСтолбец.columnUpper = "_DOCUMENTRREF" Тогда // Поле документ у журнала документов

			НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.ИдентификаторСсылки;

		КонецЕсли;
		
		// Функции преобразования
		Если СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "RREF") Или СтрокаСтолбец.columnUpper = "_PREDEFINEDID" Или СтрокаСтолбец.columnUpper = "_RECORDERRREF" // Поле регистратор у РН
			 Или СтрокаСтолбец.columnUpper = "_NODERREF" // Поле ссылка узла для зарегистрированных объектов
			 Или СтрокаСтолбец.columnUpper = "_DOCUMENTRREF" Тогда // Поле документ у журнала документов

			НоваяСтрокаСтолбец.ФункцияПреобразования = "lykov_UIDToRRef(%1)";
			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = "mvarchar(36)";

		ИначеЕсли СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "TYPE") И СтрокаСтолбец.columnUpper <> "_TYPE" Тогда

			НоваяСтрокаСтолбец.ФункцияПреобразования = "lykov_TypeToBytea(%1)";
			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = "integer";

		ИначеЕсли СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "RTREF") Или СтрокаСтолбец.columnUpper = "_RECORDERTREF" // Поле регистратор
				  Или СтрокаСтолбец.columnUpper = "_NODETREF" // Поле узел у зарегистрированных изменений
				  Или СтрокаСтолбец.columnUpper = "_DOCUMENTTREF" Тогда // Поле документ у журнала документов

			НоваяСтрокаСтолбец.ФункцияПреобразования = "lykov_RTRefToBytea(%1)";
			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = "integer";

		ИначеЕсли СтрокаСтолбец.columnUpper = "_VERSION" Тогда

			НоваяСтрокаСтолбец.ФункцияПреобразования = "lykov_VersionToInteger(%1)";
			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = "mvarchar(12)";
			НоваяСтрокаСтолбец.ИмяСтолбцаВ1С = "ВерсияДанных";

		ИначеЕсли СтрокаСтолбец.columnUpper = "_KEYFIELD" Тогда

			НоваяСтрокаСтолбец.ФункцияПреобразования = "lykov_KeyFieldToBytea(%1)";
			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = "integer";

		ИначеЕсли СтрокаСтолбец.columnUpper = "TYPE" Или СтрЗаканчиваетсяНа(СтрокаСтолбец.columnUpper, "_B") Тогда

			НоваяСтрокаСтолбец.ФункцияПреобразования = "lykov_DDToBytea(%1)";
			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = "text";

		ИначеЕсли Не ПустаяСтрока(НоваяСтрокаСтолбец.Метаданные) Тогда

			МетаданныеПоля = Метаданные.НайтиПоПолномуИмени(НоваяСтрокаСтолбец.Метаданные); // ОбъектМетаданныхРеквизит
			УстановитьИмяТипаДанныхПоМетаданнымПоля(НоваяСтрокаСтолбец, МетаданныеПоля);

		ИначеЕсли Не ПустаяСтрока(ЭлементСправочникОбъект.Метаданные) И Не ПустаяСтрока(НоваяСтрокаСтолбец.ИмяСтолбцаВ1С) Тогда
			
			// Попробуем найти в стандартных реквизитах
			МетаданныеЭлемента = Метаданные.НайтиПоПолномуИмени(ЭлементСправочникОбъект.Метаданные); // ОбъектМетаданныхСправочник
			Если МетаданныеЭлемента <> Неопределено Тогда

				СтандартныеРеквизиты = ?(Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(МетаданныеЭлемента, "СтандартныеРеквизиты"),
										 МетаданныеЭлемента.СтандартныеРеквизиты,
										 Неопределено);

				Если СтандартныеРеквизиты <> Неопределено Тогда

					Для Каждого СтандартныйРеквизит Из СтандартныеРеквизиты Цикл

						Если СтандартныйРеквизит.Имя = НоваяСтрокаСтолбец.ИмяСтолбцаВ1С Тогда

							НужныйРеквизит = СтандартныйРеквизит;
							Прервать;

						КонецЕсли;

					КонецЦикла;

					УстановитьИмяТипаДанныхПоМетаданнымПоля(НоваяСтрокаСтолбец, НужныйРеквизит);

				КонецЕсли;

			КонецЕсли;

		КонецЕсли;

		Если ПустаяСтрока(НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL) Тогда
			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = ПолучитьИмяТипаДанныхДляКолонкиПоТипуДанных(СтрокаСтолбец);
		КонецЕсли;

	КонецЦикла;
	
	// Текст запроса для временной таблицы (копия по столбцам)
	ШаблонЗапроса =
	"CREATE TEMPORARY TABLE %%1
	|(
	|	%1
	|)";

	МассивПолейДляЗапроса = Новый Массив(); // Массив из Строка
	Для Каждого СтрокаСтолбец Из ЭлементСправочникОбъект.Столбцы Цикл

		ДляДобавления = ?(ПустаяСтрока(СтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL), СтрШаблон("%1", СтрокаСтолбец.ИмяСтолбца), СтрШаблон("%1 %2",
																																	   СтрокаСтолбец.ИмяСтолбца,
																																	   СтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL));

		МассивПолейДляЗапроса.Добавить(ДляДобавления);

	КонецЦикла;

	ЭлементСправочникОбъект.ТекстЗапросаДляСозданияКопииВременнойТаблицы = СтрШаблон(ШаблонЗапроса, СтрСоединить(МассивПолейДляЗапроса, ","
																																		+ Символы.ПС
																																		+ Символы.Таб));

КонецПроцедуры

// Параметры:
//	ЭлементСправочникОбъект - СправочникОбъект.Спец_СтруктураТаблицБазыДанных
//	СтрокаТаблица - СтрокаТаблицыЗначений: см. НоваяТаблицаИменТаблиц
//	ТаблицаИндексы - см. НоваяТаблицаИндексы
//
Процедура ОбновитьДанныеПоИндексамВСтруктуреТаблицPostgreSQL(Знач ЭлементСправочникОбъект, Знач СтрокаТаблица, Знач ТаблицаИндексы)
	
	// Индексы и ограничения
	ЭлементСправочникОбъект.Индексы.Очистить();
	ЭлементСправочникОбъект.Ограничения.Очистить();

	Если ТаблицаИндексы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	СтруктураОтбора = Новый Структура("tableName", СтрокаТаблица.tableName);

	ТаблицаИндексыПоСтроке = ТаблицаИндексы.Скопировать(СтруктураОтбора);
	ТаблицаИндексыПоСтроке.Сортировать("indexName ВОЗР");

	Для Каждого СтрокаИндекс Из ТаблицаИндексыПоСтроке Цикл

		Если СтрокаИндекс.itsConstraint Тогда

			НоваяСтрокаОграничение = ЭлементСправочникОбъект.Ограничения.Добавить();

			НоваяСтрокаОграничение.ИмяОграничения = СтрокаИндекс.indexName;
			НоваяСтрокаОграничение.Столбцы = ПолучитьИменаСтолбцовДляИндекса(ЭлементСправочникОбъект.Столбцы, СтрокаИндекс.columnsIndex, СтрокаИндекс.keyAtts);
			НоваяСтрокаОграничение.ТабличноеПространство = СтрокаИндекс.tablespaceTable;
			НоваяСтрокаОграничение.ПараметрыХранения = СтрокаИндекс.optionsTable;
			НоваяСтрокаОграничение.Кластеризован = СтрокаИндекс.clustered;

		Иначе

			НоваяСтрокаИндекс = ЭлементСправочникОбъект.Индексы.Добавить();

			НоваяСтрокаИндекс.ИмяИндекса = СтрокаИндекс.indexName;
			НоваяСтрокаИндекс.ТипИндекса = ПолучитьТипИндексаПоДаннымИзPostgreSQL(СтрокаИндекс.typeIndex);
			НоваяСтрокаИндекс.Столбцы = ПолучитьИменаСтолбцовДляИндекса(ЭлементСправочникОбъект.Столбцы, СтрокаИндекс.columnsIndex, СтрокаИндекс.keyAtts);
			НоваяСтрокаИндекс.Уникальный = СтрокаИндекс.uniqueIndex;
			НоваяСтрокаИндекс.Кластеризован = СтрокаИндекс.clustered;
			НоваяСтрокаИндекс.ТабличноеПространство = СтрокаИндекс.tablespaceTable;
			НоваяСтрокаИндекс.НеключевыеСтолбцы = ПолучитьИменаНеключевыхСтолбцовДляИндекса(ЭлементСправочникОбъект.Столбцы,
																							СтрокаИндекс.columnsIndex,
																							СтрокаИндекс.keyAtts);
			НоваяСтрокаИндекс.Предикаты = СтрокаИндекс.predicat;
			НоваяСтрокаИндекс.ПараметрыХранения = СтрокаИндекс.optionsTable;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// Параметры:
//	ЭлементСправочникОбъект - СправочникОбъект.Спец_СтруктураТаблицБазыДанных
//	СтрокаТаблица - СтрокаТаблицыЗначений: см. НоваяТаблицаИменТаблиц
//	ТаблицаТриггеры - см. НоваяТаблицаТриггеры
//
Процедура ОбновитьДанныеПоТриггерамВСтруктуреТаблицPostgreSQL(Знач ЭлементСправочникОбъект, Знач СтрокаТаблица, Знач ТаблицаТриггеры)

	ЭлементСправочникОбъект.Триггеры.Очистить();
	Если ТаблицаТриггеры.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	СтруктураОтбора = Новый Структура("tableName", СтрокаТаблица.tableName);

	ТаблицаТриггерыПоСтроке = ТаблицаТриггеры.Скопировать(СтруктураОтбора);
	Для Каждого СтрокаТриггер Из ТаблицаТриггерыПоСтроке Цикл

		НоваяСтрокаТриггер = ЭлементСправочникОбъект.Триггеры.Добавить();

		НоваяСтрокаТриггер.ИмяТриггера = СтрокаТриггер.triggerName;
		НоваяСтрокаТриггер.ФункцияТриггера = СокрЛП(СтрокаТриггер.functionCode);

	КонецЦикла;

КонецПроцедуры

// Параметры:
//	ЭлементСправочникОбъект - СправочникОбъект.Спец_СтруктураТаблицБазыДанных
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ОбновитьДанныеПоПредопределеннымВСтруктуреТаблицPostgreSQL(Знач ЭлементСправочникОбъект, Знач Кэш)

	ЭлементСправочникОбъект.ПредопределенныеДанные.Очистить();
	Если ПустаяСтрока(ЭлементСправочникОбъект.Метаданные) Тогда
		Возврат;
	КонецЕсли;

	СтруктураМетаданных = Спец_ОбщегоНазначения.ПолучитьСтруктуруИмениТипаДанныхОбъекта(ЭлементСправочникОбъект.Метаданные, Кэш);
	Если СтруктураМетаданных.МетаданныеОбъекта = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если Спец_ОбщегоНазначения.ЭтоПеречисление(СтруктураМетаданных.ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда

		Для Каждого СтрокаРезультат Из ПолучитьДанныеПоПеречислениямИзБД(ЭлементСправочникОбъект.Наименование, Кэш) Цикл

			НоваяСтрока = ЭлементСправочникОбъект.ПредопределенныеДанные.Добавить();

			НоваяСтрока.ЭлементСсылка                 = СтруктураМетаданных.МенеджерОбъекта.Получить(СтрокаРезультат.orderEnum);
			НоваяСтрока.ГУИДВБазеДанных               = СтрокаРезультат.UID;
			НоваяСтрока.ТекстовоеПредставлениеОбъекта = СериализаторXDTO.XMLСтрока(НоваяСтрока.ЭлементСсылка);

		КонецЦикла;

	ИначеЕсли ЭлементСправочникОбъект.Столбцы.Найти("_predefinedid", "ИмяСтолбца") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоСправочник(СтруктураМетаданных.ПолноеИмяОбъекта, Кэш, Тип("Строка"))
		Или Спец_ОбщегоНазначенияКлиентСервер.ЭтоПланВидовРасчета(СтруктураМетаданных.ПолноеИмяОбъекта, Кэш, Тип("Строка"))
		Или Спец_ОбщегоНазначенияКлиентСервер.ЭтоПланВидовХарактеристик(СтруктураМетаданных.ПолноеИмяОбъекта, Кэш, Тип("Строка"))
		Или Спец_ОбщегоНазначенияКлиентСервер.ЭтоПланСчетов(СтруктураМетаданных.ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
		
		Если СтруктураМетаданных.МетаданныеОбъекта.ПолучитьИменаПредопределенных().Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		
		Для Каждого СтрокаРезультат Из ПолучитьДанныеПоПредопределеннымЭлементамОбъекта(ЭлементСправочникОбъект.Наименование, Кэш) Цикл

			НоваяСтрока = ЭлементСправочникОбъект.ПредопределенныеДанные.Добавить();

			НоваяСтрока.ЭлементСсылка                 = СтруктураМетаданных.МенеджерОбъекта.ПолучитьСсылку(Новый УникальныйИдентификатор(СтрокаРезультат.UID));
			НоваяСтрока.ГУИДВБазеДанных               = СтрокаРезультат.UID_predefined;
			НоваяСтрока.ТекстовоеПредставлениеОбъекта = СериализаторXDTO.XMLСтрока(НоваяСтрока.ЭлементСсылка);

		КонецЦикла;
		
	ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоПланОбмена(СтруктураМетаданных.ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
		
		НоваяСтрока = ЭлементСправочникОбъект.ПредопределенныеДанные.Добавить();

		НоваяСтрока.ЭлементСсылка                 = СтруктураМетаданных.МенеджерОбъекта.ЭтотУзел();
		НоваяСтрока.ГУИДВБазеДанных               = ПолучитьДанныеПоТекущемуУзлуПланаОбмена(СтруктураМетаданных.МенеджерОбъекта, ЭлементСправочникОбъект.Наименование, Кэш);
		НоваяСтрока.ТекстовоеПредставлениеОбъекта = СериализаторXDTO.XMLСтрока(НоваяСтрока.ЭлементСсылка);
		
	КонецЕсли;

КонецПроцедуры

// Параметры:
//	НаименованиеТаблицы - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Массив из Структура:
//		* UID - Строка
//		* orderEnum - Число
//
Функция ПолучитьДанныеПоПеречислениямИзБД(Знач НаименованиеТаблицы, Знач Кэш)

	ТекстЗапроса = "SELECT lykov_RRefToUID(_idrref) AS UID,
				   |	_enumorder AS orderEnum
				   |FROM " + НаименованиеТаблицы;

	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Спец_Проверить(СтруктураРезультат.Успешно,
				СтруктураРезультат.ТекстОшибки,
				"Спец_PostgreSQL.ПолучитьДанныеПоПеречислениямИзБД");
	
	Возврат СтруктураРезультат.РезультатЗапроса;

КонецФункции

// Параметры:
//	НаименованиеТаблицы - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Массив из Структура:
//		* UID - Строка
//		* UID_predefined - Строка
//
Функция ПолучитьДанныеПоПредопределеннымЭлементамОбъекта(Знач НаименованиеТаблицы, Знач Кэш)

	ТекстЗапроса = "SELECT lykov_RRefToUID(_idrref) AS UID,
				   |	lykov_RRefToUID(_predefinedid) AS UID_predefined
				   |FROM " + НаименованиеТаблицы + "
				   |WHERE _predefinedid <> lykov_uidtorref('')";

	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Спец_Проверить(СтруктураРезультат.Успешно,
			СтруктураРезультат.ТекстОшибки,
			"Спец_PostgreSQL.ПолучитьДанныеПоПредопределеннымЭлементамОбъекта");
	
	Возврат СтруктураРезультат.РезультатЗапроса;

КонецФункции

// Параметры:
//  МенеджерПланаОбмена - ПланОбменаМенеджер
//	НаименованиеТаблицы - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьДанныеПоТекущемуУзлуПланаОбмена(Знач МенеджерПланаОбмена, Знач НаименованиеТаблицы, Знач Кэш)

	ТекстЗапроса = "SELECT lykov_RRefToUID(_predefinedid) AS uid
				   |FROM " + НаименованиеТаблицы + "
				   |WHERE _idrref = %1";
	
	ТекстЗапроса = СтрШаблон(ТекстЗапроса, Спец_PostgreSQLКлиентСервер.ПолучитьЗначениеДляPostgreSQLВТекстЗапроса(МенеджерПланаОбмена.ЭтотУзел()));
	
	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Спец_Проверить(СтруктураРезультат.Успешно,
			СтруктураРезультат.ТекстОшибки,
			"Спец_PostgreSQL.ПолучитьДанныеПоПредопределеннымЭлементамОбъекта");
	
	Если СтруктураРезультат.РезультатЗапроса.Количество() > 0 Тогда
		Возврат СтруктураРезультат.РезультатЗапроса.Получить(0)["uid"];
	Иначе
		Возврат "";
	КонецЕсли;

КонецФункции

// Параметры:
//	ЭлементСправочникОбъект - СправочникОбъект.Спец_СтруктураТаблицБазыДанных
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ОбновитьДанныеПоРазмеруТаблицыВСтруктуреТаблицPostgreSQL(Знач ЭлементСправочникОбъект, Знач Кэш)

	ЭлементСправочникОбъект.ОбщийРазмерТаблицы = Спец_PostgreSQLКлиентСервер.ПолучитьРазмерОбъектаВPostgreSQL(ЭлементСправочникОбъект.Наименование, Истина, Кэш);
	ЭлементСправочникОбъект.РазмерТаблицыБезИндексов = Спец_PostgreSQLКлиентСервер.ПолучитьРазмерОбъектаВPostgreSQL(ЭлементСправочникОбъект.Наименование,
																													Ложь,
																													Кэш);

	Для Каждого СтрокаИндекс Из ЭлементСправочникОбъект.Индексы Цикл
		СтрокаИндекс.РазмерИндекса = Спец_PostgreSQLКлиентСервер.ПолучитьРазмерОбъектаВPostgreSQL(СтрокаИндекс.ИмяИндекса, Ложь, Кэш);
	КонецЦикла;
	Для Каждого СтрокаОграничение Из ЭлементСправочникОбъект.Ограничения Цикл
		СтрокаОграничение.РазмерИндекса = Спец_PostgreSQLКлиентСервер.ПолучитьРазмерОбъектаВPostgreSQL(СтрокаОграничение.ИмяОграничения, Ложь, Кэш);
	КонецЦикла;

КонецПроцедуры

// Параметры:
//	ИдентификаторЗадания - Строка
//	ТекстОшибки - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//	ВсегоПунктов - Число
//	ТекущийПункт - Число
//
//@skip-check query-in-loop
Процедура РеструктуризироватьТаблицыВPostgreSQL(Знач ИдентификаторЗадания, ТекстОшибки, Знач Кэш, Знач ВсегоПунктов, Знач ТекущийПункт)

	ОбновитьПовторноИспользуемыеЗначения();

	МассивОбновленныхТаблиц = Новый Массив(); // Массив из Строка - Сюда класть имена измененных таблиц (имя в PostgreSQL)
	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания("Обновление структур таблиц (только для текущей базы, подготовка структур индексов для обновления)",
																  ИдентификаторЗадания,
																  Спец_РаботаСФоновымиЗаданиямиКлиентСервер.РассчитатьКоэффициентСостояния(0, ТекущийПункт, ВсегоПунктов));

	МассивСтруктурДляОбновления = МассивСтандартныхИндексовДляУстановки();
	Спец_Переопределяемый.ОбновитьСтруктуруТаблицPostgreSQLТолькоДляТекущейБазы(МассивСтруктурДляОбновления, Кэш);
	Спец_РаботаСКоллекциямиКлиентСервер.СортироватьМассивСтруктурПоКлючу(МассивСтруктурДляОбновления, "ПолноеИмяМетаданных");

	Всего   = МассивСтруктурДляОбновления.Количество();
	Текущий = 0;

	Для Каждого СтруктураДляОбновления Из МассивСтруктурДляОбновления Цикл

		Текущий = Текущий + 1;
		Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания(СтрШаблон("Обновление структур таблиц (только для текущей базы, %1)", СтруктураДляОбновления.ПолноеИмяМетаданных),
																	  ИдентификаторЗадания,
																	  Спец_РаботаСФоновымиЗаданиямиКлиентСервер.РассчитатьКоэффициентСостояния((Текущий / Всего * 100),
																																			   ТекущийПункт,
																																			   ВсегоПунктов));

		МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(СтруктураДляОбновления.ПолноеИмяМетаданных);
		Если МетаданныеОбъекта = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		ПараметрыТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(СтруктураДляОбновления.ПолноеИмяМетаданных, СтруктураДляОбновления.НазначениеТаблицы);
		Если ПустаяСтрока(ПараметрыТаблицы.НаименованиеВPostgreSQL) Тогда
			Продолжить;
		КонецЕсли;
		
		НужноОбновление = ОбработатьСтруктуруДляИндексации(ПараметрыТаблицы.НаименованиеВPostgreSQL, СтруктураДляОбновления, Кэш);

		Если НужноОбновление Тогда
			МассивОбновленныхТаблиц.Добавить(ПараметрыТаблицы.НаименованиеВPostgreSQL);
		КонецЕсли;

		Для Каждого СтруктураДляОбновленияТабличнойЧасти Из СтруктураДляОбновления.ТабличныеЧасти Цикл

			ПараметрыТаблицыТабличнойЧасти = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(СтруктураДляОбновленияТабличнойЧасти.ПолноеИмяМетаданных);
			Если ПустаяСтрока(ПараметрыТаблицыТабличнойЧасти.НаименованиеВPostgreSQL) Тогда
				Продолжить;
			КонецЕсли;
			
			НужноОбновление = ОбработатьСтруктуруДляИндексации(ПараметрыТаблицыТабличнойЧасти.НаименованиеВPostgreSQL,
															   СтруктураДляОбновленияТабличнойЧасти,
															   Кэш);

			Если НужноОбновление Тогда
				МассивОбновленныхТаблиц.Добавить(ПараметрыТаблицыТабличнойЧасти.НаименованиеВPostgreSQL);
			КонецЕсли;

		КонецЦикла;

		Текущий = Текущий + 1;

	КонецЦикла;

	МассивОбновленныхТаблиц = Спец_РаботаСКоллекциямиКлиентСервер.СвернутьМассив(МассивОбновленныхТаблиц);
	
	// Обновляем в конце измененные таблицы.
	Если МассивОбновленныхТаблиц.Количество() > 0 Тогда
		ОбновитьОсновныеТаблицыИзPostgreSQL(МассивОбновленныхТаблиц, ИдентификаторЗадания, Кэш, ВсегоПунктов, ТекущийПункт + 1);
	КонецЕсли;

	ОбновитьПовторноИспользуемыеЗначения();

КонецПроцедуры

// Параметры:
//	НаименованиеВPostgreSQL - Строка
//	СтруктураДляОбновления - см. ПодготовитьСтруктуруДляУстановкиВPostgreSQL
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Булево
//
Функция ОбработатьСтруктуруДляИндексации(Знач НаименованиеВPostgreSQL, Знач СтруктураДляОбновления, Знач Кэш)

	ШаблонИмяОбъекта = "_lykov" + НаименованиеВPostgreSQL + "_";
	НужноОбновление  = Ложь;
	
	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	СтруктураТаблицБазыДанных.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.Спец_СтруктураТаблицБазыДанных КАК СтруктураТаблицБазыДанных
	|ГДЕ
	|	СтруктураТаблицБазыДанных.Наименование = &Наименование
	|	И НЕ СтруктураТаблицБазыДанных.ПометкаУдаления";

	Запрос.УстановитьПараметр("Наименование", НаименованиеВPostgreSQL);

	СсылкаНаТаблицуДляОбновления = Спец_ОбщегоНазначения.ПолучитьСтруктуруПервойВыборкиЗапроса(Запрос, "Ссылка"); // СправочникСсылка.Спец_СтруктураТаблицБазыДанных
	Спец_Проверить(СсылкаНаТаблицуДляОбновления,
			"Не удалось найти таблицу в справочнике " + НаименованиеВPostgreSQL,
			"Спец_PostgreSQL.ОбработатьСтруктуруДляИндексации: " + СтруктураДляОбновления.ПолноеИмяМетаданных);
	
	Спец_ЗаписатьЛог("Обновление структуры таблиц PostgreSQL", Перечисления.Спец_УровниЛогирования.Информация, "Обработка структуры для индексации для таблицы " + НаименованиеВPostgreSQL);
	
#Область ПараметрыТаблицы
	
	// Перезаписываем только, если различаются параметры таблицы (т.е. только fillfactor или tablespace)
	СтруктураТекущихДанных = ПолучитьТекущиеПараметрыТаблицыВPostgreSQL(СсылкаНаТаблицуДляОбновления);
	Если СтруктураТекущихДанных.ПроцентЗаполнения <> СтруктураДляОбновления.Fillfactor Тогда
		
		ТекстОшибки = "";
		ТекстЗапроса = СтрШаблон("ALTER TABLE public.%1 SET (fillfactor = %2)", НаименованиеВPostgreSQL, Формат(СтруктураДляОбновления.Fillfactor, "ЧН=100; ЧГ="));
		Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ТекстЗапроса, ТекстОшибки, Кэш),
				ТекстОшибки,
				"Спец_PostgreSQL.ОбработатьСтруктуруДляИндексации: " + СтруктураДляОбновления.ПолноеИмяМетаданных);
		
		НужноОбновление = Истина;
		
	КонецЕсли;
	
	// Имя табличного пространства отдельно, при этом не вызываем исключение (так как копии баз), если не удалось переопределить
	Если Не ПустаяСтрока(СтруктураДляОбновления.ИмяТабличногоПространства)
		 И СокрЛП(ВРег(СтруктураТекущихДанных.ТабличноеПространство)) <> СокрЛП(ВРег(СтруктураДляОбновления.ИмяТабличногоПространства)) Тогда
		
		ТекстЗапроса = СтрШаблон("ALTER TABLE public.%1 SET TABLESPACE %2", НаименованиеВPostgreSQL, СокрЛП(СтруктураДляОбновления.ИмяТабличногоПространства));
		
		ТекстОшибки = "";
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ТекстЗапроса, ТекстОшибки, Кэш);
		Если Не Успешно Тогда
			Спец_ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
		Иначе
			НужноОбновление = Истина;
		КонецЕсли;
		
	КонецЕсли;

#КонецОбласти

#Область Индексы

	МассивТекстЗапроса = Новый Массив(); // Массив из Строка

	ТаблицаТекущихИндексов = ПолучитьТаблицуТекущихИндексов(СсылкаНаТаблицуДляОбновления);
	Для Каждого СтрокаИндекс Из ТаблицаТекущихИндексов Цикл
		СтрокаИндекс.Столбцы = ВРег(СокрЛП(СтрокаИндекс.Столбцы));
	КонецЦикла;
	ТаблицаТекущихИндексов.Индексы.Добавить("Столбцы");

	Для Каждого СтруктураИндекса Из СтруктураДляОбновления.МассивИндексов Цикл

		НовоеИмяИндекса = ШаблонИмяОбъекта + "index_" + СтрЗаменить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.ПолучитьУникальныйИдентификатор(Кэш),
																	"-",
																	"_");
		
		// Столбцы индекса
		МассивИменПолей  = Новый Массив(); // Массив из Строка
		МассивТекстПолей = Новый Массив(); // Массив из Строка

		Для Каждого ИмяПоля Из СтруктураИндекса.МассивПолей Цикл

			Если ИмяПоля = "_keyfield" Или ИмяПоля = "_numberprefix" Тогда

				МассивТекстПолей.Добавить(СтрШаблон("%1 %2ASC NULLS LAST", ИмяПоля, ?(ПустаяСтрока(СтруктураИндекса.КлассОператоров),
																					  "",
																					  СтруктураИндекса.КлассОператоров + " ")));

				МассивИменПолей.Добавить(ИмяПоля);

			Иначе

				МассивТекстПолей.Добавить(СтрШаблон("[%1.%2] %3ASC NULLS LAST",
													СтруктураДляОбновления.ПолноеИмяМетаданных,
													ИмяПоля,
													?(ПустаяСтрока(СтруктураИндекса.КлассОператоров), "", СтруктураИндекса.КлассОператоров + " ")));

				МассивИменПолей.Добавить(СтрШаблон("[%1.%2]", СтруктураДляОбновления.ПолноеИмяМетаданных, ИмяПоля));

			КонецЕсли;

		КонецЦикла;

		ТекстЧистыхПолей = Спец_РаботаСБазойДанныхНапрямую.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(СтрСоединить(МассивИменПолей, ","), Кэш);
		
		// Формируем текст запроса
		ТекстПолей   = СтрСоединить(МассивТекстПолей, ", ");
		ТекстИндекс  = ?(СтруктураИндекса.Уникальный, "CREATE UNIQUE INDEX", "CREATE INDEX");
		ТекстУсловий = ?(СтруктураИндекса.МассивУсловий.Количество() > 0,
						 "WHERE " + СтрСоединить(СтруктураИндекса.МассивУсловий, Символы.ПС + "		AND"),
						 "");

		ТекстЗапроса = СтрШаблон("%1 %2
								 |	ON public.%3 USING btree
								 |	(%4)
								 |	WITH (FILLFACTOR=%5)
								 |	%7
								 |	%6",
								 ТекстИндекс,
								 НовоеИмяИндекса,
								 НаименованиеВPostgreSQL,
								 ТекстПолей,
								 Формат(СтруктураИндекса.Fillfactor, "ЧН=90; ЧГ="),
								 ТекстУсловий,
								 ?(ПустаяСтрока(СтруктураИндекса.ИмяТабличногоПространства), "", "TABLESPACE "
																								 + СокрЛП(СтруктураИндекса.ИмяТабличногоПространства)));

		Если СтруктураИндекса.Кластер Тогда

			ТекстЗапроса = ТекстЗапроса + СтрШаблон(";
													|
													|
													|ALTER TABLE public.%1 CLUSTER ON %2", НаименованиеВPostgreSQL, НовоеИмяИндекса);

		КонецЕсли;
		
		// Проверяем, нужно ли добавлять
		НужноДобавлять = Ложь;

		СтрокаТекущийИндекс = ТаблицаТекущихИндексов.Найти(ВРег(СокрЛП(ТекстЧистыхПолей)), "Столбцы");
		Если СтрокаТекущийИндекс = Неопределено Тогда

			НужноДобавлять = Истина;

		Иначе

			ТекущийFillFactor = 90;

			МассивТекущихПараметровХранения = СтрРазделить(СтрокаТекущийИндекс.ПараметрыХранения, ",", Ложь);
			Для Каждого Параметр Из МассивТекущихПараметровХранения Цикл

				ВРегПараметр = СокрЛП(ВРег(Параметр));
				Если СтрНачинаетсяС(ВРегПараметр, "FILLFACTOR") Тогда

					МассивСРавно = СтрРазделить(ВРегПараметр, "=", Ложь);
					Если МассивСРавно.Количество() = 2 Тогда
						ТекущийFillFactor = Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаВЧисло(МассивСРавно.Получить(1), Кэш);
					КонецЕсли;

				КонецЕсли;

			КонецЦикла;

			НужноДобавлять = (СтруктураИндекса.Уникальный <> СтрокаТекущийИндекс.Уникальный) Или (СтруктураИндекса.Кластер <> СтрокаТекущийИндекс.Кластеризован)
							 Или ?(ПустаяСтрока(СтруктураИндекса.ИмяТабличногоПространства),
								   Ложь,
								   ВРег(СокрЛП(СтруктураИндекса.ИмяТабличногоПространства)) <> ВРег(СокрЛП(СтрокаТекущийИндекс.ТабличноеПространство)))
							 Или (ТекущийFillFactor <> СтруктураИндекса.Fillfactor);

			Если НужноДобавлять Тогда // Удаляем текущий индекс
				МассивТекстЗапроса.Вставить(0, "DROP INDEX IF EXISTS " + СтрокаТекущийИндекс.ИмяИндекса);
			КонецЕсли;

			ТаблицаТекущихИндексов.Удалить(СтрокаТекущийИндекс);

		КонецЕсли;

		Если НужноДобавлять Тогда
			МассивТекстЗапроса.Добавить(ТекстЗапроса);
		КонецЕсли;

	КонецЦикла;

	Для Каждого СтрокаЛишнийИндекс Из ТаблицаТекущихИндексов Цикл
		МассивТекстЗапроса.Вставить(0, "DROP INDEX IF EXISTS " + СтрокаЛишнийИндекс.ИмяИндекса);
	КонецЦикла;

	Если МассивТекстЗапроса.Количество() > 0 Тогда

		ГотовыйТекстЗапроса = Спец_РаботаСБазойДанныхНапрямую.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(СтрСоединить(МассивТекстЗапроса,
																																Символы.ПС
																																+ Спец_КонстантыКлиентСервер.РазделительЗапросовВPostgreSQL()), Кэш);
		ТекстОшибки = "";
		
		// Проверяем, что ошибка не на табличное пространство
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ГотовыйТекстЗапроса, ТекстОшибки, Кэш);
		Если Не Успешно Тогда
			
			МассивДляУдаления = Новый Массив(); // Массив из Строка
			МассивОчищенныйТекстЗапроса = СтрРазделить(ГотовыйТекстЗапроса, Символы.ПС);
			
			Для Каждого СтрокаДляПроверки Из МассивОчищенныйТекстЗапроса Цикл
				
				Если СтрНачинаетсяС(СокрЛ(СтрокаДляПроверки), "TABLESPACE ") Тогда
					МассивДляУдаления.Добавить(СтрокаДляПроверки);
				КонецЕсли;
				
			КонецЦикла; 
			
			Спец_Проверить(МассивДляУдаления.Количество() > 0,
					ТекстОшибки,
					"Спец_PostgreSQL.ОбработатьСтруктуруДляИндексации: " + СтруктураДляОбновления.ПолноеИмяМетаданных);
			
			Для Каждого СтрокаДляУдаления Из МассивДляУдаления Цикл
				Спец_РаботаСКоллекциямиКлиентСервер.УдалитьЗначениеИзМассива(МассивОчищенныйТекстЗапроса, СтрокаДляУдаления);
			КонецЦикла;
			
			ГотовыйТекстЗапроса = СтрСоединить(МассивОчищенныйТекстЗапроса, Символы.ПС);
			
			ТекстОшибки = "";
			Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ГотовыйТекстЗапроса, ТекстОшибки, Кэш),
					ТекстОшибки,
					"Спец_PostgreSQL.ОбработатьСтруктуруДляИндексации: " + СтруктураДляОбновления.ПолноеИмяМетаданных);
			
		КонецЕсли;
		
		НужноОбновление = Истина;

	КонецЕсли;

#КонецОбласти

#Область Ограничения

	МассивТекстЗапроса = Новый Массив(); // Массив из Строка

	ТаблицаТекущихОграничений = ПолучитьТаблицуТекущихОграничений(СсылкаНаТаблицуДляОбновления);
	Для Каждого СтрокаОграничение Из ТаблицаТекущихОграничений Цикл
		СтрокаОграничение.Столбцы = ВРег(СокрЛП(СтрокаОграничение.Столбцы));
	КонецЦикла;
	ТаблицаТекущихОграничений.Индексы.Добавить("Столбцы");

	Для Каждого СтруктураОграничения Из СтруктураДляОбновления.МассивОграничений Цикл

		НовоеИмяОграничения = ШаблонИмяОбъекта
							  + "constraint_"
							  + СтрЗаменить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.ПолучитьУникальныйИдентификатор(Кэш), "-", "_");
		
		// Столбцы ограничения
		МассивПолейДляОграничения = Новый Массив(); // Массив из Строка
		Для Каждого ИмяПоля Из СтруктураОграничения.МассивПолей Цикл

			Если ИмяПоля = "_keyfield" Или ИмяПоля = "_numberprefix" Тогда
				МассивПолейДляОграничения.Добавить(ИмяПоля);
			Иначе
				МассивПолейДляОграничения.Добавить(СтрШаблон("[%1.%2]", СтруктураДляОбновления.ПолноеИмяМетаданных, ИмяПоля));
			КонецЕсли;

		КонецЦикла;

		ТекстСтолбцы = Спец_РаботаСБазойДанныхНапрямую.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(СтрСоединить(МассивПолейДляОграничения,
																																	 ","), Кэш);
		
		// Формируем текст запроса
		ТекстЗапроса = СтрШаблон("ALTER TABLE public.%1 ADD CONSTRAINT %2 %3 (%4)
								 |	WITH (FILLFACTOR=%5)
								 |%6",
								 НаименованиеВPostgreSQL,
								 НовоеИмяОграничения,
								 СтруктураОграничения.ТипОграничения,
								 ТекстСтолбцы,
								 Формат(СтруктураОграничения.Fillfactor, "ЧН=90; ЧГ="),
								 ?(ПустаяСтрока(СтруктураОграничения.ИмяТабличногоПространства), "", "USING INDEX TABLESPACE "
																									 + СокрЛП(СтруктураОграничения.ИмяТабличногоПространства)));

		Если СтруктураОграничения.Кластер Тогда

			ТекстЗапроса = ТекстЗапроса + СтрШаблон("
													|;
													|
													|CLUSTER public.%1 USING %2", НаименованиеВPostgreSQL, НовоеИмяОграничения);

		КонецЕсли;
		
		// Проверяем, нужно ли обновлять
		НужноДобавлять = Ложь;

		СтрокаТекущееОграничение = ТаблицаТекущихОграничений.Найти(ВРег(СокрЛП(ТекстСтолбцы)), "Столбцы");
		Если СтрокаТекущееОграничение = Неопределено Тогда

			НужноДобавлять = Истина;

		Иначе // Проверяем, изменились ли какие-либо параметры

			ТекущийFillFactor = 90;

			МассивТекущихПараметровХранения = СтрРазделить(СтрокаТекущееОграничение.ПараметрыХранения, ",", Ложь);
			Для Каждого Параметр Из МассивТекущихПараметровХранения Цикл

				ВРегПараметр = СокрЛП(ВРег(Параметр));
				Если СтрНачинаетсяС(ВРегПараметр, "FILLFACTOR") Тогда

					МассивСРавно = СтрРазделить(ВРегПараметр, "=", Ложь);
					Если МассивСРавно.Количество() = 2 Тогда
						ТекущийFillFactor = Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаВЧисло(МассивСРавно.Получить(1), Кэш);
					КонецЕсли;

				КонецЕсли;

			КонецЦикла;

			НужноДобавлять = ?(ПустаяСтрока(СтруктураОграничения.ИмяТабличногоПространства),
							   Ложь,
							   ВРег(СокрЛП(СтруктураОграничения.ИмяТабличногоПространства)) <> ВРег(СокрЛП(СтрокаТекущееОграничение.ТабличноеПространство)))
							 Или (ТекущийFillFactor <> СтруктураОграничения.Fillfactor)
							 Или (СтрокаТекущееОграничение.Кластеризован <> СтруктураОграничения.Кластер);

			Если НужноДобавлять Тогда // Удаляем текущее ограничение

				ТекстЗапросаДляУдаления = СтрШаблон("ALTER TABLE IF EXISTS public.%1 DROP CONSTRAINT IF EXISTS %2",
													НаименованиеВPostgreSQL,
													СтрокаТекущееОграничение.ИмяОграничения);

				МассивТекстЗапроса.Вставить(0, ТекстЗапросаДляУдаления);

			КонецЕсли;

			ТаблицаТекущихОграничений.Удалить(СтрокаТекущееОграничение);

		КонецЕсли;

		Если НужноДобавлять Тогда
			МассивТекстЗапроса.Добавить(Спец_РаботаСБазойДанныхНапрямую.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(ТекстЗапроса, Кэш));
		КонецЕсли;

	КонецЦикла;

	Для Каждого СтрокаЛишнееОграничение Из ТаблицаТекущихОграничений Цикл

		ТекстЗапросаДляУдаления = СтрШаблон("ALTER TABLE IF EXISTS public.%1 DROP CONSTRAINT IF EXISTS %2",
											НаименованиеВPostgreSQL,
											СтрокаЛишнееОграничение.ИмяОграничения);

		МассивТекстЗапроса.Вставить(0, ТекстЗапросаДляУдаления);

	КонецЦикла;

	Если МассивТекстЗапроса.Количество() > 0 Тогда

		ГотовыйТекстЗапроса = Спец_РаботаСБазойДанныхНапрямую.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(СтрСоединить(МассивТекстЗапроса,
																													Спец_КонстантыКлиентСервер.РазделительЗапросовВPostgreSQL()), Кэш);

		ТекстОшибки = "";
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ГотовыйТекстЗапроса, ТекстОшибки, Кэш);
		Если Не Успешно Тогда
			
			// Проверяем, что ошибка не на табличное пространство
			МассивДляУдаления = Новый Массив(); // Массив из Строка
			МассивОчищенныйТекстЗапроса = СтрРазделить(ГотовыйТекстЗапроса, Символы.ПС);
			
			Для Каждого СтрокаДляПроверки Из МассивОчищенныйТекстЗапроса Цикл
				
				Если СтрНачинаетсяС(СокрЛ(СтрокаДляПроверки), "USING INDEX TABLESPACE ") Тогда
					МассивДляУдаления.Добавить(СтрокаДляПроверки);
				КонецЕсли;
				
			КонецЦикла; 
			
			Спец_Проверить(МассивДляУдаления.Количество() > 0,
					ТекстОшибки,
					"Спец_PostgreSQL.ОбработатьСтруктуруДляИндексации: " + СтруктураДляОбновления.ПолноеИмяМетаданных);
			
			Для Каждого СтрокаДляУдаления Из МассивДляУдаления Цикл
				Спец_РаботаСКоллекциямиКлиентСервер.УдалитьЗначениеИзМассива(МассивОчищенныйТекстЗапроса, СтрокаДляУдаления);
			КонецЦикла;
			
			ГотовыйТекстЗапроса = СтрСоединить(МассивОчищенныйТекстЗапроса, Символы.ПС);
			
			ТекстОшибки = "";
			Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ГотовыйТекстЗапроса, ТекстОшибки, Кэш),
					ТекстОшибки,
					"Спец_PostgreSQL.ОбработатьСтруктуруДляИндексации: " + СтруктураДляОбновления.ПолноеИмяМетаданных);
			
		КонецЕсли;
		
		НужноОбновление = Истина;

	КонецЕсли;

#КонецОбласти

#Область Триггеры

	МассивТекстЗапроса = Новый Массив(); // Массив из Строка

	ТаблицаТекущихТриггеров = ПолучитьТаблицуТекущихТриггеров(СсылкаНаТаблицуДляОбновления);
	Для Каждого СтрокаТриггер Из ТаблицаТекущихТриггеров Цикл

		СтрокаТриггер.ФункцияТриггера = ВРег(СокрЛП(СтрокаТриггер.ФункцияТриггера));
		СтрокаТриггер.ИмяТриггера     = ВРег(СокрЛП(СтрокаТриггер.ИмяТриггера));

	КонецЦикла;
	ТаблицаТекущихТриггеров.Индексы.Добавить("ИмяТриггера");

	Для Каждого КлючЗначение Из СтруктураДляОбновления.СоответствиеТриггеров Цикл

		НовыйКлюч     = Спец_РаботаСБазойДанныхНапрямую.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(КлючЗначение.Ключ, Кэш);
		ТекстТриггера = Спец_РаботаСБазойДанныхНапрямую.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(КлючЗначение.Значение, Кэш);

		НужноДобавлять = Ложь;

		СтрокаТекущийТриггер = ТаблицаТекущихТриггеров.Найти(ВРег(НовыйКлюч), "ИмяТриггера");
		Если СтрокаТекущийТриггер = Неопределено Тогда

			НужноДобавлять = Истина;

		Иначе

			Если СтрНайти(ВРег(ТекстТриггера), СтрокаТекущийТриггер.ФункцияТриггера) = 0 Тогда

				НужноДобавлять = Истина;
				МассивТекстЗапроса.Вставить(0, "DROP TRIGGER IF EXISTS " + НовыйКлюч + " ON public." + НаименованиеВPostgreSQL + " CASCADE");

			КонецЕсли;

			ТаблицаТекущихТриггеров.Удалить(СтрокаТекущийТриггер);

		КонецЕсли;

		Если НужноДобавлять Тогда
			МассивТекстЗапроса.Добавить(ТекстТриггера);
		КонецЕсли;

	КонецЦикла;

	Для Каждого СтрокаЛишнийТриггер Из ТаблицаТекущихТриггеров Цикл
		МассивТекстЗапроса.Вставить(0, "DROP TRIGGER IF EXISTS " + СтрокаЛишнийТриггер.ИмяТриггера + " ON public." + НаименованиеВPostgreSQL + " CASCADE");
	КонецЦикла;

	Если МассивТекстЗапроса.Количество() > 0 Тогда

		ГотовыйТекстЗапроса = Спец_РаботаСБазойДанныхНапрямую.ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(СтрСоединить(МассивТекстЗапроса,
																							Спец_КонстантыКлиентСервер.РазделительЗапросовВPostgreSQL()), Кэш);

		ТекстОшибки = "";
		
		Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ГотовыйТекстЗапроса, ТекстОшибки, Кэш),
				ТекстОшибки,
				"Спец_PostgreSQL.ОбработатьСтруктуруДляИндексации");
		
		НужноОбновление = Истина;

	КонецЕсли;

#КонецОбласти

	Возврат НужноОбновление;

КонецФункции

// Параметры:
//	СсылкаНаТаблицу - СправочникСсылка.Спец_СтруктураТаблицБазыДанных
// 
// Возвращаемое значение:
//	Структура:
//		* ПроцентЗаполнения - Число
//		* ТабличноеПространство - Строка
//
Функция ПолучитьТекущиеПараметрыТаблицыВPostgreSQL(Знач СсылкаНаТаблицу)

	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	СтруктураТаблицБазыДанных.ПроцентЗаполнения КАК ПроцентЗаполнения,
	|	СтруктураТаблицБазыДанных.ТабличноеПространство КАК ТабличноеПространство
	|ИЗ
	|	Справочник.Спец_СтруктураТаблицБазыДанных КАК СтруктураТаблицБазыДанных
	|ГДЕ
	|	СтруктураТаблицБазыДанных.Ссылка = &СсылкаНаТаблицу";

	Запрос.УстановитьПараметр("СсылкаНаТаблицу", СсылкаНаТаблицу);

	//@skip-check constructor-function-return-section
	Возврат Спец_ОбщегоНазначения.ПолучитьСтруктуруПервойВыборкиЗапроса(Запрос);

КонецФункции

// Параметры:
//	СсылкаНаТаблицу - СправочникСсылка.Спец_СтруктураТаблицБазыДанных
// 
// Возвращаемое значение:
//	ТаблицаЗначений:
//		* ИмяИндекса - Строка
//		* Столбцы - Строка
//		* Уникальный - Булево
//		* Кластеризован - Булево
//		* ТабличноеПространство - Строка
//		* ПараметрыХранения - Строка
//
Функция ПолучитьТаблицуТекущихИндексов(Знач СсылкаНаТаблицу)

	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СтруктураТаблицБазыДанныхИндексы.ИмяИндекса КАК ИмяИндекса,
	|	СтруктураТаблицБазыДанныхИндексы.Столбцы КАК Столбцы,
	|	СтруктураТаблицБазыДанныхИндексы.Уникальный КАК Уникальный,
	|	СтруктураТаблицБазыДанныхИндексы.Кластеризован КАК Кластеризован,
	|	СтруктураТаблицБазыДанныхИндексы.ТабличноеПространство КАК ТабличноеПространство,
	|	СтруктураТаблицБазыДанныхИндексы.ПараметрыХранения КАК ПараметрыХранения
	|ИЗ
	|	Справочник.Спец_СтруктураТаблицБазыДанных.Индексы КАК СтруктураТаблицБазыДанныхИндексы
	|ГДЕ
	|	СтруктураТаблицБазыДанныхИндексы.Ссылка = &СсылкаНаТаблицу";

	Запрос.УстановитьПараметр("СсылкаНаТаблицу", СсылкаНаТаблицу);
	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции

// Параметры:
//	СсылкаНаТаблицу - СправочникСсылка.Спец_СтруктураТаблицБазыДанных
// 
// Возвращаемое значение:
//	ТаблицаЗначений:
//		* ИмяОграничения - Строка
//		* Столбцы - Строка
//		* ТабличноеПространство - Строка
//		* ПараметрыХранения - Строка
//		* Кластеризован - Булево
//
Функция ПолучитьТаблицуТекущихОграничений(Знач СсылкаНаТаблицу)

	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СтруктураТаблицБазыДанныхОграничения.ИмяОграничения КАК ИмяОграничения,
	|	СтруктураТаблицБазыДанныхОграничения.Столбцы КАК Столбцы,
	|	СтруктураТаблицБазыДанныхОграничения.ТабличноеПространство КАК ТабличноеПространство,
	|	СтруктураТаблицБазыДанныхОграничения.ПараметрыХранения КАК ПараметрыХранения,
	|	СтруктураТаблицБазыДанныхОграничения.Кластеризован КАК Кластеризован
	|ИЗ
	|	Справочник.Спец_СтруктураТаблицБазыДанных.Ограничения КАК СтруктураТаблицБазыДанныхОграничения
	|ГДЕ
	|	СтруктураТаблицБазыДанныхОграничения.Ссылка = &СсылкаНаТаблицу";

	Запрос.УстановитьПараметр("СсылкаНаТаблицу", СсылкаНаТаблицу);
	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции

// Параметры:
//	СсылкаНаТаблицу - СправочникСсылка.Спец_СтруктураТаблицБазыДанных
// 
// Возвращаемое значение:
//  ТаблицаЗначений:
//		* ИмяТриггера - Строка
//		* ФункцияТриггера - Строка
//
Функция ПолучитьТаблицуТекущихТриггеров(Знач СсылкаНаТаблицу)

	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СтруктураТаблицБазыДанныхТриггеры.ИмяТриггера КАК ИмяТриггера,
	|	СтруктураТаблицБазыДанныхТриггеры.ФункцияТриггера КАК ФункцияТриггера
	|ИЗ
	|	Справочник.Спец_СтруктураТаблицБазыДанных.Триггеры КАК СтруктураТаблицБазыДанныхТриггеры
	|ГДЕ
	|	СтруктураТаблицБазыДанныхТриггеры.Ссылка = &СсылкаНаТаблицу";

	Запрос.УстановитьПараметр("СсылкаНаТаблицу", СсылкаНаТаблицу);
	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции

#КонецОбласти

#Область КластеризацияОчисткаВсехТаблиц

// Параметры:
//	ИдентификаторЗадания - Строка
//	ТекстСообщений - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура КластеризацияОчисткаВсехТаблицVACUUM(Знач ИдентификаторЗадания, ТекстСообщений, Знач Кэш)

	ТекущийДеньНедели = ДеньНедели(ТекущаяДатаСеанса());
	Если ТекущийДеньНедели = 6 Или ТекущийДеньНедели = 7 Тогда // FULL VACUUM лучше запускать только по выходным (блокирует таблицу, может надолго зависнуть)
		ШаблонСкрипта = "VACUUM (FULL, ANALYZE) %1;";
	Иначе
		ШаблонСкрипта = "VACUUM (ANALYZE) %1;";
	КонецЕсли;

	ВыборкаРезультат = ПолучитьТаблицыДляVACUUM();
	ВсегоТаблиц      = ВыборкаРезультат.Количество();
	ТекущаяТаблица   = 0;

	Пока ВыборкаРезультат.Следующий() Цикл
		
		Скрипт               = СтрШаблон(ШаблонСкрипта, ВыборкаРезультат.ИмяТаблицыХранения);
		ТекущаяТаблица       = ТекущаяТаблица + 1;
		ТекстОшибки          = "";
		ИдентификаторЗапроса = "VACUUM_" + ВыборкаРезультат.ИмяТаблицыХранения;

		Спец_ЗаписатьЛог("Кластеризация / очистка всех таблиц (PostgreSQL)", Перечисления.Спец_УровниЛогирования.Информация, Скрипт);
		Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания(Скрипт, ИдентификаторЗадания, (ТекущаяТаблица / ВсегоТаблиц) * 100);

		Спец_КомпонентаДополнительныеФункцииКлиентСервер.НачатьЗамер(ИдентификаторЗапроса, Кэш);
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(Скрипт, ТекстОшибки, Кэш);
		ВремяВыполнения = Спец_КомпонентаДополнительныеФункцииКлиентСервер.ЗавершитьЗамер(ИдентификаторЗапроса, Кэш);

		Если Не Успешно Тогда

			МассивТекстСообщения = Новый Массив(); // Массив из Строка
			МассивТекстСообщения.Добавить("------ " + Скрипт + " ------");
			МассивТекстСообщения.Добавить(Символы.Таб + ТекстОшибки);

			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(СтрСоединить(МассивТекстСообщения, Символы.ПС),
															 "Кластеризация / очистка всех таблиц (PostgreSQL) (VACUUM)",
															 ТекстСообщений);

		Иначе

			СправочникОбъект = Спец_ОбщегоНазначения.ПолучитьОбъектСБлокированием(ВыборкаРезультат.Ссылка, Кэш, ТекстСообщений);
			Если СправочникОбъект = Неопределено Тогда
				Продолжить;
			КонецЕсли;

			СправочникОбъект.ДатаПоследнейОчистки  = ТекущаяДатаСеанса();
			СправочникОбъект.ВремяПоследнейОчистки = ВремяВыполнения;

			Спец_ОбщегоНазначения.ЗаписатьОбъект(СправочникОбъект, , ТекстСообщений, , Кэш);

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// Параметры:
//	ИдентификаторЗадания - Строка
//	ТекстСообщений - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура КластеризацияОчисткаВсехТаблицCLUSTER(Знач ИдентификаторЗадания, ТекстСообщений, Знач Кэш)

	ТекущийМесяц = НачалоМесяца(ТекущаяДатаСеанса());

	ДатаПоследнейКластеризации = Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ДатаПоследнейКластеризации, Дата(1, 1, 1)); // Дата
	Если НачалоМесяца(ДатаПоследнейКластеризации) >= ТекущийМесяц Тогда
		Возврат;
	КонецЕсли;
	
	// Запускаем только по выходным
	ТекущийДеньНедели = ДеньНедели(ТекущаяДатаСеанса());
	Если ТекущийДеньНедели <> 6 И ТекущийДеньНедели <> 7 Тогда
		Возврат;
	КонецЕсли;

	Скрипт = "CLUSTER;";
	
	Спец_ЗаписатьЛог("Кластеризация / очистка всех таблиц (PostgreSQL)", Перечисления.Спец_УровниЛогирования.Информация, Скрипт);
	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания(Скрипт, ИдентификаторЗадания, 1);
	
	ТекстОшибки = "";
	Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(Скрипт, ТекстОшибки, Кэш);

	Если Не Успешно Тогда

		МассивТекстСообщения = Новый Массив(); // Массив из Строка
		МассивТекстСообщения.Добавить("------ " + Скрипт + " ------");
		МассивТекстСообщения.Добавить(Символы.Таб + ТекстОшибки);

		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(СтрСоединить(МассивТекстСообщения, Символы.ПС),
														 "Кластеризация / очистка всех таблиц (PostgreSQL) (CLUSTER)",
														 ТекстСообщений);

	КонецЕсли;

	Спец_УстановитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ДатаПоследнейКластеризации, ТекущийМесяц);

КонецПроцедуры

// Параметры:
//	ИдентификаторЗадания - Строка
//	ТекстСообщений - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура КластеризацияОчисткаВсехТаблицREINDEX(Знач ИдентификаторЗадания, ТекстСообщений, Знач Кэш)

	ТекущийМесяц = НачалоМесяца(ТекущаяДатаСеанса());

	ДатаПоследнейРеиндексации = Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ДатаПоследнейРеиндексации, Дата(1, 1, 1)); // Дата
	Если НачалоМесяца(ДатаПоследнейРеиндексации) >= ТекущийМесяц Тогда
		Возврат;
	КонецЕсли;
	
	// Запускаем только по выходным
	ТекущийДеньНедели = ДеньНедели(ТекущаяДатаСеанса());
	Если ТекущийДеньНедели <> 6 И ТекущийДеньНедели <> 7 Тогда
		Возврат;
	КонецЕсли;

	Если Не Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLСоединениеУспешноУстановлено(Кэш) Тогда
		Возврат;
	КонецЕсли;
	
	// DATABASE
	Скрипт = СтрШаблон("REINDEX DATABASE ""%1""", Кэш.КомпонентаPostgreSQL.НаименованиеБазы);
	
	Спец_ЗаписатьЛог("Кластеризация / очистка всех таблиц (PostgreSQL)", Перечисления.Спец_УровниЛогирования.Информация, Скрипт);
	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания(Скрипт, ИдентификаторЗадания, 1);

	ТекстОшибки = "";
	Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(Скрипт, ТекстОшибки, Кэш);
	Если Не Успешно Тогда

		МассивТекстСообщения = Новый Массив(); // Массив из Строка
		МассивТекстСообщения.Добавить("------ " + Скрипт + " ------");
		МассивТекстСообщения.Добавить(Символы.Таб + ТекстОшибки);

		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(СтрСоединить(МассивТекстСообщения, Символы.ПС),
														 "Кластеризация / очистка всех таблиц (PostgreSQL) (REINDEX)",
														 ТекстСообщений);

	КонецЕсли;
	
	// При автоматическом запуске прерываем выполнение
	Если ПустаяСтрока(ИдентификаторЗадания) И Спец_ОбщегоНазначенияКлиентСервер.ИдетРабочийДень() Тогда
		Возврат;
	КонецЕсли;
	
	// SYSTEM
	Скрипт = СтрШаблон("REINDEX SYSTEM ""%1""", Кэш.КомпонентаPostgreSQL.НаименованиеБазы);
	
	Спец_ЗаписатьЛог("Кластеризация / очистка всех таблиц (PostgreSQL)", Перечисления.Спец_УровниЛогирования.Информация, Скрипт);
	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания(Скрипт, ИдентификаторЗадания, 30);

	ТекстОшибки = "";
	Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(Скрипт, ТекстОшибки, Кэш);
	Если Не Успешно Тогда

		МассивТекстСообщения = Новый Массив(); // Массив из Строка
		МассивТекстСообщения.Добавить("------ " + Скрипт + " ------");
		МассивТекстСообщения.Добавить(Символы.Таб + ТекстОшибки);

		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(СтрСоединить(МассивТекстСообщения, Символы.ПС),
														 "Кластеризация / очистка всех таблиц (PostgreSQL) (REINDEX SYSTEM)",
														 ТекстСообщений);

	КонецЕсли;

	Спец_УстановитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ДатаПоследнейРеиндексации, ТекущийМесяц);

КонецПроцедуры

// Параметры:
//	ИдентификаторЗадания - Строка
//	ТекстСообщений - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура КластеризацияОчисткаВсехТаблицСбросСтатистики(Знач ИдентификаторЗадания, ТекстСообщений, Знач Кэш)

	ТекущийКвартал = НачалоКвартала(ТекущаяДатаСеанса());

	ДатаСбросаСтатистики = Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ДатаСбросаСтатистики, Дата(1, 1, 1)); // Дата
	Если НачалоКвартала(ДатаСбросаСтатистики) >= ТекущийКвартал Тогда
		Возврат;
	КонецЕсли;
	
	Спец_ЗаписатьЛог("Кластеризация / очистка всех таблиц (PostgreSQL)", Перечисления.Спец_УровниЛогирования.Информация, "Сброс статистики");
	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания("Сброс статистики", ИдентификаторЗадания, 90);

	ВыборкаРезультат = ПолучитьТаблицыДляСбросаЧастыхОбращений();
	Пока ВыборкаРезультат.Следующий() Цикл

		СправочникОбъект = Спец_ОбщегоНазначения.ПолучитьОбъектСБлокированием(ВыборкаРезультат.Ссылка, Кэш, ТекстСообщений);
		Если СправочникОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		СправочникОбъект.ЧастыеОбращения = Ложь;
		Спец_ОбщегоНазначения.ЗаписатьОбъект(СправочникОбъект, , ТекстСообщений, , Кэш);

	КонецЦикла;

	КоличествоТаблиц = Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.КоличествоТаблицИзЧастоИспользуемыхВКэш, 0); // Число
	Если КоличествоТаблиц = 0 Тогда
		Возврат;
	КонецЕсли;

	МассивКолонок = ПолучитьМассивИменЧастоИспользуемыхТаблицPostgreSQL(КоличествоТаблиц, ТекстСообщений, Кэш);
	Если МассивКолонок = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Для Каждого ИмяТаблицы Из МассивКолонок Цикл

		СправочникЭлемент = Справочники.Спец_СтруктураТаблицБазыДанных.НайтиПоНаименованию(ИмяТаблицы, Истина);
		Если Не ЗначениеЗаполнено(СправочникЭлемент) Тогда
			Продолжить;
		КонецЕсли;

		СправочникОбъект = Спец_ОбщегоНазначения.ПолучитьОбъектСБлокированием(СправочникЭлемент, Кэш, ТекстСообщений);
		Если СправочникОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		СправочникОбъект.ЧастыеОбращения = Истина;
		Спец_ОбщегоНазначения.ЗаписатьОбъект(СправочникОбъект, , ТекстСообщений, , Кэш);

	КонецЦикла;

	ТекстЗапроса = "SELECT pg_stat_reset()";
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);

	Спец_УстановитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ДатаСбросаСтатистики, ТекущийКвартал);

КонецПроцедуры

// Возвращаемое значение:
//	ВыборкаИзРезультатаЗапроса:
//		* Ссылка - СправочникСсылка.Спец_СтруктураТаблицБазыДанных
//		* ИмяТаблицыХранения - Строка
//
Функция ПолучитьТаблицыДляVACUUM()

	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ТаблицаРезультат.Ссылка КАК Ссылка,
	|	ТаблицаРезультат.ИмяТаблицыХранения КАК ИмяТаблицыХранения
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		СтруктураТаблицPostgreSQL.Ссылка КАК Ссылка,
	|		СтруктураТаблицPostgreSQL.Наименование КАК ИмяТаблицыХранения,
	|		НАЧАЛОПЕРИОДА(СтруктураТаблицPostgreSQL.ДатаПоследнейОчистки, ДЕНЬ) КАК ДеньПоследнейОчистки,
	|		СтруктураТаблицPostgreSQL.ОбщийРазмерТаблицы КАК ОбщийРазмерТаблицы
	|	ИЗ
	|		Справочник.Спец_СтруктураТаблицБазыДанных КАК СтруктураТаблицPostgreSQL
	|	ГДЕ
	|		НЕ СтруктураТаблицPostgreSQL.ПометкаУдаления) КАК ТаблицаРезультат
	|
	|УПОРЯДОЧИТЬ ПО
	|	ТаблицаРезультат.ДеньПоследнейОчистки,
	|	ТаблицаРезультат.ОбщийРазмерТаблицы УБЫВ
	|АВТОУПОРЯДОЧИВАНИЕ";

	Возврат Запрос.Выполнить().Выбрать();

КонецФункции

// Возвращаемое значение:
//	ВыборкаИзРезультатаЗапроса:
//		* Ссылка - СправочникСсылка.Спец_СтруктураТаблицБазыДанных
//
Функция ПолучитьТаблицыДляСбросаЧастыхОбращений()

	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	СтруктураТаблицPostgreSQL.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.Спец_СтруктураТаблицБазыДанных КАК СтруктураТаблицPostgreSQL
	|ГДЕ
	|	СтруктураТаблицPostgreSQL.ЧастыеОбращения
	|	И НЕ СтруктураТаблицPostgreSQL.ПометкаУдаления";

	Возврат Запрос.Выполнить().Выбрать();

КонецФункции

// Параметры:
//	КоличествоТаблиц - Число
//	ТекстыОшибок - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Массив из Строка
//
Функция ПолучитьМассивИменЧастоИспользуемыхТаблицPostgreSQL(Знач КоличествоТаблиц, Знач ТекстыОшибок, Знач Кэш)

	ТекстЗапроса = "SELECT relname
				   |FROM pg_stat_user_tables
				   |WHERE schemaname='public'
				   |ORDER BY
				   |	CASE WHEN seq_scan IS null
				   |		THEN 0
				   |		ELSE seq_scan
				   |	END +
				   |	CASE WHEN idx_scan IS null
				   |		THEN 0
				   |		ELSE idx_scan
				   |	END
				   |DESC LIMIT " + Формат(КоличествоТаблиц, "ЧН=0; ЧГ=");

	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Если Не СтруктураРезультат.Успешно Тогда

		МассивТекстСообщения = Новый Массив(); // Массив из Строка
		МассивТекстСообщения.Добавить("------ Запрос по статистике ------");
		МассивТекстСообщения.Добавить(Символы.Таб + СтруктураРезультат.ТекстОшибки);

		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(СтрСоединить(МассивТекстСообщения, Символы.ПС),
														 "Кластеризация / очистка всех таблиц (PostrgeSQL) (Сброс статистики)",
														 ТекстыОшибок);

		Возврат Новый Массив();

	Иначе

		Возврат Спец_РаботаСКоллекциямиКлиентСервер.ВыгрузитьМассивЗначений(СтруктураРезультат.РезультатЗапроса, "relname");

	КонецЕсли;

КонецФункции

#КонецОбласти

// Параметры:
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Массив из Строка
//
Функция ПолучитьМассивСуществующихКластеров(Знач Кэш)

	ТекстЗапроса =
	"SELECT DISTINCT
	|	i.relname AS name
	|FROM
	|	pg_index AS idx
	|		JOIN pg_class AS i
	|		ON i.oid = idx.indexrelid
	|WHERE
	|	idx.indisclustered";

	РезультатВыполненияЗапроса = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Возврат Спец_РаботаСКоллекциямиКлиентСервер.ВыгрузитьМассивЗначений(РезультатВыполненияЗапроса.РезультатЗапроса, "name");

КонецФункции

// Параметры:
//	Кэш см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Массив из Строка
//
Функция ПолучитьМассивСуществующихКонстрейнтов(Знач Кэш)
	
	ТекстЗапроса =
	"SELECT DISTINCT
	|	tc.constraint_name AS name
	|FROM
	|	information_schema.table_constraints AS tc
	|WHERE
	|	tc.table_schema = 'public'
	|	AND tc.constraint_name <> ''
	|	AND NOT upper(tc.constraint_name) LIKE '%NULL%'";

	СтруктураРезультатЗапроса = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	МассивКонстрейнтовПодготовка = Спец_РаботаСКоллекциямиКлиентСервер.ВыгрузитьМассивЗначений(СтруктураРезультатЗапроса.РезультатЗапроса, "name"); // Массив из Строка

	Если МассивКонстрейнтовПодготовка.Количество() = 0 Тогда
		Возврат Новый Массив();
	КонецЕсли;

	МассивКонстрейнтовГотовые = Новый Массив(); // Массив из Строка
	МассивКонстрейнтовГотовыеДляЗапроса = Новый Массив(); // Массив из Строка
	ШаблонКонстрейнтаДляЗапроса = "'%1'";

	Для Каждого ИмяКонстрейнта Из МассивКонстрейнтовПодготовка Цикл

		МассивКонстрейнтовГотовые.Добавить(ИмяКонстрейнта);
		МассивКонстрейнтовГотовыеДляЗапроса.Добавить(СтрШаблон(ШаблонКонстрейнтаДляЗапроса, ИмяКонстрейнта));

	КонецЦикла;
	
	// Проставим FILLFACTOR по умолчанию
	МассивСтруктурДляУстановки = ПолучитьКонстрейнтыДляУстановкиFillFactor(МассивКонстрейнтовГотовыеДляЗапроса, Кэш);
	ШаблонСкрипта = "ALTER TABLE %1 DROP CONSTRAINT %2; 
					|ALTER TABLE %1 ADD CONSTRAINT %2 %3 WITH (fillfactor=92);";

	Для Каждого СтрокаИзПакета Из МассивСтруктурДляУстановки Цикл

		ТекстСкрипта = СтрШаблон(ШаблонСкрипта, СокрЛП(СтрокаИзПакета.tableName), СокрЛП(СтрокаИзПакета.constraintName), СокрЛП(СтрокаИзПакета.constrainText));

		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстСкрипта, , , Кэш);

	КонецЦикла;

	Возврат МассивКонстрейнтовГотовые;

КонецФункции

// Параметры:
//	МассивКонстрейнтовГотовыеДляЗапроса - Массив из Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Массив из Структура:
//		* tableName - Строка
//		* constraintName - Строка
//		* scrypt - Строка
//		* constrainText - Строка
//
Функция ПолучитьКонстрейнтыДляУстановкиFillFactor(Знач МассивКонстрейнтовГотовыеДляЗапроса, Знач Кэш)

	ТекстЗапроса =
	"CREATE TEMPORARY TABLE VT_tableNames ON COMMIT DROP AS
	|SELECT
	|	tc.table_name AS tableName,
	|	tc.constraint_name AS constraintName,
	|	pg_get_indexdef(tc.constraint_name::regclass) AS scrypt
	|FROM
	|	information_schema.table_constraints AS tc
	|WHERE
	|	tc.table_schema = 'public'
	|	AND tc.constraint_name IN (&ИменаКонстрейнтов)
	|;
	|
	|SELECT
	|	tableNames.tableName AS tableName,
	|	tableNames.constraintName AS constraintName,
	|	tableNames.scrypt AS scrypt,
	|	pg_get_constraintdef(c.oid) AS constrainText
	|FROM
	|	pg_class AS t
	|		JOIN pg_constraint AS c
	|		ON c.conrelid = t.oid
	|		JOIN VT_tableNames AS tableNames
	|		ON t.relname = tableNames.tableName
	|WHERE
	|	tableNames.tableName <> ''
	|	AND NOT tableNames.scrypt LIKE '%WITH%'";

	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИменаКонстрейнтов", СтрСоединить(МассивКонстрейнтовГотовыеДляЗапроса, ","));

	СтруктураРезультатЗапроса = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Возврат СтруктураРезультатЗапроса.РезультатЗапроса;

КонецФункции

// Параметры:
//	type - Строка
// 
// Возвращаемое значение:
//	ПеречислениеСсылка.Спец_ТипыДанныхБазыДанных
//
Функция ПолучитьТипДанныхПоДаннымИзPostgreSQL(Знач type)

	ДляРазбора = ВРег(type);
	Если ДляРазбора = "NUMERIC" Или СтрНачинаетсяС(ДляРазбора, "INT") Тогда
		Возврат Перечисления.Спец_ТипыДанныхБазыДанных.Число;
	ИначеЕсли СтрНайти(ДляРазбора, "CHAR") > 0 Тогда
		Возврат Перечисления.Спец_ТипыДанныхБазыДанных.Строка;
	ИначеЕсли ДляРазбора = "TIMESTAMP" Тогда
		Возврат Перечисления.Спец_ТипыДанныхБазыДанных.Дата;
	ИначеЕсли СтрНачинаетсяС(ДляРазбора, "BOOL") Тогда
		Возврат Перечисления.Спец_ТипыДанныхБазыДанных.Булево;
	ИначеЕсли ДляРазбора = "BYTEA" Тогда
		Возврат Перечисления.Спец_ТипыДанныхБазыДанных.Ссылочный;
	Иначе
		Возврат Перечисления.Спец_ТипыДанныхБазыДанных.NULL;
	КонецЕсли;

КонецФункции

// Параметры:
//	СтрокаСтолбец - СтрокаТаблицыЗначений: см. НоваяТаблицаСтолбцы
// 
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьИмяТипаДанныхДляКолонкиПоТипуДанных(Знач СтрокаСтолбец)

	ДляРазбора = ВРег(СтрокаСтолбец.typecolumn);
	Если ДляРазбора = "NUMERIC" Тогда
		Возврат СтрШаблон("numeric(%1, %2)", Формат(СтрокаСтолбец.columnPrecision, "ЧДЦ=0; ЧН=0; ЧГ="), Формат(СтрокаСтолбец.columnScale, "ЧДЦ=0; ЧН=0; ЧГ="));
	ИначеЕсли ДляРазбора = "BYTEA" Тогда
		Возврат "text";
	Иначе
		Возврат СтрокаСтолбец.typecolumn;
	КонецЕсли;

КонецФункции

// Параметры:
//	type - Строка
// 
// Возвращаемое значение:
//	ПеречислениеСсылка.Спец_PostgreSQLТипыИндексов
//
Функция ПолучитьТипИндексаПоДаннымИзPostgreSQL(Знач type)

	ДляРазбора = ВРег(type);
	Если ДляРазбора = "BTREE" Тогда
		Возврат Перечисления.Спец_PostgreSQLТипыИндексов.btree;
	ИначеЕсли ДляРазбора = "HEAP" Тогда
		Возврат Перечисления.Спец_PostgreSQLТипыИндексов.heap;
	ИначеЕсли ДляРазбора = "HASH" Тогда
		Возврат Перечисления.Спец_PostgreSQLТипыИндексов.hash;
	ИначеЕсли ДляРазбора = "GIST" Тогда
		Возврат Перечисления.Спец_PostgreSQLТипыИндексов.gist;
	ИначеЕсли ДляРазбора = "GIN" Тогда
		Возврат Перечисления.Спец_PostgreSQLТипыИндексов.gin;
	ИначеЕсли ДляРазбора = "SPGIST" Тогда
		Возврат Перечисления.Спец_PostgreSQLТипыИндексов.spgist;
	ИначеЕсли ДляРазбора = "BRIN" Тогда
		Возврат Перечисления.Спец_PostgreSQLТипыИндексов.brin;
	Иначе
		Возврат Перечисления.Спец_PostgreSQLТипыИндексов.ПустаяСсылка();
	КонецЕсли;

КонецФункции

// Параметры:
//	Столбцы - СправочникТабличнаяЧасть.Спец_СтруктураТаблицБазыДанных.Столбцы
//	columnsIndex - Строка
//	keyAtts - Число
// 
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьИменаСтолбцовДляИндекса(Знач Столбцы, Знач columnsIndex, Знач keyAtts)

	МассивИменаСтолбцов = Новый Массив(); // Массив из Строка

	МассивИндексов = СтрРазделить(columnsIndex, " ", Ложь);
	Для i = 1 По Мин(МассивИндексов.Количество(), keyAtts) Цикл

		НомерСтолбца = Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(МассивИндексов.Получить(i - 1));
		Если НомерСтолбца > 0 И Столбцы.Количество() + 1 > НомерСтолбца Тогда
			МассивИменаСтолбцов.Добавить(Столбцы[НомерСтолбца - 1].ИмяСтолбца);
		Иначе
			МассивИменаСтолбцов.Добавить("<не распознал>");
		КонецЕсли;

	КонецЦикла;

	Возврат СтрСоединить(МассивИменаСтолбцов, ",");

КонецФункции

// Параметры:
//	Столбцы - СправочникТабличнаяЧасть.Спец_СтруктураТаблицБазыДанных.Столбцы
//	columnsIndex - Строка
//	keyAtts - Число
// 
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьИменаНеключевыхСтолбцовДляИндекса(Знач Столбцы, Знач columnsIndex, Знач keyAtts)

	МассивИндексов = СтрРазделить(columnsIndex, " ", Ложь);
	Если МассивИндексов.Количество() <= keyAtts Тогда
		Возврат "";
	КонецЕсли;

	МассивИменаСтолбцов = Новый Массив(); // Массив из Строка
	Для i = keyAtts По МассивИндексов.Количество() Цикл
		МассивИменаСтолбцов.Добавить(Столбцы[i - 1].ИмяСтолбца);
	КонецЦикла;

	Возврат СтрСоединить(МассивИменаСтолбцов, ",");

КонецФункции

// Параметры:
//	НоваяСтрокаСтолбец - СправочникТабличнаяЧастьСтрока.Спец_СтруктураТаблицБазыДанных.Столбцы
//	МетаданныеПоля - ОбъектМетаданныхРеквизит, ОписаниеСтандартногоРеквизита -
//
Процедура УстановитьИмяТипаДанныхПоМетаданнымПоля(Знач НоваяСтрокаСтолбец, Знач МетаданныеПоля)

	Если МетаданныеПоля = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ОписаниеТипов = Неопределено;
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(МетаданныеПоля, "Тип") Тогда
		ОписаниеТипов = МетаданныеПоля.Тип;
	КонецЕсли;

	ВсеТипы = ?(ОписаниеТипов = Неопределено, Новый Массив(), ОписаниеТипов.Типы());
	Если ЗначениеЗаполнено(НоваяСтрокаСтолбец.ТипСоставногоПоля) Тогда

		Если НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.Число И ОписаниеТипов.КвалификаторыЧисла.Разрядность > 0 Тогда

			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = ?(ОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти > 0,
															  СтрШаблон("numeric(%1, %2)",
																		Формат(ОписаниеТипов.КвалификаторыЧисла.Разрядность, "ЧДЦ=0; ЧН=0; ЧГ="),
																		Формат(ОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти, "ЧДЦ=0; ЧН=0; ЧГ=")),
															  СтрШаблон("numeric(%1)", Формат(ОписаниеТипов.КвалификаторыЧисла.Разрядность,
																							  "ЧДЦ=0; ЧН=0; ЧГ=")));

		ИначеЕсли НоваяСтрокаСтолбец.ТипСоставногоПоля = Перечисления.Спец_ТипыСоставныхПолейБазыДанных.Строка И ОписаниеТипов.КвалификаторыСтроки.Длина > 0 Тогда

			Если ОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная Тогда

				НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = СтрШаблон("mvarchar(%1)", Формат(ОписаниеТипов.КвалификаторыСтроки.Длина, "ЧДЦ=0; ЧН=0; ЧГ="));

			ИначеЕсли ОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда

				НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = СтрШаблон("mchar(%1)", Формат(ОписаниеТипов.КвалификаторыСтроки.Длина, "ЧДЦ=0; ЧН=0; ЧГ="));

			КонецЕсли;

		КонецЕсли;

	ИначеЕсли ВсеТипы.Количество() = 1 Тогда

		НулевойТип = ВсеТипы.Получить(0);
		Если НулевойТип = Тип("Строка") И ОписаниеТипов.КвалификаторыСтроки.Длина > 0 Тогда

			Если ОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная Тогда

				НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = СтрШаблон("mvarchar(%1)", Формат(ОписаниеТипов.КвалификаторыСтроки.Длина, "ЧДЦ=0; ЧН=0; ЧГ="));

			ИначеЕсли ОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда

				НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = СтрШаблон("mchar(%1)", Формат(ОписаниеТипов.КвалификаторыСтроки.Длина, "ЧДЦ=0; ЧН=0; ЧГ="));

			КонецЕсли;

		ИначеЕсли НулевойТип = Тип("Число") И ОписаниеТипов.КвалификаторыЧисла.Разрядность > 0 Тогда

			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = ?(ОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти > 0,
															  СтрШаблон("numeric(%1, %2)",
																		Формат(ОписаниеТипов.КвалификаторыЧисла.Разрядность, "ЧДЦ=0; ЧН=0; ЧГ="),
																		Формат(ОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти, "ЧДЦ=0; ЧН=0; ЧГ=")),
															  СтрШаблон("numeric(%1)", Формат(ОписаниеТипов.КвалификаторыЧисла.Разрядность,
																							  "ЧДЦ=0; ЧН=0; ЧГ=")));

		ИначеЕсли НулевойТип = Тип("ХранилищеЗначения") Или НулевойТип = Тип("ДвоичныеДанные") Тогда

			НоваяСтрокаСтолбец.ФункцияПреобразования = "lykov_DDToBytea(%1)";
			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = "text";

		ИначеЕсли НулевойТип = Тип("УникальныйИдентификатор") Тогда

			НоваяСтрокаСтолбец.ФункцияПреобразования = "lykov_UIDToRRef(%1)";
			НоваяСтрокаСтолбец.ИмяТипаДанныхДляPostgreSQL = "mvarchar(36)";

		КонецЕсли;

	КонецЕсли;

КонецПроцедуры

// Параметры:
//	ИсходнаяСтрока - Строка
// 
// Возвращаемое значение:
//	Булево
//
Функция УжеЕстьПереопределенияИндекса(Знач ИсходнаяСтрока)

	Возврат СтрНайти(ИсходнаяСтрока, "WITH") > 0
			Или СтрНайти(ИсходнаяСтрока, "WHERE") > 0
			Или СтрНайти(ИсходнаяСтрока, "TABLESPACE") > 0
			Или СтрНайти(ИсходнаяСтрока, "BTREE") = 0;

КонецФункции

// Параметры:
//	МассивИменТаблицСуществует - Массив из Строка
// 
// Возвращаемое значение:
//	ВыборкаИзРезультатаЗапроса:
//		* Ссылка - СправочникСсылка.Спец_СтруктураТаблицБазыДанных
//
Функция ПолучитьВыборкуПоТаблицамДляУдаления(Знач МассивИменТаблицСуществует)

	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СтруктураТаблицPostgreSQL.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.Спец_СтруктураТаблицБазыДанных КАК СтруктураТаблицPostgreSQL
	|ГДЕ
	|	НЕ СтруктураТаблицPostgreSQL.Наименование В (&МассивИменТаблиц)
	|	И НЕ СтруктураТаблицPostgreSQL.ПометкаУдаления";

	Запрос.УстановитьПараметр("МассивИменТаблиц", МассивИменТаблицСуществует);
	Возврат Запрос.Выполнить().Выбрать();

КонецФункции

// Возвращаемое значение:
//	ВыборкаИзРезультатаЗапроса:
//		* ИмяТаблицыХранения - Строка
//
Функция ПолучитьТаблицыДляПомещенияВОпертивнуюПамять()

	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	НаименованияТаблиц.ИмяТаблицыХранения КАК ИмяТаблицыХранения
	|ИЗ
	|	(ВЫБРАТЬ
	|		СтруктураТаблицPostgreSQL.Наименование КАК ИмяТаблицыХранения
	|	ИЗ
	|		Справочник.Спец_СтруктураТаблицБазыДанных КАК СтруктураТаблицPostgreSQL
	|	ГДЕ
	|		СтруктураТаблицPostgreSQL.ЧастыеОбращения
	|		И НЕ СтруктураТаблицPostgreSQL.ПометкаУдаления
	|
	|	ОБЪЕДИНИТЬ ВСЕ
	|
	|	ВЫБРАТЬ
	|		СтруктураТаблицPostgreSQL.Наименование
	|	ИЗ
	|		Справочник.Спец_СтруктураТаблицБазыДанных КАК СтруктураТаблицPostgreSQL
	|	ГДЕ
	|		СтруктураТаблицPostgreSQL.ПринудительноВКэш
	|		И НЕ СтруктураТаблицPostgreSQL.ПометкаУдаления) КАК НаименованияТаблиц";

	Возврат Запрос.Выполнить().Выбрать();

КонецФункции

#Область Типизация

// Параметры:
//	ИсходнаяСтрока - Структура:
//		* name - Строка
//		* scrypt - Строка
// 
// Возвращаемое значение:
//	Структура:
//		* name - Строка
//		* scrypt - Строка
//		* СкриптКластера - Строка
//
Функция НоваяСтруктураСтрокиИндексаДляПерестроения(Знач ИсходнаяСтрока)

	Возврат Новый Структура("name, scrypt, СкриптКластера", ИсходнаяСтрока.name, ИсходнаяСтрока.scrypt, "");

КонецФункции

// Возвращаемое значение:
//	ТаблицаЗначений:
//		* tablename - Строка
//		* tablenameupper - Строка
//		* tablespacetable - Строка 
//		* ownertable - Строка
//		* optionstable - Строка
//		* oidtable - Число
//
Функция НоваяТаблицаИменТаблиц()

	ТаблицаДляВозврата = Новый ТаблицаЗначений();

	ТаблицаДляВозврата.Колонки.Добавить("tablename", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("tablenameupper", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("tablespacetable", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("ownertable", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("optionstable", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("oidtable", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаЧисло(15));

	Возврат ТаблицаДляВозврата;

КонецФункции

// Возвращаемое значение:
//	ТаблицаЗначений:
//		* tablename - Строка
//		* numbercolumn - Число
//		* columnname - Строка
//		* columnupper - Строка
//		* typecolumn - Строка
//		* nullablecolumn - Булево
//		* columnprecision - Число
//		* columnscale - Число
//
Функция НоваяТаблицаСтолбцы()

	ТаблицаДляВозврата = Новый ТаблицаЗначений();

	ТаблицаДляВозврата.Колонки.Добавить("tablename", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("numbercolumn", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаЧисло(15));
	ТаблицаДляВозврата.Колонки.Добавить("columnname", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("columnupper", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("typecolumn", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("nullablecolumn", Новый ОписаниеТипов("Булево"));
	ТаблицаДляВозврата.Колонки.Добавить("columnprecision", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаЧисло(15));
	ТаблицаДляВозврата.Колонки.Добавить("columnscale", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаЧисло(15));

	ТаблицаДляВозврата.Индексы.Добавить("tableName");

	Возврат ТаблицаДляВозврата;

КонецФункции
	
// Возвращаемое значение:
//	ТаблицаЗначений:
//		* tablename - Строка
//		* indexname - Строка
//		* itsconstraint - Булево
//		* typeindex - Строка
//		* keyatts - Число
//		* columnsindex - Строка
//		* uniqueindex - Булево
//		* clustered - Булево
//		* tablespacetable - Строка
//		* predicat - Строка
//		* optionstable - Строка
//
Функция НоваяТаблицаИндексы()

	ТаблицаДляВозврата = Новый ТаблицаЗначений();

	ТаблицаДляВозврата.Колонки.Добавить("tablename", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("indexname", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("itsconstraint", Новый ОписаниеТипов("Булево"));
	ТаблицаДляВозврата.Колонки.Добавить("typeindex", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("keyatts", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаЧисло(15));
	ТаблицаДляВозврата.Колонки.Добавить("columnsindex", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("uniqueindex", Новый ОписаниеТипов("Булево"));
	ТаблицаДляВозврата.Колонки.Добавить("clustered", Новый ОписаниеТипов("Булево"));
	ТаблицаДляВозврата.Колонки.Добавить("tablespacetable", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("predicat", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("optionstable", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока());

	ТаблицаДляВозврата.Индексы.Добавить("tableName");

	Возврат ТаблицаДляВозврата;

КонецФункции

// Возвращаемое значение:
//	ТаблицаЗначений:
//		* tablename - Строка
//		* triggername - Строка
//		* functioncode - Строка
//
Функция НоваяТаблицаТриггеры()

	ТаблицаДляВозврата = Новый ТаблицаЗначений();

	ТаблицаДляВозврата.Колонки.Добавить("tablename", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("triggername", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024));
	ТаблицаДляВозврата.Колонки.Добавить("functioncode", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока());

	ТаблицаДляВозврата.Индексы.Добавить("tableName");

	Возврат ТаблицаДляВозврата;

КонецФункции

#КонецОбласти

#КонецОбласти
