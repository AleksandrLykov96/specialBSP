// @strict-types

#Область ПрограммныйИнтерфейс

// Преобразует параметры в шаблоне текста запроса в имена таблиц в БД.
// Имена параметров должны быть прописаны в квадратных скобках, например, для данного запроса будет выполнено следующее преобразование:
//		"SELECT * FROM [Справочник.Спец_Базы]" -> "SELECT * FROM _reference123"
// Есть возможность преобразования предопределённых параметров в ГУИДы в БД (см ПолучитьГУИДПредопределенногоЭлементаВБазе), для этого нужно написать их полное представление:
// 		"SELECT '[Перечисление.Спец_ВидыБаз.ГлавноеУправление]'" -> "SELECT 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX'" (нужный ГУИД)
// Если у реквизита составной тип, необходимо прописать имя нужного типа (как в перечислении Спец_ТипыСоставныхПолейБазыДанных) в скобках после нужного реквизита:
// 		"SELECT [Справочник.Спец_Базы.СоставнойРеквизит(ИдентификаторСсылки)]" -> "SELECT _fld123_rref"
// Есть возможноть подстановки табличных частей, для этого просто прописываем путь к метаданным нужной табличной части (без слова ТабличнаяЧасть):
// 		"SELECT [Справочник.Спец_Базы.HTTP.Адрес]" -> "SELECT _fld456"
// 		
// Если установлены обмены с другой базой, и это база-отправитель, то можно заполнить наименованиями таблиц из другой базы,
// передав параметр "База". Если нужно для текущей базы, то параметр База передавать не нужно.
// 
// Параметры:
//  ШаблонТекстаЗапроса - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  База - СправочникСсылка.Спец_Базы, Неопределено - База, для которой нужно заполнить наименования таблиц.
// 
// Возвращаемое значение:
//  Строка
//
Функция ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(Знач ШаблонТекстаЗапроса, Кэш = Неопределено, Знач База = Неопределено) Экспорт
	
	// ++ Спец_БСП.ОбменСДругимиБазами_БезМодуляОтправителя
	////Спец_Проверить(Не ЗначениеЗаполнено(База), "Нельзя заполнить параметры для другой базы! Нужен модуль отправителя по обменам");
	// -- Спец_БСП.ОбменСДругимиБазами_БезМодуляОтправителя
	
	// Ищем наименования параметров (в квадратных скобках)
	ГотовыйТекстЗапроса = СтрЗаменить(ШаблонТекстаЗапроса, "[ТекущийUnixTimestampВPostrgeSQL]", Спец_КонстантыКлиентСервер.ТекущийUnixTimestampВPostrgeSQL());
	
	СтартоваяПозиция = 1;
	Пока Истина Цикл
		
		ПозицияЛевогоИмени = СтрНайти(ГотовыйТекстЗапроса, "[", , СтартоваяПозиция);
		Если ПозицияЛевогоИмени = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ПозицияПравогоИмени = СтрНайти(ГотовыйТекстЗапроса, "]", , ПозицияЛевогоИмени);
		Если ПозицияПравогоИмени = 0 Тогда
			Прервать;
		КонецЕсли;
		
		СтартоваяПозиция          = ПозицияЛевогоИмени + 1;
		ПредварительноеИмяТаблицы = Сред(ГотовыйТекстЗапроса, ПозицияЛевогоИмени + 1, ПозицияПравогоИмени - ПозицияЛевогоИмени - 1);
		МассивИменаТаблицы        = СтрРазделить(ПредварительноеИмяТаблицы, ".", Ложь);
		ТипСоставногоПоля         = Неопределено; // ПеречислениеСсылка.Спец_ТипыСоставныхПолейБазыДанных
		
		КоличествоЗаписей = МассивИменаТаблицы.Количество();
		Если КоличествоЗаписей = 2 Тогда // Имя метаданных какого-то объекта
			
			ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую_ПодставитьИмяТаблицы(ГотовыйТекстЗапроса,
					Сред(ГотовыйТекстЗапроса, ПозицияЛевогоИмени, ПозицияПравогоИмени - ПозицияЛевогоИмени + 1),
					ПредварительноеИмяТаблицы,
					База);
			
		ИначеЕсли КоличествоЗаписей = 3 Тогда // Имя метаданных + реквизит или имя табличной части
			
			ИмяМетаданных     = МассивИменаТаблицы.Получить(0) + "." + МассивИменаТаблицы.Получить(1);
			ИмяРеквизитаИлиТЧ = МассивИменаТаблицы.Получить(2);
			
			СтруктураРеквизитов = Спец_ОбщегоНазначения.ПолучитьСтруктуруВсехРеквизитовОбъекта(ИмяМетаданных, Истина, Кэш);
			
			// Проверка на составной тип реквизита
			ПозицияСоставногоТипа = СтрНайти(ИмяРеквизитаИлиТЧ, "(");
			Если ПозицияСоставногоТипа > 0 Тогда
				
				ИмяСоставногоТипа = Сред(ИмяРеквизитаИлиТЧ, ПозицияСоставногоТипа + 1);
				ИмяСоставногоТипа = СтрЗаменить(ИмяСоставногоТипа, ")", "");
				ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных." + ИмяСоставногоТипа);
				ИмяРеквизитаИлиТЧ = СтрЗаменить(ИмяРеквизитаИлиТЧ, "(" + ИмяСоставногоТипа + ")", "");
				
			КонецЕсли;
			
			// Если имя предопределенного, подставляем ГУИД
			//@skip-check empty-except-statement
			Попытка
				ПопыткаПредопределенноеЗначение = ПредопределенноеЗначение(ИмяМетаданных + "." + ИмяРеквизитаИлиТЧ); // ЛюбаяСсылка
			Исключение
			КонецПопытки;
			
			Если ПопыткаПредопределенноеЗначение <> Неопределено Тогда
				
				ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую_ПодставитьПредопределенноеЗначение(ГотовыйТекстЗапроса,
					Сред(ГотовыйТекстЗапроса, ПозицияЛевогоИмени, ПозицияПравогоИмени - ПозицияЛевогоИмени + 1),
					ИмяМетаданных,
					ПопыткаПредопределенноеЗначение,
					База);
				
				ПопыткаПредопределенноеЗначение = Неопределено;
				
			КонецЕсли;
			
			Если СтруктураРеквизитов.МассивРеквизитов.Найти(ИмяРеквизитаИлиТЧ) <> Неопределено
				Или СтрНачинаетсяС(ИмяМетаданных, "Перечисление.") Тогда // Это реквизит
				
				ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую_ПодставитьРеквизит(ГотовыйТекстЗапроса,
					Сред(ГотовыйТекстЗапроса, ПозицияЛевогоИмени, ПозицияПравогоИмени - ПозицияЛевогоИмени + 1),
					ИмяМетаданных,
					ИмяРеквизитаИлиТЧ,
					ТипСоставногоПоля,
					База);
				
			Иначе
				
				ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую_ПодставитьИмяТаблицы(ГотовыйТекстЗапроса,
					Сред(ГотовыйТекстЗапроса, ПозицияЛевогоИмени, ПозицияПравогоИмени - ПозицияЛевогоИмени + 1),
					ИмяМетаданных + ".ТабличнаяЧасть." + ИмяРеквизитаИлиТЧ,
					База);
				
			КонецЕсли;
			
		ИначеЕсли КоличествоЗаписей = 4 Тогда // Реквизит табличной части
			
			ИмяРеквизитаИлиТЧ = МассивИменаТаблицы.Получить(3);
			
			// Проверка на составной тип реквизита
			ПозицияСоставногоТипа = СтрНайти(ИмяРеквизитаИлиТЧ, "(");
			Если ПозицияСоставногоТипа > 0 Тогда
				
				ИмяСоставногоТипа = Сред(ИмяРеквизитаИлиТЧ, ПозицияСоставногоТипа + 1);
				ИмяСоставногоТипа = СтрЗаменить(ИмяСоставногоТипа, ")", "");
				ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных." + ИмяСоставногоТипа);
				ИмяРеквизитаИлиТЧ = СтрЗаменить(ИмяРеквизитаИлиТЧ, "(" + ИмяСоставногоТипа + ")", "");
				
			КонецЕсли;
			
			ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую_ПодставитьРеквизит(ГотовыйТекстЗапроса,
					Сред(ГотовыйТекстЗапроса, ПозицияЛевогоИмени, ПозицияПравогоИмени - ПозицияЛевогоИмени + 1),
					МассивИменаТаблицы.Получить(0) + "." + МассивИменаТаблицы.Получить(1) + ".ТабличнаяЧасть." + МассивИменаТаблицы.Получить(2),
					ИмяРеквизитаИлиТЧ,
					ТипСоставногоПоля,
					База);
			
		Иначе // Неизвестный случай
			
			Продолжить;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ГотовыйТекстЗапроса;
	
КонецФункции

// Формирует текст запроса для удаления объектов из БД напрямую (DELETE FROM).
// Если это регистр, то записывается только удаление из таблицы по указанным отборам.
// Если это ссылочный объект, то по удалённым ссылкам удаляются все данные из
//        (!) ВСЕХ РЕГИСТРОВ (!) И ВЕДУЩИХ ИЗМЕРЕНИЙ (!)
// 
// Примечание: если передан массив как значение отбора, то условие для удаление прописывается через WHERE IN.
// Чтобы это отработало быстрее, лучше использовать временную таблицу в БД и внутреннее соединение. 
// 
// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - см. Спец_ОбщегоНазначения.ПолучитьСтруктуруВсехРеквизитовОбъекта.ОбъектМетаданныхИлиПолноеИмя
//  МассивОтборов - Массив из см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруОтбораДляУдаленияОбъектовИзБД
//  			  - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруОтбораДляУдаленияОбъектовИзБД
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка - Текст запроса результат
//
Функция СформироватьТекстЗапросаДляУдаленияОбъектовИзБД(Знач ОбъектМетаданныхИлиПолноеИмя, Знач МассивОтборов, Кэш = Неопределено) Экспорт
	
	СтруктураПоМетаданным = Спец_ОбщегоНазначения.ПолучитьСтруктуруИмениТипаДанныхОбъекта(ОбъектМетаданныхИлиПолноеИмя, Кэш);
	Если СтруктураПоМетаданным.МетаданныеОбъекта = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	// Формируем условия
	МассивУсловий = Новый Массив(); // Массив из Строка
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивОтборов);
	Для Каждого СтруктураОтбора Из МассивОтборов Цикл
		
		Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(СтруктураОтбора.Значение) Тогда
			
			МассивЗначенийДляУсловия = Новый Массив(); // Массив из Строка
			Для Каждого ЭлементОтбора Из СтруктураОтбора.Значение Цикл
				МассивЗначенийДляУсловия.Добавить(Спец_PostgreSQLКлиентСервер.ПолучитьЗначениеДляPostgreSQLВТекстЗапроса(ЭлементОтбора, , Кэш));
			КонецЦикла;
			
			Если СтруктураОтбора.ВидСравнения = ВидСравнения.НеВСписке
					Или СтруктураОтбора.ВидСравнения = ВидСравнения.НеВИерархии
					Или СтруктураОтбора.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии
					Или СтруктураОтбора.ВидСравнения = ВидСравнения.НеРавно
					Или СтруктураОтбора.ВидСравнения = ВидСравнения.НеСодержит Тогда
				
				ЛогическийОператор = "NOT IN";
				
			Иначе
				
				ЛогическийОператор = "IN";
				
			КонецЕсли;
			
			МассивУсловий.Добавить(СтрШаблон("[%1.%2] %4 (%3)",
					СтруктураПоМетаданным.ПолноеИмяОбъекта,
					СтруктураОтбора.ИмяОтбора,
					СтрСоединить(МассивЗначенийДляУсловия, ","),
					ЛогическийОператор));
			
		Иначе
			
			ГотовоеЗначение = Спец_PostgreSQLКлиентСервер.ПолучитьЗначениеДляPostgreSQLВТекстЗапроса(СтруктураОтбора.Значение, , Кэш);
			
			Если СтруктураОтбора.ВидСравнения = ВидСравнения.НеРавно Тогда
				ЛогическийОператор = "<>";
			ИначеЕсли СтруктураОтбора.ВидСравнения = ВидСравнения.ВСписке Или СтруктураОтбора.ВидСравнения = ВидСравнения.ВСпискеПоИерархии Тогда
				ЛогическийОператор = "IN";
				ГотовоеЗначение = "(" + ГотовоеЗначение + ")";
			ИначеЕсли СтруктураОтбора.ВидСравнения = ВидСравнения.НеВСписке Или СтруктураОтбора.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
				ЛогическийОператор = "NOT IN";
				ГотовоеЗначение = "(" + ГотовоеЗначение + ")";
			ИначеЕсли СтруктураОтбора.ВидСравнения = ВидСравнения.Больше Тогда
				ЛогическийОператор = ">";
			ИначеЕсли СтруктураОтбора.ВидСравнения = ВидСравнения.БольшеИлиРавно Тогда
				ЛогическийОператор = ">=";
			ИначеЕсли СтруктураОтбора.ВидСравнения = ВидСравнения.Меньше Тогда
				ЛогическийОператор = "<";
			ИначеЕсли СтруктураОтбора.ВидСравнения = ВидСравнения.МеньшеИлиРавно Тогда
				ЛогическийОператор = "<=";
			ИначеЕсли СтруктураОтбора.ВидСравнения = ВидСравнения.Содержит Тогда
				ЛогическийОператор = "LIKE";
			ИначеЕсли СтруктураОтбора.ВидСравнения = ВидСравнения.НеСодержит Тогда
				ЛогическийОператор = "NOT LIKE";
			Иначе
				ЛогическийОператор = "=";
			КонецЕсли;
			
			МассивУсловий.Добавить(СтрШаблон("[%1.%2] %4 %3",
					СтруктураПоМетаданным.ПолноеИмяОбъекта,
					СтруктураОтбора.ИмяОтбора,
					ГотовоеЗначение,
					ЛогическийОператор));
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТекстУсловия = ?(МассивУсловий.Количество() > 0,
			"WHERE " + СтрСоединить(МассивУсловий, Символы.ПС + Символы.Таб + Символы.Таб + "AND "),
			"");
	
	Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоРегистр(СтруктураПоМетаданным.ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
		
		Возврат ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(СтрШаблон("DELETE FROM [%1]
																			   |%2", СтруктураПоМетаданным.ПолноеИмяОбъекта, ТекстУсловия), Кэш);
		
	ИначеЕсли Не Спец_ОбщегоНазначенияКлиентСервер.ЭтоСсылка(СтруктураПоМетаданным.ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
		
		Возврат "";
		
	КонецЕсли;
	
	// Здесь только ссылочные объекты
	МассивТекстЗапроса = Новый Массив(); // Массив из Строка
	МассивТекстЗапроса.Добавить(СтрШаблон(
			
			"CREATE TEMP TABLE vt_tmp ON COMMIT DROP AS
			|(
			|	SELECT DISTINCT [%1.Ссылка] AS rref
			|	FROM [%1]
			|	%2
			|);
			|
			|
			|CREATE UNIQUE INDEX vt_tmp_idx ON vt_tmp USING btree
			|	(rref ASC NULLS LAST)
			|	WITH (FILLFACTOR=100);
			|
			|
			|ANALYZE vt_tmp",
			
			СтруктураПоМетаданным.ПолноеИмяОбъекта,
			ТекстУсловия));
	
	МассивТекстЗапроса.Добавить(СтрШаблон(
			
			"DELETE FROM [%1] USING vt_tmp
			|WHERE [%1.Ссылка] = vt_tmp.rref",
			
			СтруктураПоМетаданным.ПолноеИмяОбъекта));
	
	СтруктураВсехРеквизитов = Спец_ОбщегоНазначения.ПолучитьСтруктуруВсехРеквизитовОбъекта(ОбъектМетаданныхИлиПолноеИмя, Истина, Кэш);
	Для Каждого ТабличнаяЧасть Из СтруктураВсехРеквизитов.ТабличныеЧасти Цикл
		
		МассивТекстЗапроса.Добавить(СтрШаблон(
				
				"DELETE FROM [%1.%2] USING vt_tmp
				|WHERE [%1.%2.Ссылка] = vt_tmp.rref",
				
				СтруктураПоМетаданным.ПолноеИмяОбъекта,
				ТабличнаяЧасть.Ключ));
		
	КонецЦикла;
	
	// Ищем регистры, где данный объект ключевой
	КодТекущейТаблицы = СериализаторXDTO.XMLСтрока(Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьКодТаблицыИзБД(СтруктураПоМетаданным.ПолноеИмяОбъекта));
	
	МассивРеквизитов = Спец_ОбщегоНазначения.ПолучитьМассивРеквизитовГдеУчаствуетОбъект(СтруктураПоМетаданным.МетаданныеОбъекта, Кэш);
	Для Каждого СтруктураРеквизита Из МассивРеквизитов Цикл
		
		Если Не Спец_ОбщегоНазначенияКлиентСервер.ЭтоРегистр(СтруктураРеквизита.ПолноеИмяМетаданных, Кэш, Тип("Строка")) Тогда
			Продолжить;
		КонецЕсли;
		
		МассивКлючевыхИзмерений = Спец_ОбщегоНазначения.ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(СтруктураРеквизита.ПолноеИмяМетаданных, Кэш);
		Если МассивКлючевыхИзмерений.Найти(СтруктураРеквизита.ИмяРеквизита) <> Неопределено Тогда
			
			ИмяРеквизита = Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьИмяРеквизитаИзБД(СтруктураРеквизита.ПолноеИмяМетаданных, СтруктураРеквизита.ИмяРеквизита);
			Если СтрРазделить(ИмяРеквизита, ",").Количество() > 1 Тогда
				// Это составной тип
				
				МассивТекстЗапроса.Добавить(СтрШаблон(
						
						"DELETE FROM [%1] USING vt_tmp
						|WHERE [%1.%2(НомерТаблицы)] = lykov_RTRefToBytea(%3)
						|	AND [%1.%2(ИдентификаторСсылки)] = vt_tmp.rref",
						
						СтруктураРеквизита.ПолноеИмяМетаданных,
						СтруктураРеквизита.ИмяРеквизита,
						КодТекущейТаблицы));
				
			Иначе
				
				МассивТекстЗапроса.Добавить(СтрШаблон(
						
						"DELETE FROM [%1] USING vt_tmp
						|WHERE [%1.%2] = vt_tmp.rref",
						
						СтруктураРеквизита.ПолноеИмяМетаданных,
						СтруктураРеквизита.ИмяРеквизита));
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТекстЗапроса = СтрСоединить(МассивТекстЗапроса, ";
			|
			|");
	
	Возврат ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую(ТекстЗапроса, Кэш);
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Параметры:
//  ТекстЗапроса - Строка
//  ИмяПараметра - Строка
//  ИмяМетаданных - Строка
//  База - СправочникСсылка.Спец_Базы, Неопределено - 
//
Процедура ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую_ПодставитьИмяТаблицы(ТекстЗапроса, Знач ИмяПараметра, Знач ИмяМетаданных, Знач База)
	
	Если ЗначениеЗаполнено(База) Тогда МодульОбменыВозвращаемые = Спец_ОбщегоНазначенияКлиентСервер.ОбщийМодуль("Спец_ОбменСДругимиБазамиВызовСервераПовтИсп"); КонецЕсли;
	
	// Проверка на параметр "Код таблицы"
	ПозицияСоставногоТипа = СтрНайти(ИмяМетаданных, "(");
	Если ПозицияСоставногоТипа > 0 Тогда
		
		ИмяПараметраВСкобках = Сред(ИмяМетаданных, ПозицияСоставногоТипа + 1);
		ИмяПараметраВСкобках = СтрЗаменить(ИмяПараметраВСкобках, ")", "");
		
		Если ИмяПараметраВСкобках = "КодТаблицы" Тогда
			
			ИмяМетаданных = СтрЗаменить(ИмяМетаданных, "(КодТаблицы)", "");
			
			//@skip-check dynamic-access-method-not-found
			КодТаблицы = Формат(?(База <> Неопределено,
					МодульОбменыВозвращаемые.КодТаблицыВБДДляДругойБазы(База, ИмяМетаданных),
					Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьКодТаблицыИзБД(ИмяМетаданных)), "ЧН=0; ЧГ=");
			
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПараметра, КодТаблицы);
			Возврат;
			
		КонецЕсли;
		
	КонецЕсли;
	
	//@skip-check dynamic-access-method-not-found
	ИмяТаблицыБД = ?(База = Неопределено,
		Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьИмяТаблицыИзБД(ИмяМетаданных),
		МодульОбменыВозвращаемые.ИмяТаблицыВБДДляДругойБазы(База, ИмяМетаданных));
	
	Если Не ПустаяСтрока(ИмяТаблицыБД) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПараметра, ИмяТаблицыБД);
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  ТекстЗапроса - Строка
//  ИмяПараметра - Строка
//  ИмяМетаданных - Строка
//  ЗначениеПредопределенного - ЛюбаяСсылка
//  База - СправочникСсылка.Спец_Базы, Неопределено - 
//
Процедура ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую_ПодставитьПредопределенноеЗначение(ТекстЗапроса, Знач ИмяПараметра, Знач ИмяМетаданных,
		Знач ЗначениеПредопределенного, Знач База)
	
	Если ЗначениеЗаполнено(База) Тогда МодульОбменыВозвращаемые = Спец_ОбщегоНазначенияКлиентСервер.ОбщийМодуль("Спец_ОбменСДругимиБазамиВызовСервераПовтИсп"); КонецЕсли;
	Если СтрНачинаетсяС(ИмяМетаданных, "Перечисление.") Тогда
		
		//@skip-check dynamic-access-method-not-found
		ГУИДПредопределенного = ?(База = Неопределено,
			Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьГУИДПредопределенногоЭлементаВБазе(ЗначениеПредопределенного),
			МодульОбменыВозвращаемые.ГУИДПредопределенногоЗначенияДляДругойБазы(База, ИмяМетаданных, ЗначениеПредопределенного));
		
	ИначеЕсли База <> Неопределено Тогда
		
		ГУИДПредопределенного = СериализаторXDTO.XMLСтрока(ЗначениеПредопределенного);
		
	КонецЕсли;
	
	Если Не ПустаяСтрока(ГУИДПредопределенного) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПараметра, "'" + ГУИДПредопределенного + "'");
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  ТекстЗапроса - Строка
//  ИмяПараметра - Строка
//  ИмяМетаданных - Строка
//  ИмяРеквизита - Строка
//  СоставнойТип - ПеречислениеСсылка.Спец_ТипыСоставныхПолейБазыДанных
//  База - СправочникСсылка.Спец_Базы, Неопределено - 
//
Процедура ПодставитьНаименованияТаблицДляТекстаЗапросаНапрямую_ПодставитьРеквизит(ТекстЗапроса, Знач ИмяПараметра, Знач ИмяМетаданных,
		Знач ИмяРеквизита, Знач СоставнойТип, Знач База)
	
	Если ЗначениеЗаполнено(База) Тогда МодульОбменыВозвращаемые = Спец_ОбщегоНазначенияКлиентСервер.ОбщийМодуль("Спец_ОбменСДругимиБазамиВызовСервераПовтИсп"); КонецЕсли;
	
	//@skip-check dynamic-access-method-not-found
	ИмяРеквизитаБД = ?(База = Неопределено,
		Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьИмяРеквизитаИзБД(ИмяМетаданных, ИмяРеквизита, СоставнойТип),
		МодульОбменыВозвращаемые.ИмяРеквизитаИзБДДляДругойБазы(База, ИмяМетаданных, ИмяРеквизита, СоставнойТип)); // Строка
	
	Если Не ПустаяСтрока(ИмяРеквизитаБД) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПараметра, ИмяРеквизитаБД);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти
