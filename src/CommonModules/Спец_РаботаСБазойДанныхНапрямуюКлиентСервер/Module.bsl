// @strict-types

//@skip-check transfer-object-between-client-server
//@skip-check method-too-many-params

#Область ПрограммныйИнтерфейс

#Область ИменаОбъектовВБД

// Возвращает имя таблицы в БД.
// 
// Параметры:
//  МетаданныеОбъектаИлиПолноеИмя - Строка - Полное имя объекта метаданных в 1С
//  							  - см. Спец_ОбщегоНазначения.ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьИмяТаблицыИзБД(Знач МетаданныеОбъектаИлиПолноеИмя) Экспорт
	
	//@skip-check unknown-method-property
	ПолноеИмяСтрокой = ?(ТипЗнч(МетаданныеОбъектаИлиПолноеИмя) = Тип("Строка"),
			МетаданныеОбъектаИлиПолноеИмя,
			МетаданныеОбъектаИлиПолноеИмя.ПолноеИмя());
	
	ТипБазыДанных = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы().ТипБазыДанных;
	Если ТипБазыДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL") Тогда
		
		Возврат Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ПолноеИмяСтрокой).НаименованиеВPostgreSQL;
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ПолучитьИмяТаблицыИзБДЧерез1С(ПолноеИмяСтрокой);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ПолучитьИмяТаблицыИзБДЧерез1С(ПолноеИмяСтрокой);
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

// Возвращает имя реквизита в БД
// 
// Параметры:
//  МетаданныеОбъектаИлиПолноеИмя - Строка - Полное имя объекта метаданных в 1С
//  							  - см. Спец_ОбщегоНазначения.ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
//  ИмяРеквизита - Строка - Имя реквизита в 1С
//	ТипСоставногоПоля - Неопределено, ПеречислениеСсылка.Спец_ТипыСоставныхПолейБазыДанных - Тип составного поля
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьИмяРеквизитаИзБД(Знач МетаданныеОбъектаИлиПолноеИмя, Знач ИмяРеквизита, Знач ТипСоставногоПоля = Неопределено) Экспорт
	
	//@skip-check unknown-method-property
	ПолноеИмяСтрокой = ?(ТипЗнч(МетаданныеОбъектаИлиПолноеИмя) = Тип("Строка"),
			МетаданныеОбъектаИлиПолноеИмя,
			МетаданныеОбъектаИлиПолноеИмя.ПолноеИмя());
	
	ТипБазыДанных = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы().ТипБазыДанных;
	Если ТипБазыДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL") Тогда
		
		Возврат Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(ПолноеИмяСтрокой, ИмяРеквизита, ТипСоставногоПоля);
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ПолучитьИмяРеквизитаИзБДЧерез1С(ПолноеИмяСтрокой, ИмяРеквизита);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ПолучитьИмяРеквизитаИзБДЧерез1С(ПолноеИмяСтрокой, ИмяРеквизита);
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

// Возвращает код таблицы (номер таблицы, последние цифровые сивмолы наименования таблицы) в БД.
// Если таблица не существует, или нет доступа к наименованиям в БД, то возвращается -1.
// 
// Параметры:
//  МетаданныеОбъектаИлиПолноеИмя - Строка - Полное имя объекта метаданных в 1С
//  							  - см. Спец_ОбщегоНазначения.ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
// 
// Возвращаемое значение:
//  Число
//
Функция ПолучитьКодТаблицыИзБД(Знач МетаданныеОбъектаИлиПолноеИмя) Экспорт
	
	ТипБазыДанных = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы().ТипБазыДанных;
	Если ТипБазыДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL") Тогда
		
		//@skip-check unknown-method-property
		ПолноеИмяСтрокой = ?(ТипЗнч(МетаданныеОбъектаИлиПолноеИмя) = Тип("Строка"),
				МетаданныеОбъектаИлиПолноеИмя,
				МетаданныеОбъектаИлиПолноеИмя.ПолноеИмя());
		
		Возврат Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ПолноеИмяСтрокой).КодТаблицы;
		
	Иначе
		
		Возврат -1;
		
	КонецЕсли;
	
КонецФункции

// Возвращает ГУИД предопределённого элемента в БД. Для перечислений возвращает _idrref, для остальных элементов - _predefinedid (в формате 1С).
// 
// Параметры:
//  ПредопределенныйЭлемент - ЛюбаяСсылка - Предопределенный элемент
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьГУИДПредопределенногоЭлементаВБазе(Знач ПредопределенныйЭлемент) Экспорт
	
	ТипБазыДанных = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы().ТипБазыДанных;
	Если ТипБазыДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL") Тогда
		
		Возврат Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьГУИДПредопределенногоЭлементаВPostgreSQL(ПредопределенныйЭлемент);
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает предопределённый элемент по ГУИДу в БД. Обратный вызов для ПолучитьГУИДПредопределенногоЭлементаВБазе.
// см. ПолучитьГУИДПредопределенногоЭлементаВБазе
// 
// Параметры:
//  ГУИДЭлемента - Строка
// 
// Возвращаемое значение:
//  ЛюбаяСсылка
//
Функция ПолучитьПредопределенныйЭлементПоГУИДу(Знач ГУИДЭлемента) Экспорт
	
	ТипБазыДанных = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы().ТипБазыДанных;
	Если ТипБазыДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL") Тогда
		Возврат Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьПредопределенныйЭлементПоГУИДуВБазе(ГУИДЭлемента);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Возвращает наименование таблицы в 1С по коду в БД
// 
// Параметры:
//  КодТаблицы - Число
// 
// Возвращаемое значение:
//  Строка - Получить наименование таблицы в 1С по коду
//
Функция ПолучитьНаименованиеТаблицыВ1СПоКоду(Знач КодТаблицы) Экспорт
	
	ТипБазыДанных = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы().ТипБазыДанных;
	Если ТипБазыДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL") Тогда
		
		Возврат Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьНаименованиеТаблицыПоКоду(КодТаблицы);
		
	Иначе
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат Спец_ОбщегоНазначенияВызовСервера.ПолучитьИмяТаблицыВ1СПоКодуЧерез1С(КодТаблицы);
		#Иначе
			Возврат Спец_ОбщегоНазначения.ПолучитьИмяТаблицыВ1СПоКодуЧерез1С(КодТаблицы);
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ЗаписьНапрямую

// ЭТО ОЧЕНЬ ГРУБАЯ ОЦЕНКА (более точная будет занимать слишком много времени).
// Берём количество строк * количество колонок и, так как в основном передаются ссылки,
// за количество байт в одном столбце берём 36 символов (длина идентификатора ссылки).
// Если полученный размер превышает 2 буфера данных для потоков, то лучше передавать через файлы.
// 
//@skip-check unknown-method-property
// 
// Параметры:
//  ИсходныеДанныеДляПередачи - ТаблицаЗначений, Массив из Структура - Исходные данные для передачи
// 
// Возвращаемое значение:
//  Булево - Флаг того, что лучше передавать через файлы
//
Функция ЛучшеПередаватьЧерезФайлы(Знач ИсходныеДанныеДляПередачи) Экспорт

	ТипИсходныхДанных = ТипЗнч(ИсходныеДанныеДляПередачи);
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ИсходныеДанныеДляПередачи, ТипИсходныхДанных) Тогда
		
		Возврат ИсходныеДанныеДляПередачи.Количество()
				* ИсходныеДанныеДляПередачи.Колонки.Количество()
				* Спец_КонстантыКлиентСервер.ДлинаИдентификатораСсылки() > Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков"), 16384) * 2;

	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИсходныеДанныеДляПередачи, ТипИсходныхДанных) Тогда

		Если ИсходныеДанныеДляПередачи.Количество() = 0 Тогда
			
			Возврат Ложь;
			
		ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ИсходныеДанныеДляПередачи.Получить(0)) Тогда
			
			Возврат ИсходныеДанныеДляПередачи.Количество()
					* ИсходныеДанныеДляПередачи.Получить(0).Количество()
					* Спец_КонстантыКлиентСервер.ДлинаИдентификатораСсылки() > Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков"), 16384) * 2;
			
		Иначе
			
			Возврат ИсходныеДанныеДляПередачи.Количество()
					* Спец_КонстантыКлиентСервер.ДлинаИдентификатораСсылки() > Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков"), 16384) * 2;
			
		КонецЕсли;

	Иначе

		Возврат Ложь;

	КонецЕсли;

КонецФункции

#Область ПомещениеДанныхВоВременнуюТаблицу

// Структура параметров для помещения данных во временную таблицу.
// 
//@skip-check structure-consructor-too-many-keys
// 
// Параметры:
//  ИмяМетаданныхИз1С - Строка - Наименование объекта метаданных в 1С
// 
// Возвращаемое значение:
//  Структура - Подготовить структуру параметров помещение данных во временную таблицу:
// * ИмяМетаданныхИз1С - Строка - Наименование таблицы из 1С.
//                                Если заполнено, то наименования колонок в PostgreSQL будут браться из таблицы 1С.
//                                В противном случае наименования колонок не меняются.
// * НачинатьТранзакцию - Булево - Если ИСТИНА, то будет вызвано начало транзакции.
// * ИмяВременнойТаблицы - Строка - Имя временной таблицы результат.
// * МассивПолейДляИндекса - Массив из Строка - Массив полей, которые будут проиндексированы (в именах 1С)
//
Функция ПодготовитьСтруктуруПараметровПомещениеДанныхВоВременнуюТаблицу(Знач ИмяМетаданныхИз1С = "") Экспорт
	
	Возврат Новый Структура(
			"ИмяМетаданныхИз1С,
			|НачинатьТранзакцию,
			|ИмяВременнойТаблицы,
			|МассивПолейДляИндекса",
			
			ИмяМетаданныхИз1С,
			Истина,
			"spec_tmp",
			Новый Массив());
	
КонецФункции

// Поместить таблицу 1С во временную таблицу в БД.
// 
// Параметры:
//	ИсходныеДанные - Массив из Структура
//  			   - Массив из ФиксированнаяСтруктура
//  			   - ФиксированныйМассив из Структура
//  			   - ФиксированныйМассив из ФиксированнаяСтруктура
//  			   - ТаблицаЗначений - Исходные данные. Имена колонок должны совпадать с именами столбцов в 1С.
//	ПараметрыПомещения - см. ПодготовитьСтруктуруПараметровПомещениеДанныхВоВременнуюТаблицу
//	ТекстОшибок - Строка - Текст ошибок
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Неопределено, Структура - Структура помещённой временной таблицы:
//		* ИмяТаблицы - Строка - Имя временной таблицы
//		* СоответствиеПолей - Соответствие из КлючИЗначение - Соответствие помещённых столбцов в БД:
//			** Ключ - Строка - Имя столбца в БД
//			** Значение - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
//
Функция ПоместитьТаблицу1СВоВременнуюТаблицу(Знач ИсходныеДанные, Знач ПараметрыПомещения, ТекстОшибок = "", Кэш = Неопределено) Экспорт

	Спец_Проверить(Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна(), "Запись напрямую недоступна!");
	Возврат Спец_PostgreSQLКлиентСервер.ПоместитьТаблицу1СВоВременнуюТаблицу(ИсходныеДанные, ПараметрыПомещения, ТекстОшибок, Кэш);

КонецФункции

#КонецОбласти

// Структура параметров для записи в БД напрямую.
// Если тип обновления 'НайтиНеОбновлятьСоздавать' или 'НайтиОбновлятьСоздавать', то если ПоляДляПроверкиКонфликтов совпадают с ограничением по таблице
// (т.е. с любым уникальным индексом или констрейнтом),
// то основная таблица перед записью НЕ будет присоединенина, будет выполнена просто запись. Если не будет совпадать,
// сначала будет присоединена основная таблица с данными (по ПолямДляСвязи левым соединением) и уже потом по всем основным ограничениям выполнена запись
// (так как в БД в ON CONFLICT нужно указывать существующий индекс,
// иначе будет ошибка 'Нет уникального ограничения или ограничения-исключения, соответствующего указанию ON CONFLICT')
// 
// Параметры:
//  МетаданныеОбъектаИлиПолноеИмя - Строка - Полное имя объекта метаданных в 1С
//  							  - см. Спец_ОбщегоНазначения.ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
// 
// Возвращаемое значение:
//	Структура - Структура параметров для записи в БД:
//		* НаименованиеВБД - Строка - Наименование таблицы в БД
//		* ИмяМетаданныхВ1С - Строка - Наименование метаданных в 1С
//		* ТипВ1С - Тип - Тип метаданных в 1С
//		* ПоляДляСвязи - Массив из см. ПолучитьСтруктуруПоляДляСвязиДляЗаписи - Массив полей для связи с исходной таблицей в БД (Ссылка или все измерения)
//		* ПоляДляПроверкиКонфликтов - Массив из Строка - Массив полей для проверки конфликтов (ON CONFLICT (...) DO...) (в именах БД)
//		* ИмяПоляГУИДа - Строка - Имя поля для формирования ГУИДа новой ссылки
//		* ДополнительныеПоляДляВозврата - Массив из Строка - Массив имен полей для возврата после обновления таблицы. В именах PostrgeSQL:
//                                      'resTable.<Имя поля>' - из таблицы (!) только измененных (!) записей.
//                                                              Т.е. если НайтиНеОбновлятьСоздавать, то вернутся только созданные записи, и т.п.
//                                      'vt.<Имя поля>' - из исходных данных (из временной таблицы), присоединённой внутренним соединением к 'resTable' с помощью 'ПоляДляСвязи'
//		* ТипОбновления - ПеречислениеСсылка.Спец_ТипыОбновленияТаблицыБазыДанных - Тип обновления таблицы в PostgreSQL
//		* ВозвращатьРезультат - Булево - Если ЛОЖЬ, то изменённые данные не будут возвращены в 1С
//		* МассивИменТабличныхЧастей - Массив из Строка - Если это ссылочный объект, то содержит массив наименований табличных частей для записи
//
Функция ПодготовитьСтруктуруПараметровДляЗаписиНапрямую(Знач МетаданныеОбъектаИлиПолноеИмя) Экспорт
	
	Спец_Проверить(Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна(), "Запись напрямую недоступна!");
	
	//@skip-check unknown-method-property
	ПолноеИмяСтрокой = ?(ТипЗнч(МетаданныеОбъектаИлиПолноеИмя) = Тип("Строка"),
			МетаданныеОбъектаИлиПолноеИмя,
			МетаданныеОбъектаИлиПолноеИмя.ПолноеИмя());
	
	Возврат Спец_PostgreSQLКлиентСервер.ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL(ПолноеИмяСтрокой);
	
КонецФункции

// Структуру поля для связи для записи напрямую в БД.
// 
// Параметры:
//  МетаданныеОбъектаИлиПолноеИмя - Строка - Полное имя объекта метаданных в 1С
//  							  - см. Спец_ОбщегоНазначения.ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
//  ИмяПоляДляСвязиВ1С - Строка - Имя поля в 1С
//  ДополнительныеФункцииДляСвязи - Строка - Дополнительные функции для связи
//	ТекстОшибок - Строка - Текст ошибок
// 
// Возвращаемое значение:
//	Структура - Структура поля для связи:
//		* ИмяСтолбцаВБД - Строка - Наименование столбца в БД
//		* ИмяВ1С - Строка - Наименование столбца в 1С
//		* ТипДанных - ПеречислениеСсылка.Спец_ТипыДанныхБазыДанных - Тип данных столбца в БД
//		* ТипСоставногоПоля - ПеречислениеСсылка.Спец_ТипыСоставныхПолейБазыДанных - Тип составного поля в БД
//		* ИмяТипаДанныхВБД - Строка - Наименование типа данных в БД (для передачи через временную таблицу)
//		* ФункцияПреобразования - Строка - Функция преобразования для связи в БД
//		* НеNull - Булево - Колонка должна быть не null
//		* ДополнительныеФункцииДляСвязи - Строка - Дополнительная функция для связи в БД
//
Функция ПолучитьСтруктуруПоляДляСвязиДляЗаписи(Знач МетаданныеОбъектаИлиПолноеИмя, Знач ИмяПоляДляСвязиВ1С, Знач ДополнительныеФункцииДляСвязи = "", ТекстОшибок = "") Экспорт
	
	Спец_Проверить(Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна(), "Запись напрямую недоступна!");
	
	//@skip-check unknown-method-property
	ПолноеИмяСтрокой = ?(ТипЗнч(МетаданныеОбъектаИлиПолноеИмя) = Тип("Строка"),
			МетаданныеОбъектаИлиПолноеИмя,
			МетаданныеОбъектаИлиПолноеИмя.ПолноеИмя());
	
	Возврат Спец_PostgreSQLКлиентСервер.ПолучитьСтруктуруПоляДляСвязиДляЗаписи(ПолноеИмяСтрокой, ИмяПоляДляСвязиВ1С, ДополнительныеФункцииДляСвязи, ТекстОшибок);
	
КонецФункции

// Добавляет все ключевые измерения регистра в структуру параметров для записи напрямую в БД.
// 
// Параметры:
//  СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиНапрямую
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ДобавитьВсеКлючевыеИзмеренияРегистра(Знач СтруктураПараметров, Кэш = Неопределено) Экспорт
	
	Спец_Проверить(Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна(), "Запись напрямую недоступна!");
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		МассивИзмерений = Спец_ОбщегоНазначенияВызовСервера.ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(СтруктураПараметров.ИмяМетаданныхВ1С);
	#Иначе
		МассивИзмерений = Спец_ОбщегоНазначения.ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(СтруктураПараметров.ИмяМетаданныхВ1С, Кэш);
	#КонецЕсли
	
	Для Каждого НаименованиеИзмерения Из МассивИзмерений Цикл
		ДобавитьКлючевоеПолеДляЗапроса(СтруктураПараметров, НаименованиеИзмерения, Истина, Истина);
	КонецЦикла;
	
КонецПроцедуры

// Добавляет ключевое поле для запроса для записи напрямую в БД.
// 
// Параметры:
//	СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиНапрямую
//	ИмяКлючевогоПоля - Строка - Имя ключевого поля
//	ДобавлятьПолеСвязи - Булево - Добавлять поле связи
//	ДобавлятьПолеДляПроверкиКонфликтов - Булево - Добавлять поле для проверки конфликтов
//	СтруктураПараметровТаблицы - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//
Процедура ДобавитьКлючевоеПолеДляЗапроса(Знач СтруктураПараметров, Знач ИмяКлючевогоПоля, Знач ДобавлятьПолеСвязи = Истина, Знач ДобавлятьПолеДляПроверкиКонфликтов = Истина) Экспорт
	
	Спец_Проверить(Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна(), "Запись напрямую недоступна!");
	Спец_PostgreSQLКлиентСервер.ДобавитьКлючевоеПолеДляЗапроса(СтруктураПараметров,
			ИмяКлючевогоПоля,
			ДобавлятьПолеСвязи,
			ДобавлятьПолеДляПроверкиКонфликтов);
	
КонецПроцедуры

// Найти создать строки регистра в таблице в БД. Если напрямую записать данные не удалось, то записываются через 1С.
// 
// Параметры:
//  ИсходныеДанные - см. ПоместитьТаблицу1СВоВременнуюТаблицу.ИсходныеДанные
//	СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиНапрямую
//	ТекстОшибок - Строка - Тексты ошибок при выполнении
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//	ТолькоНапрямую - Булево - Если ИСТИНА, то запись через 1С не будет вызвана (в случае ошибок при записи напрямую)
// 
// Возвращаемое значение:
//  Булево
//
Функция НайтиСоздатьОбъектыРегистра(Знач ИсходныеДанные, Знач СтруктураПараметров, ТекстОшибок = "", Кэш = Неопределено, Знач ТолькоНапрямую = Ложь) Экспорт
	
	Спец_Проверить(Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна(), "Запись напрямую недоступна!");
	Если ИсходныеДанные.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Кэш = Неопределено Тогда
		Кэш = Спец_ПолучитьКэш();
	КонецЕсли;
	
	ПропуститьЗаписьНапрямую = Ложь;
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	// Не пишем, если включено логирование через 1С
	ПропуститьЗаписьНапрямую = Спец_ЛогированиеОбъектовВызовСервераПовтИсп.ТипЛогированияОбъекта(СтруктураПараметров.ИмяМетаданныхВ1С) <> 0;
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	Если Не ПропуститьЗаписьНапрямую Тогда
		
		Попытка
			
			СтруктураРезультат = Спец_PostgreSQLКлиентСервер.НайтиСоздатьОбъектыВPostgreSQL(ИсходныеДанные, СтруктураПараметров, ТекстОшибок, Кэш);
			
		Исключение
			
			ТекстОшибки = СтрШаблон(
					
					"Не удалось записать данные по регистру напрямую!
					|	Текст ошибки: %1
					|	Параметры записи: %2
					|	Исходные данные: %3",
					
					Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб),
					Спец_СтроковыеФункцииКлиентСервер.СформироватьТекстовоеПредставлениеОбъекта(СтруктураПараметров, Символы.Таб),
					Спец_СтроковыеФункцииКлиентСервер.СформироватьТекстовоеПредставлениеОбъекта(?(ИсходныеДанные.Количество() > 500, "<более 500 записей>", ИсходныеДанные), Символы.Таб));
			
			Спец_ЗаписатьЛог("Найти / создать объекты регистра в БД",
					ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
					ТекстОшибки,
					Кэш);
			
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибки, "Найти / создать объекты регистра в БД", ТекстОшибок);
			
		КонецПопытки;
		
	КонецЕсли;
	
	Если Не СтруктураРезультат.Успешно И Не ТолькоНапрямую Тогда
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Спец_ОбщегоНазначенияВызовСервера.НайтиСоздатьОбъектыРегистраЧерез1С(ИсходныеДанные, СтруктураПараметров, ТекстОшибок);
		#Иначе
			Спец_ОбщегоНазначения.НайтиСоздатьОбъектыРегистраЧерез1С(ИсходныеДанные, СтруктураПараметров, ТекстОшибок, Кэш);
		#КонецЕсли
		
		СтруктураРезультат.Успешно = Истина;
		
	ИначеЕсли СтруктураРезультат.Успешно Тогда
		
		#Если Клиент Тогда
			
			ТипДляОбновления = Спец_ОбщегоНазначенияКлиентПовтИсп.ПолучитьСтруктуруИмениТипаДанныхОбъекта(СтруктураПараметров.ИмяМетаданныхВ1С).Тип;
			ОповеститьОбИзменении(ТипДляОбновления);
			
		#КонецЕсли
		
	КонецЕсли;
	
	Возврат СтруктураРезультат.Успешно;
	
КонецФункции

// Найти создать ссылочные объекты в БД.
// ВНИМАНИЕ: если это ссылочный объект, и стоит 'НеОбновлять',
// то версия данных не обновится и на формах у пользователей останется старая версия (до момента обновления кэша).
// Оповестить об изменениях не спасает.
// 
// Параметры:
//	ИсходныеДанные - см. ПоместитьТаблицу1СВоВременнуюТаблицу.ИсходныеДанные
//  СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиНапрямую
//  ТекстОшибок - Строка - Текст ошибок
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос
//
Функция НайтиСоздатьОбъектыВБазеДанных(Знач ИсходныеДанные, Знач СтруктураПараметров, ТекстОшибок = "", Кэш = Неопределено) Экспорт
	
	Спец_Проверить(Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна(), "Запись напрямую недоступна!");
	Если ИсходныеДанные.Количество() = 0 Тогда
		Возврат Новый Структура("Успешно, ТекстОшибки, РезультатЗапроса", Истина, "", Новый Массив());
	КонецЕсли;
	
	Если Кэш = Неопределено Тогда
		Кэш = Спец_ПолучитьКэш();
	КонецЕсли;
	
	Попытка
		
		СтруктураРезультат = Спец_PostgreSQLКлиентСервер.НайтиСоздатьОбъектыВPostgreSQL(ИсходныеДанные, СтруктураПараметров, ТекстОшибок, Кэш);
		Если СтруктураРезультат = Неопределено Или Не СтруктураРезультат.Успешно Тогда
			ВызватьИсключение "Не удалось создать объекты в PostgreSQL";
		КонецЕсли;
		
		#Если Клиент Тогда
			
			ТипДляОбновления = Спец_ОбщегоНазначенияКлиентПовтИсп.ПолучитьСтруктуруИмениТипаДанныхОбъекта(СтруктураПараметров.ИмяМетаданныхВ1С).Тип;
			ОповеститьОбИзменении(ТипДляОбновления);
			
		#КонецЕсли
		
		Возврат СтруктураРезультат;
		
	Исключение
		
		ТекстОшибки = СтрШаблон(
				
				"Не удалось записать данные по объектам напрямую!
				|	Текст ошибки: %1
				|	Параметры записи: %2
				|	Исходные данные: %3",
				
				Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб),
				Спец_СтроковыеФункцииКлиентСервер.СформироватьТекстовоеПредставлениеОбъекта(СтруктураПараметров, Символы.Таб),
				Спец_СтроковыеФункцииКлиентСервер.СформироватьТекстовоеПредставлениеОбъекта(?(ИсходныеДанные.Количество() > 500, "<более 500 записей>", ИсходныеДанные), Символы.Таб));
		
		Спец_ЗаписатьЛог("Найти / создать объекты в БД",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
				ТекстОшибки,
				Кэш);
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибки, "Найти / создать объекты в БД", ТекстОшибок);
		Возврат Новый Структура("Успешно, ТекстОшибки, РезультатЗапроса", Ложь, ТекстОшибки, Новый Массив());
		
	КонецПопытки;
	
КонецФункции

// Возвращает структуру отбора для удаления объектов из БД (см. Спец_РаботаСБазойДанныхНапрямую.СформироватьТекстЗапросаДляУдаленияОбъектовИзБД)
// 
// Параметры:
//  ИмяРеквизита - Строка - Имя реквизита для удаления
// 
// Возвращаемое значение:
//  Структура:
//		* ИмяОтбора - Строка
//		* ВидСравнения - ВидСравнения
//		* Значение - Строка, Число, Дата, Булево, ЛюбаяСсылка, Массив из Строка, Число, Дата, Булево, ЛюбаяСсылка - Значение для отбора
//
Функция ПодготовитьСтруктуруОтбораДляУдаленияОбъектовИзБД(Знач ИмяРеквизита) Экспорт
	
	Возврат Новый Структура("ИмяОтбора, ВидСравнения, Значение",
			ИмяРеквизита,
			ВидСравнения.Равно,
			"");
	
КонецФункции

// Удалить данные по объектам 1С через БД.
// 
// Параметры:
//	ИсходныеДанные - см. ПоместитьТаблицу1СВоВременнуюТаблицу.ИсходныеДанные
//  МетаданныеОбъектаИлиПолноеИмя - Строка - Полное имя объекта метаданных в 1С
//  							  - см. Спец_ОбщегоНазначения.ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
//  ТекстОшибок - Строка - Тексты ошибок при выполнении
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//	ТолькоНапрямую - Булево - Если ИСТИНА, то запись через 1С не будет вызвана (в случае ошибок при записи напрямую)
// 
// Возвращаемое значение:
//  Булево - Флаг успешности выполнения
//
Функция УдалитьДанныеПоОбъекту1СВБазеДанных(Знач ИсходныеДанные, Знач МетаданныеОбъектаИлиПолноеИмя, ТекстОшибок = "", Кэш = Неопределено, Знач ТолькоНапрямую = Ложь) Экспорт
	
	Спец_Проверить(Спец_РаботаСБазойДанныхНапрямуюВызовСервераПовтИсп.ЗаписьНапрямуюДоступна(), "Запись напрямую недоступна!");
	
	Если Кэш = Неопределено Тогда
		Кэш = Спец_ПолучитьКэш();
	КонецЕсли;
	
	Успешно = Ложь;
	//@skip-check unknown-method-property
	ПолноеИмяСтрокой = ?(ТипЗнч(МетаданныеОбъектаИлиПолноеИмя) = Тип("Строка"),
			МетаданныеОбъектаИлиПолноеИмя,
			МетаданныеОбъектаИлиПолноеИмя.ПолноеИмя());
	
	Попытка
		Успешно = Спец_PostgreSQLКлиентСервер.УдалитьДанныеПоОбъекту1СВБазеДанных(ИсходныеДанные, ПолноеИмяСтрокой, ТекстОшибок, Кэш);
	Исключение
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(), "Удалить данные по объекту(ам) в PostgreSQL", ТекстОшибок);
	КонецПопытки;
	
	Если Не Успешно И Не ТолькоНапрямую Тогда
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Спец_ОбщегоНазначенияВызовСервера.УдалитьДанныеПоОбъекту1СВБазеДанныхЧерез1С(ИсходныеДанные, ПолноеИмяСтрокой, ТекстОшибок);
		#Иначе
			Спец_ОбщегоНазначения.УдалитьДанныеПоОбъекту1СВБазеДанныхЧерез1С(ИсходныеДанные, ПолноеИмяСтрокой, ТекстОшибок, Кэш);
		#КонецЕсли
		
	ИначеЕсли Успешно Тогда
		
		#Если Клиент Тогда
			
			ТипДляОбновления = Спец_ОбщегоНазначенияКлиентПовтИсп.ПолучитьСтруктуруИмениТипаДанныхОбъекта(ПолноеИмяСтрокой).Тип;
			ОповеститьОбИзменении(ТипДляОбновления);
			
		#КонецЕсли
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

//@skip-check structure-consructor-too-many-keys
//
// Возвращаемое значение:
//  см. ПолучитьСтруктуруПоляДляСвязиДляЗаписи
//
Функция ПодготовитьСтруктуруСтолбцаВБД() Экспорт
	
	Возврат Новый Структура(
			"ИмяСтолбцаВБД,
			|ИмяВ1С,
			|ТипДанных,
			|ТипСоставногоПоля,
			|ИмяТипаДанныхВБД,
			|ФункцияПреобразования,
			|НеNull,
			|ДополнительныеФункцииДляСвязи",
			
			"",
			"",
			ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.ПустаяСсылка"),
			ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ПустаяСсылка"),
			"",
			"",
			Ложь,
			"");

КонецФункции

#КонецОбласти
