// @strict-types

//@skip-check method-too-many-params

#Область ПрограммныйИнтерфейс

// Преобразует двоичные данные в строку формата Base64
// 
// Параметры:
//  ДанныеДляОбработки - ДвоичныеДанные - Данные для обработки
// 
// Возвращаемое значение:
//  Строка - Двоичные данные в строку base64
//
Функция ПреобразоватьДвоичныеДанныеВСтрокуBase64(Знач ДанныеДляОбработки) Экспорт
	
	// Попадает любой из переносов строки, поэтому заменим все возможные варианты на всякий случай.
	Возврат УбратьЛишниеПропускиСтрок(Base64Строка(ДанныеДляОбработки));
	
КонецФункции

// Метод убирает все возможные символы переноса строк
// 
// Параметры:
//  ДанныеДляОчистки - Строка - Строка для очистки
// 
// Возвращаемое значение:
//  Строка
//
Функция УбратьЛишниеПропускиСтрок(Знач ДанныеДляОчистки) Экспорт
	
	Возврат СокрЛП(
		СтрЗаменить(
			СтрЗаменить(
				СтрЗаменить(
					СтрЗаменить(ДанныеДляОчистки, Символ(182), ""),
				Символ(13), ""),
			Символы.ВК, ""),
		Символы.ПС, ""));
	
КонецФункции

// Метод для добавления строки в текст
// 
// Параметры:
//  СтрокаДляДобавления - Строка - Добавляемая строка
//  ОбщийТекст - Строка - Текст, в который нужно добавить строку
//  Разделитель - Строка - Разделитель между текстом и добавляемой строкой
//
Процедура ДобавитьСтрокуВТекст(Знач СтрокаДляДобавления, ОбщийТекст, Знач Разделитель = ", ") Экспорт
	
	СтрокаДляДобавления = Строка(СтрокаДляДобавления);
	Если Не ПустаяСтрока(СтрокаДляДобавления) Тогда ОбщийТекст = ?(ПустаяСтрока(ОбщийТекст), СтрокаДляДобавления, ОбщийТекст + Разделитель + СтрокаДляДобавления); КонецЕсли;
	
КонецПроцедуры

// Разбивает строку на несколько строк по указанному разделителю. Разделитель может иметь любую длину.
// В случаях, когда разделителем является строка из одного символа, и не используется параметр СокращатьНепечатаемыеСимволы,
// рекомендуется использовать функцию платформы СтрРазделить.
//
// Параметры:
//  Значение               - Строка - текст с разделителями.
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ.
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     > для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат;
//     > если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//  СокращатьНепечатаемыеСимволы - Булево - сокращать непечатаемые символы по краям каждой из найденных подстрок.
//
// Возвращаемое значение:
//  Массив из Строка
//
// Пример:
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",")
//  - возвратит массив из 5 элементов, три из которых  - пустые: "", "один", "", "два", "";
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина)
//  - возвратит массив из двух элементов: "один", "два";
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(" один   два  ", " ")
//  - возвратит массив из двух элементов: "один", "два";
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("")
//  - возвратит пустой массив;
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("",,Ложь)
//  - возвратит массив с одним элементом: ""(пустая строка);
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("", " ")
//  - возвратит массив с одним элементом: "" (пустая строка).
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Значение, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено, 
	СокращатьНепечатаемыеСимволы = Ложь) Экспорт
	
	Если СтрДлина(Разделитель) = 1 
		И ПропускатьПустыеСтроки = Неопределено 
		И СокращатьНепечатаемыеСимволы Тогда 
		
		Результат = СтрРазделить(Значение, Разделитель, Ложь);
		Для Индекс = 0 По Результат.ВГраница() Цикл Результат[Индекс] = СокрЛП(Результат[Индекс]); КонецЦикла;
		Возврат Результат;
		
	КонецЕсли;
	
	Результат = Новый Массив; // Массив из Строка
	
	// Для обеспечения обратной совместимости.
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Значение) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = СтрНайти(Значение, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Значение, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Если СокращатьНепечатаемыеСимволы Тогда
				Результат.Добавить(СокрЛП(Подстрока));
			Иначе
				Результат.Добавить(Подстрока);
			КонецЕсли;
		КонецЕсли;
		Значение = Сред(Значение, Позиция + СтрДлина(Разделитель));
		Позиция = СтрНайти(Значение, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Значение) Тогда
		Если СокращатьНепечатаемыеСимволы Тогда
			Результат.Добавить(СокрЛП(Значение));
		Иначе
			Результат.Добавить(Значение);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

// Возвращает уникальный идентификатор в виде строки 4 версии.
// Платформенный метод может возвращать 1-й версии (*nix, версия 1С 8.3.12, на других не проверял). В данном случае метод возвратит новый UID
// средствами ОС.
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьУникальныйИдентификатор() Экспорт
	
	ИдентификаторРезультатСтартовый = Строка(Новый УникальныйИдентификатор);
	Если Сред(ИдентификаторРезультатСтартовый, 15, 1) = "4" Тогда Возврат ИдентификаторРезультатСтартовый; КонецЕсли;
	Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоLinux() Тогда
		ИдентификаторРезультат = Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы("uuidgen"); // Строка
	КонецЕсли;
	
	Если ПустаяСтрока(ИдентификаторРезультат) Тогда
		
		ИдентификаторРезультат = Сред(ИдентификаторРезультатСтартовый, 1, 14) + "4" // Номер версии
			+ Сред(ИдентификаторРезультатСтартовый, 16, 4) + "8" // Номер варианта
			+ Сред(ИдентификаторРезультатСтартовый, 21, 16);
		
	КонецЕсли;
	
	Возврат ИдентификаторРезультат;
	
КонецФункции

// Проверяет, содержит ли строка только цифры.
//
// Параметры:
//  Значение         - Строка - проверяемая строка.
//  ПробелыЗапрещены - Булево - если Ложь, то в строке допустимо наличие пробелов.
//
// Возвращаемое значение:
//   Булево - Истина - строка содержит только цифры или пустая, Ложь - строка содержит иные символы.
//
// Пример:
//  Результат = СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке("0123"); // Истина
//  Результат = СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке("0123abc"); // Ложь
//  Результат = СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке("01 2 3",, Ложь); // Истина
//
Функция ТолькоЦифрыВСтроке(Знач Значение, Знач ПробелыЗапрещены = Истина) Экспорт
	
	Если ТипЗнч(Значение) <> Тип("Строка") Тогда Возврат Ложь; КонецЕсли;
	Если Не ПробелыЗапрещены Тогда Значение = СтрЗаменить(Значение, " ", ""); КонецЕсли;
	
	Возврат ?(ПустаяСтрока(Значение),
		Истина,
		СтрДлина(
			СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(
								СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(
													Значение, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", "")) = 0);
	
КонецФункции

// Возвращает смещённый текст на переданный разделитель.
// Смещает только строки, разделённые символом ПС
// 
// Параметры:
//  ИсходныйТекст - Строка - Исходный текст
//  Разделитель - Строка - Разделитель, на который необходимо сместить текст
// 
// Возвращаемое значение:
//  Строка - Сместить весь текст на разделитель
//
Функция СместитьВесьТекстНаРазделитель(Знач ИсходныйТекст, Знач Разделитель = "	") Экспорт
	
	Возврат ?(Разделитель = "", ИсходныйТекст, Разделитель + СтрСоединить(СтрРазделить(ИсходныйТекст, Символы.ПС), Символы.ПС + Разделитель));
	
КонецФункции

// Метод формирует простое текстовое представление переданного объекта.
// Для веб-клиента вызывается сервер, поэтому значение должно быть сериализуемое.
// 
// Параметры:
//  ИсходныйОбъект - Произвольный
//  			   - ДвоичныеДанные
//  			   - Структура
//  			   - ФиксированнаяСтруктура
//  			   - Соответствие из Произвольный
//  			   - ФиксированноеСоответствие из Произвольный
//  			   - Массив из Произвольный
//  			   - ФиксированныйМассив из Произвольный
//  			   - СписокЗначений из Произвольный
//  			   - ТаблицаЗначений
//  			   - HTTPЗапрос
//  			   - HTTPОтвет
//  			   - HTTPСоединение
//  			   - ХранилищеЗначения
//  Смещение - Строка - Исходное смещение строки
// 
// Возвращаемое значение:
//  Строка - Текстовое представление объекта
//
Функция СформироватьТекстовоеПредставлениеОбъекта(Знач ИсходныйОбъект, Знач Смещение = "") Экспорт
	
#Если Не ВебКлиент Тогда
	
	Результат = "";
	
	ТипОбъекта = ТипЗнч(ИсходныйОбъект);
	Если ТипОбъекта = Тип("Строка") Тогда
		
		Результат = ?(ЭтоАдресВременногоХранилища(ИсходныйОбъект),
			СформироватьТекстовоеПредставлениеОбъекта(ПолучитьИзВременногоХранилища(ИсходныйОбъект)),
			СместитьВесьТекстНаРазделитель(ИсходныйОбъект, Смещение));
		
	ИначеЕсли ТипОбъекта = Тип("Число") Или ТипОбъекта = Тип("Дата") Или ТипОбъекта = Тип("Булево") Тогда
		
		Результат = СериализаторXDTO.XMLСтрока(ИсходныйОбъект);
		
	ИначеЕсли ТипОбъекта = Тип("ДвоичныеДанные") Тогда
		
		Результат = НРег(ПолучитьHexСтрокуИзДвоичныхДанных(ИсходныйОбъект));
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(ИсходныйОбъект, ТипОбъекта)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ИсходныйОбъект, ТипОбъекта) Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить(Строка(ТипОбъекта));
		
		ШаблонПоля = "%1 : %2";
		Для Каждого Значение Из ИсходныйОбъект Цикл
			
			ПредставлениеПоля = СтрШаблон(ШаблонПоля,
					СформироватьТекстовоеПредставлениеОбъекта(Значение.Ключ, Смещение + Символы.Таб),
					СформироватьТекстовоеПредставлениеОбъекта(Значение.Значение, Смещение + Символы.Таб));
			
			МассивПредставление.Добавить(ПредставлениеПоля);
			
		КонецЦикла;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИсходныйОбъект, ТипОбъекта) Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить(Строка(ТипОбъекта));
		
		Для Каждого Значение Из ИсходныйОбъект Цикл
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(Значение, Смещение + Символы.Таб));
		КонецЦикла;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли ТипОбъекта = Тип("СписокЗначений") Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить("Список значений");
		
		Для Каждого СтрокаСписка Из ИсходныйОбъект Цикл
			
			Элемент = СтрокаСписка.Представление;
			Если ПустаяСтрока(Элемент) Тогда
				Элемент = Строка(СтрокаСписка.Значение);
			КонецЕсли;
			
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(Элемент, Смещение + Символы.Таб));
			
		КонецЦикла;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ИсходныйОбъект, ТипОбъекта)
			Или ТипОбъекта = Тип("ДанныеФормыКоллекция") Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить("Таблица значений");
		
		МассивИменКолонок = Новый Массив; // Массив из Строка
		Для Каждого КолонкаТаблицы Из ИсходныйОбъект.Колонки Цикл
			МассивИменКолонок.Добавить(КолонкаТаблицы.Имя);
		КонецЦикла;
		
		ШапкаТаблицы = Символы.Таб + СокрЛП(СтрСоединить(МассивИменКолонок, " | "));
		
		МассивПредставление.Добавить(ШапкаТаблицы);
		МассивПредставление.Добавить("---------------------------------------------------------");
		
		ШаблонПоля = "%1%2) %3";
		
		i = 1;
		Для Каждого СтрокаТаблицы Из ИсходныйОбъект Цикл
			
			МассивПредставлениеСтроки = Новый Массив; // Массив из Строка
			Для Каждого КолонкаТаблицы Из ИсходныйОбъект.Колонки Цикл
				МассивПредставлениеСтроки.Добавить(СформироватьТекстовоеПредставлениеОбъекта(СтрокаТаблицы[КолонкаТаблицы.Имя]));
			КонецЦикла;
			
			ТекстСтрокиТаблицы = Символы.Таб + СтрСоединить(МассивПредставлениеСтроки, " | ");
			МассивПредставление.Добавить(СтрШаблон(ШаблонПоля, Символы.Таб, Формат(i, "ЧГ="), ТекстСтрокиТаблицы));
			
			i = i + 1;
			
		КонецЦикла;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоHTTPЗапросТип(ИсходныйОбъект, ТипОбъекта) Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		
		МассивПредставление.Добавить("HTTP запрос:");
		Если ТипОбъекта = Тип("HTTPЗапрос") Тогда
			МассивПредставление.Добавить(Символы.Таб + "Адрес запроса: " + СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.АдресРесурса));
		КонецЕсли;
		
		Если ИсходныйОбъект.Заголовки.Количество() > 0 Тогда
			
			МассивПредставление.Добавить(Символы.Таб + "Заголовки:");
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Заголовки, Смещение + Символы.Таб));
			
		КонецЕсли;
		
		ContentType = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(ИсходныйОбъект.Заголовки, "Content-Type", ""); // Строка
		Если ВРег(ContentType) = ВРег("application/json;charset=utf-8") Тогда
			
			СоответствиеJSON = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(ИсходныйОбъект.ПолучитьТелоКакСтроку());
			ТелоЗапроса      = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(СоответствиеJSON, Истина);
			
		Иначе
			
			ТелоЗапроса = ИсходныйОбъект.ПолучитьТелоКакСтроку();
			
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ТелоЗапроса) Тогда
			
			МассивПредставление.Добавить(Символы.Таб + "Текст запроса:");
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(ТелоЗапроса, Смещение + Символы.Таб));
			
		КонецЕсли;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоHTTPОтветТип(ИсходныйОбъект, ТипОбъекта) Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить("HTTP ответ:");
		
		Если ИсходныйОбъект.Заголовки.Количество() > 0 Тогда
			
			МассивПредставление.Добавить(Символы.Таб + "Заголовки:");
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Заголовки, Смещение + Символы.Таб));
			
		КонецЕсли;
		
		Если ИсходныйОбъект.Заголовки["Content-Type"] = "application/json;charset=utf-8" Тогда
			
			СоответствиеJSON = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(ИсходныйОбъект.ПолучитьТелоКакСтроку());
			ТелоЗапроса      = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(СоответствиеJSON, Истина);
			
		Иначе
			
			ТелоЗапроса = ИсходныйОбъект.ПолучитьТелоКакСтроку();
			
		КонецЕсли;
		Если ЗначениеЗаполнено(ТелоЗапроса) Тогда
			
			МассивПредставление.Добавить(Символы.Таб + "Текст ответа:");
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(ТелоЗапроса, Смещение + Символы.Таб));
			
		КонецЕсли;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли ТипОбъекта = Тип("HTTPСоединение") Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить("HTTP соединение:");
		
		ШаблонПоля = НСтр("ru = 'Адрес сервера: %1, Порт: %2, Пользователь: %3, Таймаут: %4'");
		ТекстПредставления = СтрШаблон(ШаблонПоля,
				СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Сервер),
				СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Порт),
				СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Пользователь),
				СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Таймаут));
		
		МассивПредставление.Добавить(Символы.Таб + ТекстПредставления);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоХранилищеЗначения(ИсходныйОбъект, ТипОбъекта) Тогда
		
		#Если Не ТонкийКлиент Тогда
			Результат = СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Получить());
		#КонецЕсли
		
	Иначе
		
		Результат = СокрЛП(ИсходныйОбъект);
		
	КонецЕсли;
	
	Возврат СместитьВесьТекстНаРазделитель(СокрЛП(Результат), Смещение);
	
#Иначе
	
	//@skip-check transfer-object-between-client-server
	Возврат Спец_СтроковыеФункцииВызовСервера.СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект, Смещение);
	
#КонецЕсли
	
КонецФункции

// Возвращает разделитель пакетов запросов
// 
// Возвращаемое значение:
//  Строка - Разделитель запросов
//
Функция ПолучитьРазделительЗапросов() Экспорт
	
	Возврат "
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|";
	
КонецФункции

// Возвращает разделитель объединяющих запросов (ОБЪЕДИНИТЬ ВСЕ)
// 
// Возвращаемое значение:
//  Строка
//
Функция РазделительОбъединяющихЗапросов() Экспорт
	
	Возврат "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
	
КонецФункции

// Возвращает закодированную исходную строку в формате Base64
// 
// Параметры:
//  ИсходнаяСтрока - Строка - Строка для кодирования
// 
// Возвращаемое значение:
//  Строка
//
Функция ЗакодироватьСтрокуВBase64(Знач ИсходнаяСтрока) Экспорт
	
	Возврат ПреобразоватьДвоичныеДанныеВСтрокуBase64(ПолучитьДвоичныеДанныеИзСтроки(ИсходнаяСтрока));
	
КонецФункции

// Возвращает раскодированную исходную строку формата Base64 (обратный метод для см. ЗакодироватьСтрокуВBase64)
// 
// Параметры:
//  СтрокаBase64 - Строка - Строка, закодированная в формате Base64
// 
// Возвращаемое значение:
//  Строка
//
Функция РаскодироватьСтрокуBase64(Знач СтрокаBase64) Экспорт
	
	Возврат ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(СтрокаBase64));
	
КонецФункции

// Дополняет строку символами слева или справа до заданной длины и возвращает ее.
// При этом удаляются незначащие символы слева и справа (подробнее про незначащие символы 
// см. синтакс-помощник к методу платформы СокрЛП). 
// По умолчанию функция дополняет строку символами "0" (ноль) слева.
//
// Параметры:
//  Значение    - Строка - исходная строка, которую необходимо дополнить символами;
//  ДлинаСтроки - Число  - требуемая результирующая длина строки;
//  Символ      - Строка - символ, которым необходимо дополнить строку;
//  Режим       - Строка - "Слева" или "Справа" - вариант добавления символов к исходной строке.
// 
// Возвращаемое значение:
//  Строка - строка, дополненная символами.
//
// Пример:
//  1. Результат = СтроковыеФункцииКлиентСервер.ДополнитьСтроку("1234", 10, "0", "Слева");
//  Возвращает: "0000001234".
//
//  2. Результат = СтроковыеФункцииКлиентСервер.ДополнитьСтроку(" 1234  ", 10, "#", "Справа");
//  Строка = " 1234  "; ДлинаСтроки = 10; Символ = "#"; Режим = "Справа"
//  Возвращает: "1234######".
//
Функция ДополнитьСтроку(Знач Значение, Знач ДлинаСтроки, Знач Символ = "0", Знач Режим = "СЛЕВА") Экспорт
	
	// Длина символа не должна превышать единицы.
	Символ = Лев(Символ, 1);
	
	// Удаляем крайние пробелы слева и справа строки.
	Значение = СокрЛП(Значение);
	КоличествоСимволовНадоДобавить = ДлинаСтроки - СтрДлина(Значение);
	
	Если КоличествоСимволовНадоДобавить > 0 Тогда
		
		СтрокаДляДобавления = СформироватьСтрокуСимволов(Символ, КоличествоСимволовНадоДобавить);
		
		ВРегРежим = ВРег(Режим);
		Если ВРегРежим = "СЛЕВА" Тогда Значение = СтрокаДляДобавления + Значение; ИначеЕсли ВРегРежим = "СПРАВА" Тогда Значение = Значение + СтрокаДляДобавления; КонецЕсли;
		
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Формирует строку повторяющихся символов заданной длины.
//
// Параметры:
//  Символ      - Строка - символ, из которого будет формироваться строка.
//  ДлинаСтроки - Число  - требуемая длина результирующей строки.
//
// Возвращаемое значение:
//  Строка - строка, состоящая из повторяющихся символов.
//
Функция СформироватьСтрокуСимволов(Знач Символ, Знач ДлинаСтроки) Экспорт
	
	Результат = "";
	Для Счетчик = 1 По ДлинаСтроки Цикл Результат = Результат + Символ; КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Проверяет, является ли строка заполненным уникальным идентификатором.
// 
// Параметры:
//  СтрокаДляПроверки - Строка - Уникальный идентификатор в виде строки
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоПустойУникальныйИдентификатор(Знач СтрокаДляПроверки) Экспорт
	
	Возврат Не ЭтоУникальныйИдентификатор(СтрокаДляПроверки) Или СокрЛП(СтрокаДляПроверки) = "00000000-0000-0000-0000-000000000000";
	
КонецФункции

// Преобразует исходную строку в дату. 
// Если дату не удалось распознать, то возвращается пустая дата (01.01.01 00:00:00).
//
// Параметры:
//  Значение - Строка - строка, которую необходимо привести к дате.
//                      Формат даты должен быть в виде "ДД.ММ.ГГГГ" или "ДД/ММ/ГГ" или "ДД-ММ-ГГ ЧЧ:ММ:CC",
//                      Например, "23.02.1980" или "23/02/80 09:15:45".
//  ЧастьДаты - Неопределено, ЧастиДаты - определяет допустимые части даты. По умолчанию, ЧастиДаты.Дата.
// 
// Возвращаемое значение:
//  Дата - полученная дата.
//
Функция СтрокаВДату(Знач Значение, Знач ЧастьДаты = Неопределено) Экспорт
	
	НаборЦифр = Спец_КонстантыКлиентСервер.ВсеЦифры();
	
	Если ТипЗнч(ЧастьДаты) <> Тип("ЧастиДаты") Тогда
		ЧастьДаты = ЧастиДаты.Дата;
	КонецЕсли;
	
	ПараметрыДаты = Новый КвалификаторыДаты(ЧастьДаты);
	ОписаниеТипаДата = Новый ОписаниеТипов("Дата",,, ПараметрыДаты);
	
	Значение = ВРег(СтрСоединить(СтрРазделить(СокрЛП(Значение), Символы.НПП + Символы.ПС + Символы.Таб), " "));
	Результат = ОписаниеТипаДата.ПривестиЗначение(Значение);
	
	Для НомерМесяца = 1 По 12 Цикл
		Значение = СтрЗаменить(Значение, ВРег(Формат(Дата(1, НомерМесяца, 2), "ДФ=MMММ")), Формат(НомерМесяца, "ЧЦ=2; ЧВН="));
		Значение = СтрЗаменить(Значение, ВРег(Формат(Дата(1, НомерМесяца, 2), "ДФ=MMM")), Формат(НомерМесяца, "ЧЦ=2; ЧВН="));
	КонецЦикла;
	
	МассивНеЦифр = СтрРазделить(Значение, НаборЦифр);
	Если МассивНеЦифр.Количество() < 2 Тогда
		Возврат Результат;
	КонецЕсли;
	
	ПозицияПервойЦифры = СтрДлина(МассивНеЦифр[0]);
	ПозицияПоследнейЦифры = СтрДлина(Значение) - СтрДлина(МассивНеЦифр[МассивНеЦифр.ВГраница()]);
	Значение = Сред(Значение, ПозицияПервойЦифры, ПозицияПоследнейЦифры - ПозицияПервойЦифры);
	Если ПустаяСтрока(Значение) Тогда
		Возврат Результат;
	КонецЕсли;
	
	ЗначениеМассивом = СтрРазделить(Значение, " ");
	Элемент = ЗначениеМассивом[ЗначениеМассивом.ВГраница()];
	Если ЗначениеМассивом.Количество() > 1 Тогда
		Если СтрДлина(Элемент) = 2 Или СтрДлина(Элемент) = 4 Тогда
			
			ЭтоТолькоЦифры = СтрРазделить(Элемент, НаборЦифр, Ложь).Количество() = 0;
			Если ЭтоТолькоЦифры Тогда
				ЗначениеДата = Значение;
				ЗначениеВремя = "";
			Иначе
				ЗначениеВремя = Элемент;
				ЗначениеМассивом.Удалить(ЗначениеМассивом.ВГраница());
				ЗначениеДата = СтрСоединить(ЗначениеМассивом, " ");
			КонецЕсли;
		Иначе
			
			ЗначениеВремя = Элемент;
			ЗначениеМассивом.Удалить(ЗначениеМассивом.ВГраница());
			ЗначениеДата = СтрСоединить(ЗначениеМассивом, " ");
		КонецЕсли;
	Иначе
		
		ЭтоТолькоЦифры = СтрРазделить(Элемент, НаборЦифр, Ложь).Количество() = 0;
		Если ЭтоТолькоЦифры Тогда
			
			Результат = ОписаниеТипаДата.ПривестиЗначение(Элемент);
			Если Не ЗначениеЗаполнено(Результат) Тогда
				
				Если СтрДлина(Элемент) = 6 Тогда
				
					ПеревернутаяДата  = Сред(Элемент, 5) + Сред(Элемент, 3, 2) + Лев(Элемент, 2);
					Год = СтрокаВЧисло(Лев(ПеревернутаяДата, 2));
					Если Год <> Неопределено Тогда
						ПеревернутаяДата = ?(Год > 29, "19", "20") + ПеревернутаяДата;
						Результат = ОписаниеТипаДата.ПривестиЗначение(ПеревернутаяДата);
					КонецЕсли;
					
				ИначеЕсли СтрДлина(Элемент) > 7 Тогда
					
					ПеревернутаяДата  = Сред(Элемент, 5) + Сред(Элемент, 3, 2) + Лев(Элемент, 2);
					Результат = ОписаниеТипаДата.ПривестиЗначение(ПеревернутаяДата);
					
				КонецЕсли;
				
			КонецЕсли;
			
			Возврат Результат;
			
		ИначеЕсли СтрНайти(Элемент, ":") > 0 Тогда
			
			ЗначениеДата = "";
			ЗначениеВремя = Элемент;
		Иначе
			ЗначениеДата = Элемент;
			ЗначениеВремя = "";
		КонецЕсли;
	КонецЕсли;
	
	ОписаниеТипаЧисло = Новый ОписаниеТипов("Число");
	
	Если ЗначениеЗаполнено(ЗначениеДата) И ЧастьДаты <> ЧастиДаты.Время Тогда
		
		НаборРазделителей = СтрСоединить(СтрРазделить(ЗначениеДата, НаборЦифр, Ложь), "");
		ЗначениеДатаМассивом = СтрРазделить(ЗначениеДата, НаборРазделителей, Ложь);
		
		ЭтоТолькоЦифры = СтрРазделить(ЗначениеДата, НаборЦифр, Ложь).Количество() = 0;
		Если НЕ ЭтоТолькоЦифры Тогда
			
			Год   = 1;
			Месяц = 1;
			День  = 1;
			
			Если СтрДлина(ЗначениеДатаМассивом[0]) = 4 Тогда
				Год = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеДатаМассивом[0]); // Число
				ГодВНачале = Истина;
			Иначе
				День = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеДатаМассивом[0]); // Число
				ГодВНачале = Ложь;
			КонецЕсли;
			
			Если ЗначениеДатаМассивом.Количество() = 2 Тогда
				Месяц = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеДатаМассивом[1]);; // Число
			ИначеЕсли ЗначениеДатаМассивом.Количество() > 2 Тогда
				Месяц = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеДатаМассивом[1]); // Число
				Если ГодВНачале Тогда
					День = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеДатаМассивом[2]);
				Иначе
					Год = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеДатаМассивом[2]);
				КонецЕсли;
			КонецЕсли;
			
			// ХЗ что это, это типовая функция
			//@skip-check invocation-parameter-type-intersect
			Если СтрДлина(Год) < 3 Тогда
				ГодЧислом = ОписаниеТипаЧисло.ПривестиЗначение(Год);
				Год = ?(ГодЧислом < 30, 2000, 1900) + ГодЧислом;
			Иначе
				Год = ОписаниеТипаЧисло.ПривестиЗначение(Год);
			КонецЕсли;
			
			ЗначениеДата = Формат(Год, "ЧЦ=4; ЧН=0001; ЧВН=; ЧГ=0")
				+ Формат(Месяц, "ЧЦ=2; ЧН=01; ЧВН=; ЧГ=0")
				+ Формат(День, "ЧЦ=2; ЧН=01; ЧВН=; ЧГ=0");
		Иначе
			
			Если СтрДлина(ЗначениеДата) = 6 Тогда
				
				Год = Прав(ЗначениеДата, 2);
				ГодЧислом = ОписаниеТипаЧисло.ПривестиЗначение(Год);
				ЗначениеДата = Строка(?(ГодЧислом < 30, 2000, 1900)) + Год + Сред(ЗначениеДата, 3, 2) + Лев(ЗначениеДата, 2) ;
				
			ИначеЕсли СтрДлина(ЗначениеДата) = 8 Тогда
				
				Результат = ОписаниеТипаДата.ПривестиЗначение(ЗначениеДата);
				
				Если Не ЗначениеЗаполнено(Результат) Тогда
					ПеревернутаяДата  = Сред(ЗначениеДата, 5) + Сред(ЗначениеДата, 3, 2) + Лев(ЗначениеДата, 2);
					Результат = ОписаниеТипаДата.ПривестиЗначение(ПеревернутаяДата);
					Если ЗначениеЗаполнено(Результат) Тогда
						ЗначениеДата = ПеревернутаяДата;
					КонецЕсли;
				КонецЕсли;
			
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		ЗначениеДата = "00010101";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ЗначениеВремя) И ЧастьДаты <> ЧастиДаты.Дата Тогда
		
		ЭтоТолькоЦифры = СтрРазделить(ЗначениеВремя, НаборЦифр, Ложь).Количество() = 0;
		Если НЕ ЭтоТолькоЦифры Тогда
			
			НаборРазделителей = СтрСоединить(СтрРазделить(ЗначениеВремя, НаборЦифр, Ложь), "");
			ЗначениеВремяМассивом = СтрРазделить(ЗначениеВремя, НаборРазделителей, Ложь);
			
			Час     = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеВремяМассивом[0]); // Число
			Минута  = 0;
			Секунда = 0;
			
			Если ЗначениеВремяМассивом.Количество() = 2 Тогда
				Минута = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеВремяМассивом[1]); // Число
			ИначеЕсли ЗначениеВремяМассивом.Количество() > 2 Тогда
				Минута = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеВремяМассивом[1]); // Число
				Секунда = ОписаниеТипаЧисло.ПривестиЗначение(ЗначениеВремяМассивом[2]); // Число
			КонецЕсли;
			
			ШаблонФормата = "ЧЦ=2; ЧН=00; ЧВН=; ЧГ=0";
			ЗначениеВремя = Формат(Час, ШаблонФормата)
				+ Формат(Минута, ШаблонФормата)
				+ Формат(Секунда, ШаблонФормата);
				
		КонецЕсли;
		
	Иначе
		ЗначениеВремя = "000000";
	КонецЕсли;
	
	Результат = ОписаниеТипаДата.ПривестиЗначение(ЗначениеДата + ЗначениеВремя);
	
	Возврат Результат;
	
КонецФункции

// Преобразует исходную строку в число без вызова исключений.
//
// Параметры:
//   Значение - Строка - строка, которую необходимо привести к числу.
//                       Например, "10", "+10", "010", вернет 10;
//                                 "(10)", "-10",вернет -10;
//                                 "10,2", "10.2",вернет 10.2;
//                                 "000", " ", "",вернет 0;
//                                 "10текст", вернет Неопределено.
//
// Возвращаемое значение:
//   Число, Неопределено - полученное число, либо Неопределено, если строка не является числом.
//
Функция СтрокаВЧисло(Знач Значение) Экспорт
	
	Значение = СтрЗаменить(Значение, " ", "");
	Если СтрНачинаетсяС(Значение, "(") Тогда Значение = СтрЗаменить(Значение, "(", "-"); Значение = СтрЗаменить(Значение, ")", ""); КонецЕсли;
	
	НачинаетсяСМинуса = СтрНачинаетсяС(Значение, "-");
	ЛишниеСимволы     = СтрСоединить(СтрРазделить(Значение, "0123456789,."), "");
	Значение          = ?(НачинаетсяСМинуса, "-", "") + СтрСоединить(СтрРазделить(Значение, ЛишниеСимволы), "");
	
	СтрокаБезНулей = СтрЗаменить(Значение, "0", "");
	Если ПустаяСтрока(СтрокаБезНулей) Или СтрокаБезНулей = "-" Тогда Возврат 0; КонецЕсли;
	
	ТипЧисло = Новый ОписаниеТипов("Число");
	Результат = ТипЧисло.ПривестиЗначение(Значение);
	Возврат ?(Результат <> 0 И Не ПустаяСтрока(СтрокаБезНулей), Результат, Неопределено);
	
КонецФункции

// Проверяет, является ли строка уникальным идентификатором.
// В качестве уникального идентификатора предполагается строка вида
// "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX", где X = [0..9,a..f].
//
// Параметры:
//  Значение - Строка - проверяемая строка.
//
// Возвращаемое значение:
//  Булево - Истина, если переданная строка является уникальным идентификатором.
//
Функция ЭтоУникальныйИдентификатор(Знач Значение) Экспорт
	
	Шаблон = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
	
	Если СтрДлина(Шаблон) <> СтрДлина(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;
	Для Позиция = 1 По СтрДлина(Значение) Цикл
		Если КодСимвола(Шаблон, Позиция) = 88 // X
			И ((КодСимвола(Значение, Позиция) < 48 Или КодСимвола(Значение, Позиция) > 57) // 0..9
				И (КодСимвола(Значение, Позиция) < 97 Или КодСимвола(Значение, Позиция) > 102) // a..f
				И (КодСимвола(Значение, Позиция) < 65 Или КодСимвола(Значение, Позиция) > 70)) // A..F
			Или КодСимвола(Шаблон, Позиция) = 45 И КодСимвола(Значение, Позиция) <> 45 Тогда // -
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Метод для поиска похожих строк в массиве строк (через расстояние Левенштейна).
// 
// Параметры:
//  ИсходныйМассивСтрок - Массив из Строка - Массив строк, в котором ищем похожие
//  СтрокаДляПоиска - Строка - Строка для поиска похожей
//  ПроцентДлиныСтрокиДляРезультата - Число - Процент длины строки с ошибкой
//  СтруктураПараметровДляПоискаЛевенштейна - Неопределено, Структура - Параметры рассчёта расстояния Левенштейна:
//  	* ЦенаУдаления - Число - По умолчанию 1
//  	* ЦенаДобавления - Число - По умолчанию 1
//  	* ЦенаЗамены - Число - По умолчанию 1
//  	* УчитыватьРегистр - Булево - Флаг того, будет ли учитываться регистр слов при расчёте (по умолчанию ЛОЖЬ)
// 
// Возвращаемое значение:
//  - Массив из Строка - Массив похожих строк
//	- Строка - Если найдена точно такая же строка
//
Функция НайтиТочнуюИлиПохожиеСтрокиВМассивеСтрок(Знач ИсходныйМассивСтрок, Знач СтрокаДляПоиска,
		Знач ПроцентДлиныСтрокиДляРезультата = 30, Знач СтруктураПараметровДляПоискаЛевенштейна = Неопределено) Экспорт
	
	МаксимальноеРасстояниеЛевенштейна = Цел(СтрДлина(СтрокаДляПоиска) / 100 * ПроцентДлиныСтрокиДляРезультата);
	ЦенаУдаления                      = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураПараметровДляПоискаЛевенштейна, "ЦенаУдаления"     , 1); // Число
	ЦенаДобавления                    = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураПараметровДляПоискаЛевенштейна, "ЦенаДобавления"   , 1); // Число
	ЦенаЗамены                        = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураПараметровДляПоискаЛевенштейна, "ЦенаЗамены"       , 1); // Число 
	УчитыватьРегистр                  = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураПараметровДляПоискаЛевенштейна, "УчитыватьРегистр" , Ложь); // Булево
	
	МассивРезультат = НовыйМассивРезультатПоискаПохожихСтрок();
	Для Каждого ИсходнаяСтрокаДляПоиска Из ИсходныйМассивСтрок Цикл
		
		РасстояниеЛевенштейна = РасстояниеДамерауЛевенштейна(ИсходнаяСтрокаДляПоиска, СтрокаДляПоиска, ЦенаУдаления, ЦенаДобавления, ЦенаЗамены, УчитыватьРегистр);
		Если РасстояниеЛевенштейна = 0 Тогда
			Возврат ИсходнаяСтрокаДляПоиска;
		ИначеЕсли РасстояниеЛевенштейна <= МаксимальноеРасстояниеЛевенштейна Тогда
			МассивРезультат.Добавить(НоваяСтруктураРезультатаДляПоискаПохожихСтрок(ИсходнаяСтрокаДляПоиска, РасстояниеЛевенштейна));
		КонецЕсли;
		
	КонецЦикла;
	
	Спец_РаботаСКоллекциямиКлиентСервер.СортироватьМассивСтруктурПоКлючу(МассивРезультат, "РасстояниеЛевенштейна", НаправлениеСортировки.Убыв);
	Возврат Спец_РаботаСКоллекциямиКлиентСервер.ВыгрузитьМассивЗначений(МассивРезультат, "СтрокаРезультат");
	
КонецФункции

// Расстояние Дамерау-Левенштейна.
// 
// Параметры:
//  ПерваяСтрока - Строка - Первая строка
//  ВтораяСтрока - Строка - Вторая строка
//  ЦенаУдаления - Число - Цена удаления
//  ЦенаДобавления - Число - Цена добавления
//  ЦенаЗамены - Число - Цена замены
//  УчитыватьРегистр - Булево - Учитывать регистр
// 
// Возвращаемое значение:
//  Число
//  
//@skip-check invocation-parameter-type-intersect
Функция РасстояниеДамерауЛевенштейна(Знач ПерваяСтрока, Знач ВтораяСтрока, Знач ЦенаУдаления = 1, Знач ЦенаДобавления = 1,
		Знач ЦенаЗамены = 1, Знач УчитыватьРегистр = Ложь) Экспорт
	
	Если Не УчитыватьРегистр Тогда ПерваяСтрока = ВРег(ПерваяСтрока); ВтораяСтрока = ВРег(ВтораяСтрока); КонецЕсли;
	
	ДлинаСтроки1 = СтрДлина(ПерваяСтрока);
	ДлинаСтроки2 = СтрДлина(ВтораяСтрока);
	
	Если ДлинаСтроки1 = 0 Тогда Возврат ДлинаСтроки2; ИначеЕсли ДлинаСтроки2 = 0 Тогда Возврат ДлинаСтроки1; КонецЕсли;
	
	МатрицаРасстояний = Новый Массив(ДлинаСтроки1 + 1, ДлинаСтроки2 + 1);
	Для i = 0 По ДлинаСтроки1 Цикл МатрицаРасстояний[i][0] = i; КонецЦикла;
	Для j = 0 По ДлинаСтроки2 Цикл МатрицаРасстояний[0][j] = j; КонецЦикла;
	Для i = 1 По ДлинаСтроки1 Цикл Для j = 1 По ДлинаСтроки2 Цикл МатрицаРасстояний[i][j] = Мин(МатрицаРасстояний[i - 1][j] + ЦенаУдаления, МатрицаРасстояний[i][j - 1] + ЦенаДобавления, МатрицаРасстояний[i - 1][j - 1] + ?(Сред(ПерваяСтрока, i, 1) <> Сред(ВтораяСтрока, j, 1), ЦенаЗамены, 0)); Если i > 1 И j > 1 И Сред(ПерваяСтрока, i, 1) = Сред(ВтораяСтрока, j - 1, 1) И Сред(ПерваяСтрока, i - 1, 1) = Сред(ВтораяСтрока, j, 1) Тогда МатрицаРасстояний[i][j] = Мин(МатрицаРасстояний[i][j], МатрицаРасстояний[i - 2][j - 2] + ?(Сред(ПерваяСтрока, i, 1) <> Сред(ВтораяСтрока, j, 1), ЦенаЗамены, 0)); КонецЕсли; КонецЦикла; КонецЦикла;
	
	Возврат МатрицаРасстояний[ДлинаСтроки1][ДлинаСтроки2];
	
КонецФункции

// Преобразует исходную строку в транслит.
// Может использоваться для отправки SMS-сообщений латиницей или для сохранения
// файлов и папок, чтобы обеспечить возможность их переноса между разными операционными системами.
// Обратное преобразование из латинских символов не предусмотрено.
//
// Параметры:
//  СтрокаДляОбработки - Строка - произвольная строка.
//
// Возвращаемое значение:
//  Строка - строка, в которой кириллица заменена на транслит.
//
Функция СтрокаЛатиницей(Знач СтрокаДляОбработки) Экспорт
	
	ПравилаТранслитерации = Новый Соответствие();
	
	ПравилаТранслитерации.Вставить("а","a");
	ПравилаТранслитерации.Вставить("б","b");
	ПравилаТранслитерации.Вставить("в","v");
	ПравилаТранслитерации.Вставить("г","g");
	ПравилаТранслитерации.Вставить("д","d");
	ПравилаТранслитерации.Вставить("е","e");
	ПравилаТранслитерации.Вставить("ё","e"); // АПК:163 требуется транслитерация.
	ПравилаТранслитерации.Вставить("ж","zh");
	ПравилаТранслитерации.Вставить("з","z");
	ПравилаТранслитерации.Вставить("и","i");
	ПравилаТранслитерации.Вставить("й","y");
	ПравилаТранслитерации.Вставить("к","k");
	ПравилаТранслитерации.Вставить("л","l");
	ПравилаТранслитерации.Вставить("м","m");
	ПравилаТранслитерации.Вставить("н","n");
	ПравилаТранслитерации.Вставить("о","o");
	ПравилаТранслитерации.Вставить("п","p");
	ПравилаТранслитерации.Вставить("р","r");
	ПравилаТранслитерации.Вставить("с","s");
	ПравилаТранслитерации.Вставить("т","t");
	ПравилаТранслитерации.Вставить("у","u");
	ПравилаТранслитерации.Вставить("ф","f");
	ПравилаТранслитерации.Вставить("х","kh");
	ПравилаТранслитерации.Вставить("ц","ts");
	ПравилаТранслитерации.Вставить("ч","ch");
	ПравилаТранслитерации.Вставить("ш","sh");
	ПравилаТранслитерации.Вставить("щ","shch");
	ПравилаТранслитерации.Вставить("ъ",""); // Пропускается.
	ПравилаТранслитерации.Вставить("ы","y");
	ПравилаТранслитерации.Вставить("ь",""); // Пропускается.
	ПравилаТранслитерации.Вставить("э","e");
	ПравилаТранслитерации.Вставить("ю","yu");
	ПравилаТранслитерации.Вставить("я","ya");
	
	Результат = "";
	ТолькоЗаглавныеВСтроке = ТолькоЗаглавныеВСтроке(СтрокаДляОбработки);
	
	Для Позиция = 1 По СтрДлина(СтрокаДляОбработки) Цикл
		
		Символ = Сред(СтрокаДляОбработки, Позиция, 1);
		
		СимволЛатиницей = ПравилаТранслитерации[НРег(Символ)]; // Поиск соответствия без учета регистра.
		Если СимволЛатиницей = Неопределено Тогда
			// Другие символы остаются "как есть".
			СимволЛатиницей = Символ;
		Иначе
			Если ТолькоЗаглавныеВСтроке Тогда 
				СимволЛатиницей = ВРег(СимволЛатиницей); // восстанавливаем регистр
			ИначеЕсли Символ = ВРег(Символ) Тогда
				СимволЛатиницей = ТРег(СимволЛатиницей); // восстанавливаем регистр
			КонецЕсли;
		КонецЕсли;
		
		Результат = Результат + СимволЛатиницей;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Очищает текст от лишних символов и оставляет только цифры в ней.
// 
// Параметры:
//  СтрокаДляОбработки - Строка - Строка для преобразования
// 
// Возвращаемое значение:
//  Строка
//
Функция ОставитьТолькоЦифрыВСтроке(Знач СтрокаДляОбработки) Экспорт
	
	Возврат ОставитьТолькоНужныеСимволыВСтроке(СтрокаДляОбработки, Спец_КонстантыКлиентСервер.ВсеЦифры());
	
КонецФункции

// Заменяет недопустимые символы в XML-строке на заданные символы.
//
// Параметры:
//   Текст - Строка - строка, в которой требуется выполнить замену недопустимых символов.
//   СимволЗамены - Строка - строка, на которую требуется выполнить замену недопустимого символа в XML-строке.
// 
// Возвращаемое значение:
//    Строка - строка, полученная заменой недопустимых символов в XML-строке.
//
Функция ЗаменитьНедопустимыеСимволыXML(Знач Текст, Знач СимволЗамены = " ") Экспорт
	
	// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
	Если СимволЗамены = "" Тогда Возврат УдалитьНедопустимыеСимволыXMLПрограммно(Текст); КонецЕсли;
	// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
	
	Если ПустаяСтрока(Текст) Тогда Возврат Текст; КонецЕсли;
	
#Если Не ВебКлиент Тогда
	
	ПозицияНачала = 1;
	
	// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
	Позиция = ОбработкаСтрокиXML.НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала, "1.1");
	// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
	// ++ Спец_БСП.Версия1С_20_Ниже
	////Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
	// -- Спец_БСП.Версия1С_20_Ниже
	Пока Позиция > 0 Цикл
		
		Текст = СтрЗаменить(Текст, Сред(Текст, Позиция, 1), СимволЗамены);
		ПозицияНачала = Позиция + СтрДлина(СимволЗамены);
		Если ПозицияНачала > СтрДлина(Текст) Тогда
			Прервать;
		КонецЕсли;
		
		// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
		Позиция = ОбработкаСтрокиXML.НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала, "1.1");
		// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
		// ++ Спец_БСП.Версия1С_20_Ниже
		////Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
		// -- Спец_БСП.Версия1С_20_Ниже
		
	КонецЦикла;
	
	Возврат Текст;
	
#Иначе
	
	// Коды символов от 0 до 2^16-1, которые метод НайтиНедопустимыеСимволыXML
	// считает недопустимыми: 0-8, 11-12, 14-31, 55296-57343.
	Итог = "";
	
	// Косяк EDT
	//@skip-check invocation-parameter-type-intersect 
	Для НомерСимвола = 1 По СтрДлина(Текст) Цикл
		
		Символ = Сред(Текст, НомерСимвола, 1);
		КодСимвола = КодСимвола(Символ);
		Если КодСимвола < 9
			Или КодСимвола > 10    И КодСимвола < 13
			Или КодСимвола > 13    И КодСимвола < 32
			Или КодСимвола > 55295 И КодСимвола < 57344 Тогда
			
			Символ = СимволЗамены;
		КонецЕсли;
		
		Итог = Итог + Символ;
		
	КонецЦикла;
	
	Возврат Итог;
	
#КонецЕсли
	
КонецФункции

// Удаляет недопустимые символы в XML-строке.
//
// Параметры:
//  Текст - Строка - строка, в которой требуется удалить недопустимые символы.
// 
// Возвращаемое значение:
//  Строка - строка, полученная при удалении недопустимых символов в XML-строке.
Функция УдалитьНедопустимыеСимволыXMLПрограммно(Знач Текст) Экспорт
	
	// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
	Возврат ?(ПустаяСтрока(Текст), Текст, ОбработкаСтрокиXML.УдалитьНедопустимыеСимволыXML(Текст, "1.1"));
	// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_20_Ниже
	////Возврат ?(ПустаяСтрока(Текст), Текст, ЗаменитьНедопустимыеСимволыXML(Текст, ""));
	// -- Спец_БСП.Версия1С_20_Ниже
	
КонецФункции

// Параметры:
//  IPДляПроверки - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоНеЛокальныйЧисловойIP(Знач IPДляПроверки, Кэш = Неопределено) Экспорт
	
	Возврат Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению(
					IPДляПроверки,
					"^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$",
					Кэш)
			И Не СтрНачинаетсяС(IPДляПроверки, "127.0.");
	
КонецФункции

// 1С-кая реализация (не работают PERL, многострочные проверки, и т.п.)
// (см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению)
//	
// Параметры:
//  СтрокаДляПроверки - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению.СтрокаДляПроверки
//  РегулярноеВыражение - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению.РегулярноеВыражение
// 
// Возвращаемое значение:
//  Булево - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению
//
Функция СтрокаСоответствуетРегулярномуВыражению(Знач СтрокаДляПроверки, Знач РегулярноеВыражение) Экспорт
	
#Если Не ВебКлиент Тогда
	
    Попытка
        
        ПаттернДляПроверки = СформироватьОбъектXDTOДляПроверкиРегулярногоВыражения(РегулярноеВыражение);
        ПаттернДляПроверки.TestItem = СтрокаДляПроверки;
        
        Возврат Истина;
        
    Исключение
        
        Возврат Ложь;
        
    КонецПопытки;
	
#Иначе
	
	Возврат Спец_СтроковыеФункцииВызовСервера.СтрокаСоответствуетРегулярномуВыражению(СтрокаДляПроверки, РегулярноеВыражение);
	
#КонецЕсли
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Параметры:
//  СтрокаДляОбработки - Строка
//  СимволыКоторыеНеТрогать - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ОставитьТолькоНужныеСимволыВСтроке(Знач СтрокаДляОбработки, Знач СимволыКоторыеНеТрогать) Экспорт
	
	Возврат СтрСоединить(СтрРазделить(СтрокаДляОбработки, СтрСоединить(СтрРазделить(СтрокаДляОбработки, СимволыКоторыеНеТрогать), "")), "");
	
КонецФункции

// Параметры:
//  НужноеИмя - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ОчиститьИмяДляЗапроса(Знач НужноеИмя) Экспорт
	
	ЧистыйАлфавит = Спец_КонстантыКлиентСервер.АнглийскийАлфавит() + Спец_КонстантыКлиентСервер.РусскийАлфавит()
			+ НРег(Спец_КонстантыКлиентСервер.АнглийскийАлфавит() + Спец_КонстантыКлиентСервер.РусскийАлфавит())
			+ Спец_КонстантыКлиентСервер.ВсеЦифры()
			+ "_";
	
	Результат = ОставитьТолькоНужныеСимволыВСтроке(НужноеИмя, ЧистыйАлфавит);
	Если СтрНачинаетсяС(Результат, "0")
			Или СтрНачинаетсяС(Результат, "1")
			Или СтрНачинаетсяС(Результат, "2")
			Или СтрНачинаетсяС(Результат, "3")
			Или СтрНачинаетсяС(Результат, "4")
			Или СтрНачинаетсяС(Результат, "5")
			Или СтрНачинаетсяС(Результат, "6")
			Или СтрНачинаетсяС(Результат, "7")
			Или СтрНачинаетсяС(Результат, "8")
			Или СтрНачинаетсяС(Результат, "9") Тогда
				
		Результат = "_" + Результат;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ТекстЗапроса - Строка
// 
// Возвращаемое значение:
//  Булево
//
Функция ЕстьКакоеЛибоУсловиеВЗапросе(Знач ТекстЗапроса) Экспорт
	
	Возврат СтрНайти(ТекстЗапроса, "ГДЕ ") > 0 Или СтрНайти(ТекстЗапроса, "ГДЕ" + Символы.ПС) > 0
			Или СтрНайти(ТекстЗапроса, "WHERE ") > 0 Или СтрНайти(ТекстЗапроса, "WHERE" + Символы.ПС) > 0;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Параметры:
//  СтрокаДляПроверки - Строка
// 
// Возвращаемое значение:
//  Булево
//
Функция ТолькоЗаглавныеВСтроке(Знач СтрокаДляПроверки)
	
	Для Позиция = 1 По СтрДлина(СтрокаДляПроверки) Цикл Символ = Сред(СтрокаДляПроверки, Позиция, 1); Если Символ <> ВРег(Символ) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
	Возврат Истина;
	
КонецФункции

#Если Не ВебКлиент Тогда

// Параметры:
//  РегулярноеВыражение - см. СтрокаСоответствуетРегулярномуВыражению.РегулярноеВыражение
// 
// Возвращаемое значение:
//	ЗначениеXDTO:
//		* TestItem - Строка
//
Функция СформироватьОбъектXDTOДляПроверкиРегулярногоВыражения(Знач РегулярноеВыражение)
	
	XDTOШаблон = СтрШаблон(
			
			"<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
			|	<package targetNamespace=""sample-my-package"">
			|		<valueType name=""testtypes"" base=""xs:string"">
			|			<pattern>%1</pattern>
			|		</valueType>
			|		<objectType name=""TestObj"">
			|			<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes"" />
			|		</objectType>
			|	</package>
			|</Model>",
			
			СтрЗаменить(РегулярноеВыражение, "&", "&amp;"));
			
	
	ЧтениеXML = Новый ЧтениеXML();
    ЧтениеXML.УстановитьСтроку(XDTOШаблон);
	МодельXDTOДляЧтения = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	МояФабрикаXDTO = Новый ФабрикаXDTO(МодельXDTOДляЧтения);
		
    ПакетДляПроверки = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Возврат МояФабрикаXDTO.Создать(ПакетДляПроверки.Получить("TestObj"));
	
КонецФункции

#КонецЕсли

#Область Типизация

// Возвращаемое значение:
//  Массив из см. НоваяСтруктураРезультатаДляПоискаПохожихСтрок
//
Функция НовыйМассивРезультатПоискаПохожихСтрок()
		
	Возврат Новый Массив();
		
КонецФункции

// Параметры:
//  СтрокаРезультат - Строка
//  РасстояниеЛевенштейна - Число
// 
// Возвращаемое значение:
//  Структура:
// * СтрокаРезультат - Строка
// * РасстояниеЛевенштейна - Число
//
Функция НоваяСтруктураРезультатаДляПоискаПохожихСтрок(Знач СтрокаРезультат, Знач РасстояниеЛевенштейна)
	
	Возврат Новый Структура("СтрокаРезультат, РасстояниеЛевенштейна", СтрокаРезультат, РасстояниеЛевенштейна);
	
КонецФункции

#КонецОбласти

#КонецОбласти
