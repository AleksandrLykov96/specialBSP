// @strict-types

//@skip-check method-too-many-params

#Область ПрограммныйИнтерфейс

// Преобразует двоичные данные в строку формата Base64
// 
// Параметры:
//  ДанныеДляОбработки - ДвоичныеДанные - Данные для обработки
// 
// Возвращаемое значение:
//  Строка - Двоичные данные в строку base64
//
Функция ПреобразоватьДвоичныеДанныеВСтрокуBase64(Знач ДанныеДляОбработки) Экспорт
	
	// Попадает любой из переносов строки, поэтому заменим все возможные варианты на всякий случай.
	Возврат УбратьЛишниеПропускиСтрок(Base64Строка(ДанныеДляОбработки));
	
КонецФункции

// Метод убирает все возможные символы переноса строк
// 
// Параметры:
//  ДанныеДляОчистки - Строка - Строка для очистки
// 
// Возвращаемое значение:
//  Строка
//
Функция УбратьЛишниеПропускиСтрок(Знач ДанныеДляОчистки) Экспорт
	
	Возврат СокрЛП(
		СтрЗаменить(
			СтрЗаменить(
				СтрЗаменить(
					СтрЗаменить(ДанныеДляОчистки, Символ(182), ""),
				Символ(13), ""),
			Символы.ВК, ""),
		Символы.ПС, ""));
	
КонецФункции

// Метод для добавления строки в текст
// 
// Параметры:
//  СтрокаДляДобавления - Строка - Добавляемая строка
//  ОбщийТекст - Строка - Текст, в который нужно добавить строку
//  Разделитель - Строка - Разделитель между текстом и добавляемой строкой
//
Процедура ДобавитьСтрокуВТекст(Знач СтрокаДляДобавления, ОбщийТекст, Знач Разделитель = ", ") Экспорт
	
	СтрокаДляДобавления = Строка(СтрокаДляДобавления);
	Если Не ПустаяСтрока(СтрокаДляДобавления) Тогда ОбщийТекст = ?(ПустаяСтрока(ОбщийТекст), СтрокаДляДобавления, ОбщийТекст + Разделитель + СтрокаДляДобавления); КонецЕсли;
	
КонецПроцедуры

// Разбивает строку на несколько строк по указанному разделителю. Разделитель может иметь любую длину.
// В случаях, когда разделителем является строка из одного символа, и не используется параметр СокращатьНепечатаемыеСимволы,
// рекомендуется использовать функцию платформы СтрРазделить.
//
// Параметры:
//  Значение               - Строка - текст с разделителями.
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ.
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     > для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат;
//     > если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//  СокращатьНепечатаемыеСимволы - Булево - сокращать непечатаемые символы по краям каждой из найденных подстрок.
//
// Возвращаемое значение:
//  Массив из Строка
//
// Пример:
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",")
//  - возвратит массив из 5 элементов, три из которых  - пустые: "", "один", "", "два", "";
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина)
//  - возвратит массив из двух элементов: "один", "два";
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(" один   два  ", " ")
//  - возвратит массив из двух элементов: "один", "два";
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("")
//  - возвратит пустой массив;
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("",,Ложь)
//  - возвратит массив с одним элементом: ""(пустая строка);
//  Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("", " ")
//  - возвратит массив с одним элементом: "" (пустая строка).
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Значение, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено, 
	СокращатьНепечатаемыеСимволы = Ложь) Экспорт
	
	Если СтрДлина(Разделитель) = 1 
		И ПропускатьПустыеСтроки = Неопределено 
		И СокращатьНепечатаемыеСимволы Тогда 
		
		Результат = СтрРазделить(Значение, Разделитель, Ложь);
		Для Индекс = 0 По Результат.ВГраница() Цикл Результат[Индекс] = СокрЛП(Результат[Индекс]); КонецЦикла;
		Возврат Результат;
		
	КонецЕсли;
	
	Результат = Новый Массив; // Массив из Строка
	
	// Для обеспечения обратной совместимости.
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Значение) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = СтрНайти(Значение, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Значение, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Если СокращатьНепечатаемыеСимволы Тогда
				Результат.Добавить(СокрЛП(Подстрока));
			Иначе
				Результат.Добавить(Подстрока);
			КонецЕсли;
		КонецЕсли;
		Значение = Сред(Значение, Позиция + СтрДлина(Разделитель));
		Позиция = СтрНайти(Значение, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Значение) Тогда
		Если СокращатьНепечатаемыеСимволы Тогда
			Результат.Добавить(СокрЛП(Значение));
		Иначе
			Результат.Добавить(Значение);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

// Возвращает уникальный идентификатор в виде строки 4 версии.
// Платформенный метод может возвращать 1-й версии (*nix, версия 1С 8.3.12, на других не проверял). В данном случае метод возвратит новый UID
// средствами ОС.
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьУникальныйИдентификатор() Экспорт
	
	ИдентификаторРезультатСтартовый = Строка(Новый УникальныйИдентификатор);
	Если Сред(ИдентификаторРезультатСтартовый, 15, 1) = "4" Тогда Возврат ИдентификаторРезультатСтартовый; КонецЕсли;
	Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоLinux() Тогда
		ИдентификаторРезультат = Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы("uuidgen"); // Строка
	КонецЕсли;
	
	Если ПустаяСтрока(ИдентификаторРезультат) Тогда
		
		ИдентификаторРезультат = Сред(ИдентификаторРезультатСтартовый, 1, 14) + "4" // Номер версии
			+ Сред(ИдентификаторРезультатСтартовый, 16, 4) + "8" // Номер варианта
			+ Сред(ИдентификаторРезультатСтартовый, 21, 16);
		
	КонецЕсли;
	
	Возврат ИдентификаторРезультат;
	
КонецФункции

// Проверяет, содержит ли строка только цифры.
//
// Параметры:
//  Значение         - Строка - проверяемая строка.
//  ПробелыЗапрещены - Булево - если Ложь, то в строке допустимо наличие пробелов.
//
// Возвращаемое значение:
//   Булево - Истина - строка содержит только цифры или пустая, Ложь - строка содержит иные символы.
//
// Пример:
//  Результат = СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке("0123"); // Истина
//  Результат = СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке("0123abc"); // Ложь
//  Результат = СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке("01 2 3",, Ложь); // Истина
//
Функция ТолькоЦифрыВСтроке(Знач Значение, Знач ПробелыЗапрещены = Истина) Экспорт
	
	Если ТипЗнч(Значение) <> Тип("Строка") Тогда Возврат Ложь; КонецЕсли;
	Если Не ПробелыЗапрещены Тогда Значение = СтрЗаменить(Значение, " ", ""); КонецЕсли;
	
	Возврат ?(ПустаяСтрока(Значение),
		Истина,
		СтрДлина(
			СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(
								СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(
													Значение, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", "")) = 0);
	
КонецФункции

// Возвращает смещённый текст на переданный разделитель.
// Смещает только строки, разделённые символом ПС
// 
// Параметры:
//  ИсходныйТекст - Строка - Исходный текст
//  Разделитель - Строка - Разделитель, на который необходимо сместить текст
// 
// Возвращаемое значение:
//  Строка - Сместить весь текст на разделитель
//
Функция СместитьВесьТекстНаРазделитель(Знач ИсходныйТекст, Знач Разделитель = "	") Экспорт
	
	Возврат ?(Разделитель = "", ИсходныйТекст, Разделитель + СтрСоединить(СтрРазделить(ИсходныйТекст, Символы.ПС), Символы.ПС + Разделитель));
	
КонецФункции

// Метод формирует простое текстовое представление переданного объекта.
// Для веб-клиента вызывается сервер, поэтому значение должно быть сериализуемое.
// 
// Параметры:
//  ИсходныйОбъект - Произвольный
//  			   - ДвоичныеДанные
//  			   - Структура
//  			   - ФиксированнаяСтруктура
//  			   - Соответствие из Произвольный
//  			   - ФиксированноеСоответствие из Произвольный
//  			   - Массив из Произвольный
//  			   - ФиксированныйМассив из Произвольный
//  			   - СписокЗначений из Произвольный
//  			   - ТаблицаЗначений
//  			   - HTTPЗапрос
//  			   - HTTPОтвет
//  			   - HTTPСоединение
//  			   - ХранилищеЗначения
//  			   - ИнформацияОбОшибке
//  Смещение - Строка - Исходное смещение строки
// 
// Возвращаемое значение:
//  Строка - Текстовое представление объекта
//
Функция СформироватьТекстовоеПредставлениеОбъекта(Знач ИсходныйОбъект, Знач Смещение = "") Экспорт
	
#Если Не ВебКлиент Тогда
	
	Результат = "";
	
	ТипОбъекта = ТипЗнч(ИсходныйОбъект);
	Если ТипОбъекта = Тип("Строка") Тогда
		
		Результат = ?(ЭтоАдресВременногоХранилища(ИсходныйОбъект),
			СформироватьТекстовоеПредставлениеОбъекта(ПолучитьИзВременногоХранилища(ИсходныйОбъект)),
			СместитьВесьТекстНаРазделитель(ИсходныйОбъект, Смещение));
		
	ИначеЕсли ТипОбъекта = Тип("Число") Или ТипОбъекта = Тип("Дата") Или ТипОбъекта = Тип("Булево") Тогда
		
		Результат = СериализаторXDTO.XMLСтрока(ИсходныйОбъект);
		
	ИначеЕсли ТипОбъекта = Тип("ДвоичныеДанные") Тогда
		
		Результат = НРег(ПолучитьHexСтрокуИзДвоичныхДанных(ИсходныйОбъект));
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(ИсходныйОбъект, ТипОбъекта)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ИсходныйОбъект, ТипОбъекта) Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить(Строка(ТипОбъекта));
		
		ШаблонПоля = "%1 : %2";
		Для Каждого Значение Из ИсходныйОбъект Цикл
			
			ПредставлениеПоля = СтрШаблон(ШаблонПоля,
					СформироватьТекстовоеПредставлениеОбъекта(Значение.Ключ, Смещение + Символы.Таб),
					СформироватьТекстовоеПредставлениеОбъекта(Значение.Значение, Смещение + Символы.Таб));
			
			МассивПредставление.Добавить(ПредставлениеПоля);
			
		КонецЦикла;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИсходныйОбъект, ТипОбъекта) Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить(Строка(ТипОбъекта));
		
		Для Каждого Значение Из ИсходныйОбъект Цикл
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(Значение, Смещение + Символы.Таб));
		КонецЦикла;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли ТипОбъекта = Тип("СписокЗначений") Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить("Список значений");
		
		Для Каждого СтрокаСписка Из ИсходныйОбъект Цикл
			
			Элемент = СтрокаСписка.Представление;
			Если ПустаяСтрока(Элемент) Тогда
				Элемент = Строка(СтрокаСписка.Значение);
			КонецЕсли;
			
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(Элемент, Смещение + Символы.Таб));
			
		КонецЦикла;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ИсходныйОбъект, ТипОбъекта)
			Или ТипОбъекта = Тип("ДанныеФормыКоллекция") Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить("Таблица значений");
		
		МассивИменКолонок = Новый Массив; // Массив из Строка
		Для Каждого КолонкаТаблицы Из ИсходныйОбъект.Колонки Цикл
			МассивИменКолонок.Добавить(КолонкаТаблицы.Имя);
		КонецЦикла;
		
		ШапкаТаблицы = Символы.Таб + СокрЛП(СтрСоединить(МассивИменКолонок, " | "));
		
		МассивПредставление.Добавить(ШапкаТаблицы);
		МассивПредставление.Добавить("---------------------------------------------------------");
		
		ШаблонПоля = "%1%2) %3";
		
		i = 1;
		Для Каждого СтрокаТаблицы Из ИсходныйОбъект Цикл
			
			МассивПредставлениеСтроки = Новый Массив; // Массив из Строка
			Для Каждого КолонкаТаблицы Из ИсходныйОбъект.Колонки Цикл
				МассивПредставлениеСтроки.Добавить(СформироватьТекстовоеПредставлениеОбъекта(СтрокаТаблицы[КолонкаТаблицы.Имя]));
			КонецЦикла;
			
			ТекстСтрокиТаблицы = Символы.Таб + СтрСоединить(МассивПредставлениеСтроки, " | ");
			МассивПредставление.Добавить(СтрШаблон(ШаблонПоля, Символы.Таб, Формат(i, "ЧГ="), ТекстСтрокиТаблицы));
			
			i = i + 1;
			
		КонецЦикла;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоHTTPЗапросТип(ИсходныйОбъект, ТипОбъекта) Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		
		МассивПредставление.Добавить("HTTP запрос:");
		Если ТипОбъекта = Тип("HTTPЗапрос") Тогда
			МассивПредставление.Добавить(Символы.Таб + "Адрес запроса: " + СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.АдресРесурса));
		КонецЕсли;
		
		Если ИсходныйОбъект.Заголовки.Количество() > 0 Тогда
			
			МассивПредставление.Добавить(Символы.Таб + "Заголовки:");
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Заголовки, Смещение + Символы.Таб));
			
		КонецЕсли;
		
		ContentType = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(ИсходныйОбъект.Заголовки, "Content-Type", ""); // Строка
		Если ВРег(ContentType) = ВРег("application/json;charset=utf-8") Тогда
			
			СоответствиеJSON = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(ИсходныйОбъект.ПолучитьТелоКакСтроку());
			ТелоЗапроса      = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(СоответствиеJSON, Истина);
			
		Иначе
			
			ТелоЗапроса = ИсходныйОбъект.ПолучитьТелоКакСтроку();
			
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ТелоЗапроса) Тогда
			
			МассивПредставление.Добавить(Символы.Таб + "Текст запроса:");
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(ТелоЗапроса, Смещение + Символы.Таб));
			
		КонецЕсли;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоHTTPОтветТип(ИсходныйОбъект, ТипОбъекта) Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить("HTTP ответ:");
		
		Если ИсходныйОбъект.Заголовки.Количество() > 0 Тогда
			
			МассивПредставление.Добавить(Символы.Таб + "Заголовки:");
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Заголовки, Смещение + Символы.Таб));
			
		КонецЕсли;
		
		Если ИсходныйОбъект.Заголовки["Content-Type"] = "application/json;charset=utf-8" Тогда
			
			СоответствиеJSON = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(ИсходныйОбъект.ПолучитьТелоКакСтроку());
			ТелоЗапроса      = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(СоответствиеJSON, Истина);
			
		Иначе
			
			ТелоЗапроса = ИсходныйОбъект.ПолучитьТелоКакСтроку();
			
		КонецЕсли;
		Если ЗначениеЗаполнено(ТелоЗапроса) Тогда
			
			МассивПредставление.Добавить(Символы.Таб + "Текст ответа:");
			МассивПредставление.Добавить(СформироватьТекстовоеПредставлениеОбъекта(ТелоЗапроса, Смещение + Символы.Таб));
			
		КонецЕсли;
		
		Результат = СтрСоединить(МассивПредставление, Символы.ПС + Смещение + Символы.Таб);
		
	ИначеЕсли ТипОбъекта = Тип("HTTPСоединение") Тогда
		
		МассивПредставление = Новый Массив; // Массив из Строка
		МассивПредставление.Добавить("HTTP соединение:");
		
		ШаблонПоля = НСтр("ru = 'Адрес сервера: %1, Порт: %2, Пользователь: %3, Таймаут: %4'");
		ТекстПредставления = СтрШаблон(ШаблонПоля,
				СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Сервер),
				СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Порт),
				СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Пользователь),
				СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Таймаут));
		
		МассивПредставление.Добавить(Символы.Таб + ТекстПредставления);
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоХранилищеЗначения(ИсходныйОбъект, ТипОбъекта) Тогда
		
		#Если Не ТонкийКлиент Тогда
			Результат = СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект.Получить());
		#КонецЕсли
		
	ИначеЕсли ТипОбъекта = Тип("ИнформацияОбОшибке") Тогда
		
		Результат = Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке());
		
	Иначе
		
		Результат = СокрЛП(ИсходныйОбъект);
		
	КонецЕсли;
	
	Возврат СместитьВесьТекстНаРазделитель(СокрЛП(Результат), Смещение);
	
#Иначе
	
	//@skip-check transfer-object-between-client-server
	Возврат Спец_СтроковыеФункцииВызовСервера.СформироватьТекстовоеПредставлениеОбъекта(ИсходныйОбъект, Смещение);
	
#КонецЕсли
	
КонецФункции

// Возвращает закодированную исходную строку в формате Base64
// 
// Параметры:
//  ИсходнаяСтрока - Строка - Строка для кодирования
// 
// Возвращаемое значение:
//  Строка
//
Функция ЗакодироватьСтрокуВBase64(Знач ИсходнаяСтрока) Экспорт
	
	Возврат ПреобразоватьДвоичныеДанныеВСтрокуBase64(ПолучитьДвоичныеДанныеИзСтроки(ИсходнаяСтрока));
	
КонецФункции

// Возвращает раскодированную исходную строку формата Base64 (обратный метод для см. ЗакодироватьСтрокуВBase64)
// 
// Параметры:
//  СтрокаBase64 - Строка - Строка, закодированная в формате Base64
// 
// Возвращаемое значение:
//  Строка
//
Функция РаскодироватьСтрокуBase64(Знач СтрокаBase64) Экспорт
	
	Возврат ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(СтрокаBase64));
	
КонецФункции

// Дополняет строку символами слева или справа до заданной длины и возвращает ее.
// При этом удаляются незначащие символы слева и справа (подробнее про незначащие символы 
// см. синтакс-помощник к методу платформы СокрЛП). 
// По умолчанию функция дополняет строку символами "0" (ноль) слева.
//
// Параметры:
//  Значение    - Строка - исходная строка, которую необходимо дополнить символами;
//  ДлинаСтроки - Число  - требуемая результирующая длина строки;
//  Символ      - Строка - символ, которым необходимо дополнить строку;
//  Режим       - Строка - "Слева" или "Справа" - вариант добавления символов к исходной строке.
// 
// Возвращаемое значение:
//  Строка - строка, дополненная символами.
//
// Пример:
//  1. Результат = СтроковыеФункцииКлиентСервер.ДополнитьСтроку("1234", 10, "0", "Слева");
//  Возвращает: "0000001234".
//
//  2. Результат = СтроковыеФункцииКлиентСервер.ДополнитьСтроку(" 1234  ", 10, "#", "Справа");
//  Строка = " 1234  "; ДлинаСтроки = 10; Символ = "#"; Режим = "Справа"
//  Возвращает: "1234######".
//
Функция ДополнитьСтроку(Знач Значение, Знач ДлинаСтроки, Знач Символ = "0", Знач Режим = "СЛЕВА") Экспорт
	
	// Длина символа не должна превышать единицы.
	Символ = Лев(Символ, 1);
	
	// Удаляем крайние пробелы слева и справа строки.
	Значение = СокрЛП(Значение);
	КоличествоСимволовНадоДобавить = ДлинаСтроки - СтрДлина(Значение);
	
	Если КоличествоСимволовНадоДобавить > 0 Тогда
		
		СтрокаДляДобавления = СформироватьСтрокуСимволов(Символ, КоличествоСимволовНадоДобавить);
		
		ВРегРежим = ВРег(Режим);
		Если ВРегРежим = "СЛЕВА" Тогда Значение = СтрокаДляДобавления + Значение; ИначеЕсли ВРегРежим = "СПРАВА" Тогда Значение = Значение + СтрокаДляДобавления; КонецЕсли;
		
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Формирует строку повторяющихся символов заданной длины.
//
// Параметры:
//  Символ      - Строка - символ, из которого будет формироваться строка.
//  ДлинаСтроки - Число  - требуемая длина результирующей строки.
//
// Возвращаемое значение:
//  Строка - строка, состоящая из повторяющихся символов.
//
Функция СформироватьСтрокуСимволов(Знач Символ, Знач ДлинаСтроки) Экспорт
	
	Результат = "";
	Для Счетчик = 1 По ДлинаСтроки Цикл Результат = Результат + Символ; КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Проверяет, является ли строка заполненным уникальным идентификатором.
// 
// Параметры:
//  СтрокаДляПроверки - Строка - Уникальный идентификатор в виде строки
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоПустойУникальныйИдентификатор(Знач СтрокаДляПроверки) Экспорт
	
	Возврат Не ЭтоУникальныйИдентификатор(СтрокаДляПроверки) Или СокрЛП(СтрокаДляПроверки) = "00000000-0000-0000-0000-000000000000";
	
КонецФункции

// Приводит строковое значение к дате.
//
// Параметры:
//	СтрокаДляПреобразования - Число, Строка - строковое значение, которое приводится к дате.
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//	Дата - приведенное значение.
//
//@skip-check invocation-parameter-type-intersect
Функция СтрокаВДату(Знач СтрокаДляПреобразования, Кэш = Неопределено) Экспорт 
	// Самый адекватный алгоритм: https://infostart.ru/1c/articles/400908/
	// Работает быстрее, чем даже строка в дату с форматом.
	//
	// Что поправил:
	//	* Добавил быструю проверку на ISO формат (см. ниже, работает только при рабочей компоненте)
	//	* Добавил проверку, что месяц, день и год не равны 00, а 01 (иначе 1С ооочень своеобразно преобразует)
	//	* Сделал более универсальную проверку на то, что если год 50 то это 1950 или 2050 (если текущий год + 15, тогда 2050, иначе 1950)
	
	Если ПустаяСтрока(СтрокаДляПреобразования) Тогда 
		Возврат Дата(1, 1, 1);
	КонецЕсли;
	
	// Самая точная проверка XML даты, но отработает только с работающей компонентой
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	Если Кэш.КомпонентаBaseFunction <> Неопределено
		И Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению(СтрокаДляПреобразования, RegexDateTimeISO8601(), Кэш) Тогда
		
		// Дата с временем отработает только если T (не пробел), поэтому принудительно ставим её.
		Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLЗначениеПоНормальному(
				Тип("Дата"),
				?(СтрДлина(СтрокаДляПреобразования) > 11, Лев(СтрокаДляПреобразования, 10) + "T" + Сред(СтрокаДляПреобразования, 12), СтрокаДляПреобразования));
		
	ИначеЕсли СтрДлина(СтрокаДляПреобразования) >= 10 И Сред(СтрокаДляПреобразования, 5, 1) = "-" И Сред(СтрокаДляПреобразования, 8, 1) = "-" Тогда
		
		ДатаРезультат = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLЗначениеПоНормальному(
				Тип("Дата"),
				?(СтрДлина(СтрокаДляПреобразования) > 11, Лев(СтрокаДляПреобразования, 10) + "T" + Сред(СтрокаДляПреобразования, 12), СтрокаДляПреобразования));
		
		Если ЗначениеЗаполнено(ДатаРезультат) Тогда Возврат ДатаРезультат; КонецЕсли;
		
	КонецЕсли;
	
Попытка
	
	//-----для локализации ------------------------------
	п_мФорматы = Новый Массив(4); // Массив из Строка
	п_мФорматы[0] = "г";    // знак года
	п_мФорматы[1] = "ЧЦ=2; ЧН=; ЧВН=";
	п_мФорматы[2] = "ЧГ=0";    
	п_мФорматы[3] = "ДФ=МММ";
	//---------------------------------------------------
	
	п_мТЕМП = Новый массив(7);  // Массив из Строка
	
	СтрокаДляПреобразования = Формат(СтрокаДляПреобразования, п_мФорматы[2]);        //на случай если в формате 1с числом: 20150320220315. (+локализация)
	
	//Если использовать конструкцию "Если Найти(сДата,..." , то перебор букв строки будет происходить 2а раза: Найти и СтрЗаменить //Использование Найти в данном случае бессмысленно
	// можно добавить любой разделитель - @, #, %, и тд, неважно. Главное, заменить их на "."
	СтрокаДляПреобразования = СтрЗаменить(СтрокаДляПреобразования, "«", "");             //«1 Фев 05 г.»
	СтрокаДляПреобразования = СтрЗаменить(СтрокаДляПреобразования, "»", "");            //«1 Фев 05 г.»
	СтрокаДляПреобразования = СтрЗаменить(СтрокаДляПреобразования, п_мФорматы[0] + ".", "");   //1 Фев 05 г. 17:20:00 //просто "г" нельзя из-за "авГуст", например. Но в далее,после парсинга месяца, любое "г" в строке,  удаляется
	СтрокаДляПреобразования = СтрЗаменить(СтрокаДляПреобразования, "/", ".");            // 1/2/5
	СтрокаДляПреобразования = СтрЗаменить(СтрокаДляПреобразования, "\", ".");            // 1\02\05
	СтрокаДляПреобразования = СтрЗаменить(СтрокаДляПреобразования, "-", ".");            // 1-02-05
	СтрокаДляПреобразования = СтрЗаменить(СтрокаДляПреобразования, Символы.Таб, ".");        // 01.02.2005    17:20:00    
	СтрокаДляПреобразования = СтрЗаменить(СтрокаДляПреобразования, " ", ".");            // 1/02 2005 17:20:00
	СтрокаДляПреобразования = СтрЗаменить(СтрокаДляПреобразования, "..",  ".");            //Возможны, появление двойных точек из за "янв." в "янв" или из-за " г. ".    
	СтрокаДляПреобразования = НРег(СокрЛП(СтрокаДляПреобразования));                 // строку в нижний регистр, чтоб проще было с Янв Январь янв и тд
	
	п_мТЕМП = Новый массив(7); // Массив из Строка
	
	п_мТЕМП[0] = СтрНайти(СтрокаДляПреобразования,".");
	
	Если п_мТЕМП[0] = 0 Тогда
		//если точек нет
		
		Если СтрНайти(СтрокаДляПреобразования,":") Тогда
			//только время (или ошибка)
			СтрокаДляПреобразования = "01.01.0001." + СтрокаДляПреобразования;
			п_мТЕМП[0] = СтрНайти(СтрокаДляПреобразования,".");
		иначе            
			//похоже на формат 1с. Можно добавить "попытку"...
			п_мТЕМП[6] = дата(СтрокаДляПреобразования);
			Возврат п_мТЕМП[6];
			
		КонецЕсли;    
		
	КонецЕсли;
	
	
	// ----- ДНИ -------------------------------------
	п_мТЕМП[0] = Лев(СтрокаДляПреобразования, п_мТЕМП[0] - 1);//дни 
	п_мТЕМП[4] = Прав(СтрокаДляПреобразования, СтрДлина(СтрокаДляПреобразования) - СтрДлина(п_мТЕМП[0])-1);// месяц и все что справа
	п_мТЕМП[0] = Формат(Число(п_мТЕМП[0]),п_мФорматы[1]);//дни в формат двух чисел
	Если п_мТЕМП[0] = "00" Тогда п_мТЕМП[0] = "01"; КонецЕсли;
	// ----- Месяц -----------------------------------
	п_мТЕМП[1] = Лев(п_мТЕМП[4], СтрНайти(п_мТЕМП[4],".") - 1);// месяц
	п_мТЕМП[4] = Прав(п_мТЕМП[4], СтрДлина(п_мТЕМП[4]) - СтрДлина(п_мТЕМП[1])-1);// год и все что справа
	//Возможны варианты месяца "янв" "янв." "январь" "января" 
	Если СтрДлина(п_мТЕМП[1]) > 2 Тогда // месяц в виде янв или январь
		
		п_мТЕМП[2] = 0;
		Пока п_мТЕМП[2] < 12 Цикл 
			
			п_мТЕМП[2] = п_мТЕМП[2]+1;
			// берем из "янв." только "янв"
			п_мТЕМП[3] = СтрЗаменить(Формат(Дата("2001" + Формат(п_мТЕМП[2],п_мФорматы[1]) + "01"), п_мФорматы[3]),".","");// + локализация
			
			п_мТЕМП[3] = СтрНайти(п_мТЕМП[1], п_мТЕМП[3]);
			
			Если п_мТЕМП[3] > 0 тогда
				п_мТЕМП[1] = Формат(п_мТЕМП[2],п_мФорматы[1]);
				прервать;
			КонецЕсли;
		КонецЦикла;    
	Иначе
		п_мТЕМП[1] = Формат(Число(п_мТЕМП[1]),п_мФорматы[1]);
	КонецЕсли;
	Если п_мТЕМП[1] = "00" Тогда п_мТЕМП[1] = "01"; КонецЕсли;
	// ----- ГОД -----------------------------------
	//Если в строке было "г" без точки("г.")
	п_мТЕМП[4] = СтрЗаменить(п_мТЕМП[4], п_мФорматы[0], "");
	//ищем год. Дата может быть без времени, т.е. год последний в строке
	п_мТЕМП[2] = СтрНайти(п_мТЕМП[4],".");
	
	Если п_мТЕМП[2]>0 Тогда
		п_мТЕМП[2] =  Лев(п_мТЕМП[4], п_мТЕМП[2] - 1);// год
		п_мТЕМП[4] = Прав(п_мТЕМП[4], СтрДлина(п_мТЕМП[4]) - СтрДлина(п_мТЕМП[2])-1);//время и все что справа
	Иначе
		п_мТЕМП[2] = п_мТЕМП[4];
		п_мТЕМП[4] = "";
	КонецЕсли;    
	
	//проверяем год
	п_мТЕМП[3] = СтрДлина(п_мТЕМП[2]);
	//если год из двух цыфр
	Если п_мТЕМП[3] = 2 или п_мТЕМП[3] = 1 Тогда
		п_мТЕМП[3] = Число(п_мТЕМП[2]);// год как число
		Год = Строка(Год(Спец_ОбщегоНазначенияКлиентСервер.ТекущаяДатаПоНормальному()));
		
		ЛеваяПоловина = Число(Лев(Год, 2));
		ПраваяПоловина = Число(Прав(Год, 2));
		
		Если п_мТЕМП[3] < ПраваяПоловина + 15 Тогда
			п_мТЕМП[2] = Строка(ЛеваяПоловина) + Формат(п_мТЕМП[3],п_мФорматы[1]);
		Иначе
			п_мТЕМП[2] = Строка(ЛеваяПоловина - 1) + Формат(п_мТЕМП[3],п_мФорматы[1]);
		КонецЕсли;    
		
	КонецЕсли;
	
	Если п_мТЕМП[2] = "0000" Тогда п_мТЕМП[2] = "0001"; КонецЕсли;
	
	// =======================  Форматируем время ==============================
	п_мТЕМП[6] = СтрЗаменить(п_мТЕМП[4],":", ".");// если дата была, например: 17-30-10, то сейчас 17.30.10 
	//"попытка" на преобразование даты, по времени, занимает столько же, а по ресурсам больше, чем сам парсинг времени. 
	//поэтому, убиваем двух зайцев перебором часы/мин/сек сразу
	Если СтрДлина(п_мТЕМП[6]) > 0 Тогда
		
		п_мТЕМП[5] = СтрНайти(п_мТЕМП[6],".");
		Если п_мТЕМП[5] > 0 Тогда
			// ========= часы    =================
			п_мТЕМП[3] = Лев(п_мТЕМП[6], СтрНайти(п_мТЕМП[6],".") - 1);//часы 
			п_мТЕМП[6] = Прав(п_мТЕМП[6], СтрДлина(п_мТЕМП[6]) - СтрДлина(п_мТЕМП[3])-1);// минуты и все что справа
			
			Если п_мТЕМП[3] = "" тогда
				п_мТЕМП[3] = "00";        
			Иначе
				//при переводе в дату лидирующий 0 у часов удаляется. Т.е. след. строка бесполезна
				//п_мТЕМП[3] = Формат(Число(п_мТЕМП[3]),п_мФорматы[1]);//часы в формат двух чисел     
			КонецЕсли;        
			
			п_мТЕМП[5] = СтрНайти(п_мТЕМП[6],".");
			Если п_мТЕМП[5] > 0 Тогда
				// ========= минуты    =================
				п_мТЕМП[4] = Лев(п_мТЕМП[6], СтрНайти(п_мТЕМП[6],".") - 1);
				п_мТЕМП[6] = Прав(п_мТЕМП[6], СтрДлина(п_мТЕМП[6]) - СтрДлина(п_мТЕМП[4])-1);// секунды и все что справа
				Если п_мТЕМП[4] = "" тогда
					п_мТЕМП[4] = "00";        
				Иначе
					п_мТЕМП[4] = Формат(Число(п_мТЕМП[4]),п_мФорматы[1]);//минуты в формат двух чисел     
				КонецЕсли;
				
				// ========= секунды    =================
				Если СтрДлина(п_мТЕМП[6]) = 0 Тогда
					п_мТЕМП[5] = "00";        
				Иначе
					п_мТЕМП[5] = Формат(Число(п_мТЕМП[6]),п_мФорматы[1]);//секунды в формат двух чисел     
				КонецЕсли;
				
			Иначе
				п_мТЕМП[4] = Формат(Число(п_мТЕМП[6]),п_мФорматы[1]);    
				п_мТЕМП[5] = "00";            
			КонецЕсли;     
		Иначе
			п_мТЕМП[3] = Формат(Число(п_мТЕМП[6]),п_мФорматы[1]);        
			п_мТЕМП[4] = "00";
			п_мТЕМП[5] = "00";
		КонецЕсли;
		
	Иначе
		п_мТЕМП[3] = "00";        
		п_мТЕМП[4] = "00";
		п_мТЕМП[5] = "00";            
	КонецЕсли;
	
	п_мТЕМП[6] = п_мТЕМП[0] + "." + п_мТЕМП[1] + "." + п_мТЕМП[2] + " " + п_мТЕМП[3] + ":" + п_мТЕМП[4] + ":" + п_мТЕМП[5];
	п_мТЕМП[6] = дата(п_мТЕМП[6]);
	
	Возврат п_мТЕМП[6];
	
Исключение
	
	Возврат Дата(1, 1, 1);
	
КонецПопытки;
	
КонецФункции

// Преобразует исходную строку в число без вызова исключений.
//
// Параметры:
//   Значение - Строка - строка, которую необходимо привести к числу.
//                       Например, "10", "+10", "010", вернет 10;
//                                 "(10)", "-10",вернет -10;
//                                 "10,2", "10.2",вернет 10.2;
//                                 "000", " ", "",вернет 0;
//                                 "10текст", вернет Неопределено.
//
// Возвращаемое значение:
//   Число, Неопределено - полученное число, либо Неопределено, если строка не является числом.
//
Функция СтрокаВЧисло(Знач Значение) Экспорт
	
	Значение = СтрЗаменить(Значение, " ", "");
	Если СтрНачинаетсяС(Значение, "(") Тогда Значение = СтрЗаменить(Значение, "(", "-"); Значение = СтрЗаменить(Значение, ")", ""); КонецЕсли;
	
	НачинаетсяСМинуса = СтрНачинаетсяС(Значение, "-");
	ЛишниеСимволы     = СтрСоединить(СтрРазделить(Значение, "0123456789,."), "");
	Значение          = ?(НачинаетсяСМинуса, "-", "") + СтрСоединить(СтрРазделить(Значение, ЛишниеСимволы), "");
	
	СтрокаБезНулей = СтрЗаменить(Значение, "0", "");
	Если ПустаяСтрока(СтрокаБезНулей) Или СтрокаБезНулей = "-" Тогда Возврат 0; КонецЕсли;
	
	ТипЧисло = Новый ОписаниеТипов("Число");
	Результат = ТипЧисло.ПривестиЗначение(Значение);
	Возврат ?(Результат <> 0 И Не ПустаяСтрока(СтрокаБезНулей), Результат, Неопределено);
	
КонецФункции

// Проверяет, является ли строка уникальным идентификатором.
// В качестве уникального идентификатора предполагается строка вида
// "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX", где X = [0..9,a..f].
//
// Параметры:
//  Значение - Строка - проверяемая строка.
//
// Возвращаемое значение:
//  Булево - Истина, если переданная строка является уникальным идентификатором.
//
Функция ЭтоУникальныйИдентификатор(Знач Значение) Экспорт
	
	Шаблон = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
	
	Если СтрДлина(Шаблон) <> СтрДлина(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;
	Для Позиция = 1 По СтрДлина(Значение) Цикл
		Если КодСимвола(Шаблон, Позиция) = 88 // X
			И ((КодСимвола(Значение, Позиция) < 48 Или КодСимвола(Значение, Позиция) > 57) // 0..9
				И (КодСимвола(Значение, Позиция) < 97 Или КодСимвола(Значение, Позиция) > 102) // a..f
				И (КодСимвола(Значение, Позиция) < 65 Или КодСимвола(Значение, Позиция) > 70)) // A..F
			Или КодСимвола(Шаблон, Позиция) = 45 И КодСимвола(Значение, Позиция) <> 45 Тогда // -
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Метод для поиска похожих строк в массиве строк (через расстояние Левенштейна).
// 
// Параметры:
//  ИсходныйМассивСтрок - Массив из Строка - Массив строк, в котором ищем похожие
//  СтрокаДляПоиска - Строка - Строка для поиска похожей
//  ПроцентДлиныСтрокиДляРезультата - Число - Процент длины строки с ошибкой
//  СтруктураПараметровДляПоискаЛевенштейна - Неопределено, Структура - Параметры рассчёта расстояния Левенштейна:
//  	* ЦенаУдаления - Число - По умолчанию 1
//  	* ЦенаДобавления - Число - По умолчанию 1
//  	* ЦенаЗамены - Число - По умолчанию 1
//  	* УчитыватьРегистр - Булево - Флаг того, будет ли учитываться регистр слов при расчёте (по умолчанию ЛОЖЬ)
// 
// Возвращаемое значение:
//  - Массив из Строка - Массив похожих строк
//	- Строка - Если найдена точно такая же строка
//
Функция НайтиТочнуюИлиПохожиеСтрокиВМассивеСтрок(Знач ИсходныйМассивСтрок, Знач СтрокаДляПоиска,
		Знач ПроцентДлиныСтрокиДляРезультата = 30, Знач СтруктураПараметровДляПоискаЛевенштейна = Неопределено) Экспорт
	
	МаксимальноеРасстояниеЛевенштейна = Цел(СтрДлина(СтрокаДляПоиска) / 100 * ПроцентДлиныСтрокиДляРезультата);
	ЦенаУдаления                      = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураПараметровДляПоискаЛевенштейна, "ЦенаУдаления"     , 1); // Число
	ЦенаДобавления                    = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураПараметровДляПоискаЛевенштейна, "ЦенаДобавления"   , 1); // Число
	ЦенаЗамены                        = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураПараметровДляПоискаЛевенштейна, "ЦенаЗамены"       , 1); // Число 
	УчитыватьРегистр                  = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураПараметровДляПоискаЛевенштейна, "УчитыватьРегистр" , Ложь); // Булево
	
	МассивРезультат = НовыйМассивРезультатПоискаПохожихСтрок();
	Для Каждого ИсходнаяСтрокаДляПоиска Из ИсходныйМассивСтрок Цикл
		
		РасстояниеЛевенштейна = РасстояниеДамерауЛевенштейна(ИсходнаяСтрокаДляПоиска, СтрокаДляПоиска, ЦенаУдаления, ЦенаДобавления, ЦенаЗамены, УчитыватьРегистр);
		Если РасстояниеЛевенштейна = 0 Тогда
			Возврат ИсходнаяСтрокаДляПоиска;
		ИначеЕсли РасстояниеЛевенштейна <= МаксимальноеРасстояниеЛевенштейна Тогда
			МассивРезультат.Добавить(НоваяСтруктураРезультатаДляПоискаПохожихСтрок(ИсходнаяСтрокаДляПоиска, РасстояниеЛевенштейна));
		КонецЕсли;
		
	КонецЦикла;
	
	Спец_РаботаСКоллекциямиКлиентСервер.СортироватьМассивСтруктурПоКлючу(МассивРезультат, "РасстояниеЛевенштейна", НаправлениеСортировки.Убыв);
	Возврат Спец_РаботаСКоллекциямиКлиентСервер.ВыгрузитьМассивЗначений(МассивРезультат, "СтрокаРезультат");
	
КонецФункции

// Расстояние Дамерау-Левенштейна.
// 
// Параметры:
//  ПерваяСтрока - Строка - Первая строка
//  ВтораяСтрока - Строка - Вторая строка
//  ЦенаУдаления - Число - Цена удаления
//  ЦенаДобавления - Число - Цена добавления
//  ЦенаЗамены - Число - Цена замены
//  УчитыватьРегистр - Булево - Учитывать регистр
// 
// Возвращаемое значение:
//  Число
//  
//@skip-check invocation-parameter-type-intersect
Функция РасстояниеДамерауЛевенштейна(Знач ПерваяСтрока, Знач ВтораяСтрока, Знач ЦенаУдаления = 1, Знач ЦенаДобавления = 1,
		Знач ЦенаЗамены = 1, Знач УчитыватьРегистр = Ложь) Экспорт
	
	Если Не УчитыватьРегистр Тогда ПерваяСтрока = ВРег(ПерваяСтрока); ВтораяСтрока = ВРег(ВтораяСтрока); КонецЕсли;
	
	ДлинаСтроки1 = СтрДлина(ПерваяСтрока);
	ДлинаСтроки2 = СтрДлина(ВтораяСтрока);
	
	Если ДлинаСтроки1 = 0 Тогда Возврат ДлинаСтроки2; ИначеЕсли ДлинаСтроки2 = 0 Тогда Возврат ДлинаСтроки1; КонецЕсли;
	
	МатрицаРасстояний = Новый Массив(ДлинаСтроки1 + 1, ДлинаСтроки2 + 1);
	Для i = 0 По ДлинаСтроки1 Цикл МатрицаРасстояний[i][0] = i; КонецЦикла;
	Для j = 0 По ДлинаСтроки2 Цикл МатрицаРасстояний[0][j] = j; КонецЦикла;
	Для i = 1 По ДлинаСтроки1 Цикл Для j = 1 По ДлинаСтроки2 Цикл МатрицаРасстояний[i][j] = Мин(МатрицаРасстояний[i - 1][j] + ЦенаУдаления, МатрицаРасстояний[i][j - 1] + ЦенаДобавления, МатрицаРасстояний[i - 1][j - 1] + ?(Сред(ПерваяСтрока, i, 1) <> Сред(ВтораяСтрока, j, 1), ЦенаЗамены, 0)); Если i > 1 И j > 1 И Сред(ПерваяСтрока, i, 1) = Сред(ВтораяСтрока, j - 1, 1) И Сред(ПерваяСтрока, i - 1, 1) = Сред(ВтораяСтрока, j, 1) Тогда МатрицаРасстояний[i][j] = Мин(МатрицаРасстояний[i][j], МатрицаРасстояний[i - 2][j - 2] + ?(Сред(ПерваяСтрока, i, 1) <> Сред(ВтораяСтрока, j, 1), ЦенаЗамены, 0)); КонецЕсли; КонецЦикла; КонецЦикла;
	
	Возврат МатрицаРасстояний[ДлинаСтроки1][ДлинаСтроки2];
	
КонецФункции

// Преобразует исходную строку в транслит.
// Может использоваться для отправки SMS-сообщений латиницей или для сохранения
// файлов и папок, чтобы обеспечить возможность их переноса между разными операционными системами.
// Обратное преобразование из латинских символов не предусмотрено.
//
// Параметры:
//  СтрокаДляОбработки - Строка - произвольная строка.
//
// Возвращаемое значение:
//  Строка - строка, в которой кириллица заменена на транслит.
//
Функция СтрокаЛатиницей(Знач СтрокаДляОбработки) Экспорт
	
	ПравилаТранслитерации = Новый Соответствие();
	
	ПравилаТранслитерации.Вставить("а","a");
	ПравилаТранслитерации.Вставить("б","b");
	ПравилаТранслитерации.Вставить("в","v");
	ПравилаТранслитерации.Вставить("г","g");
	ПравилаТранслитерации.Вставить("д","d");
	ПравилаТранслитерации.Вставить("е","e");
	ПравилаТранслитерации.Вставить("ё","e"); // АПК:163 требуется транслитерация.
	ПравилаТранслитерации.Вставить("ж","zh");
	ПравилаТранслитерации.Вставить("з","z");
	ПравилаТранслитерации.Вставить("и","i");
	ПравилаТранслитерации.Вставить("й","y");
	ПравилаТранслитерации.Вставить("к","k");
	ПравилаТранслитерации.Вставить("л","l");
	ПравилаТранслитерации.Вставить("м","m");
	ПравилаТранслитерации.Вставить("н","n");
	ПравилаТранслитерации.Вставить("о","o");
	ПравилаТранслитерации.Вставить("п","p");
	ПравилаТранслитерации.Вставить("р","r");
	ПравилаТранслитерации.Вставить("с","s");
	ПравилаТранслитерации.Вставить("т","t");
	ПравилаТранслитерации.Вставить("у","u");
	ПравилаТранслитерации.Вставить("ф","f");
	ПравилаТранслитерации.Вставить("х","kh");
	ПравилаТранслитерации.Вставить("ц","ts");
	ПравилаТранслитерации.Вставить("ч","ch");
	ПравилаТранслитерации.Вставить("ш","sh");
	ПравилаТранслитерации.Вставить("щ","shch");
	ПравилаТранслитерации.Вставить("ъ",""); // Пропускается.
	ПравилаТранслитерации.Вставить("ы","y");
	ПравилаТранслитерации.Вставить("ь",""); // Пропускается.
	ПравилаТранслитерации.Вставить("э","e");
	ПравилаТранслитерации.Вставить("ю","yu");
	ПравилаТранслитерации.Вставить("я","ya");
	
	Результат = "";
	ТолькоЗаглавныеВСтроке = ТолькоЗаглавныеВСтроке(СтрокаДляОбработки);
	
	Для Позиция = 1 По СтрДлина(СтрокаДляОбработки) Цикл
		
		Символ = Сред(СтрокаДляОбработки, Позиция, 1);
		
		СимволЛатиницей = ПравилаТранслитерации[НРег(Символ)]; // Поиск соответствия без учета регистра.
		Если СимволЛатиницей = Неопределено Тогда
			// Другие символы остаются "как есть".
			СимволЛатиницей = Символ;
		Иначе
			Если ТолькоЗаглавныеВСтроке Тогда 
				СимволЛатиницей = ВРег(СимволЛатиницей); // восстанавливаем регистр
			ИначеЕсли Символ = ВРег(Символ) Тогда
				СимволЛатиницей = ТРег(СимволЛатиницей); // восстанавливаем регистр
			КонецЕсли;
		КонецЕсли;
		
		Результат = Результат + СимволЛатиницей;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Очищает текст от лишних символов и оставляет только цифры в ней.
// 
// Параметры:
//  СтрокаДляОбработки - Строка - Строка для преобразования
// 
// Возвращаемое значение:
//  Строка
//
Функция ОставитьТолькоЦифрыВСтроке(Знач СтрокаДляОбработки) Экспорт
	
	Возврат ОставитьТолькоНужныеСимволыВСтроке(СтрокаДляОбработки, Спец_КонстантыКлиентСервер.ВсеЦифры());
	
КонецФункции

// Заменяет недопустимые символы в XML-строке на заданные символы.
//
// Параметры:
//   Текст - Строка - строка, в которой требуется выполнить замену недопустимых символов.
//   СимволЗамены - Строка - строка, на которую требуется выполнить замену недопустимого символа в XML-строке.
// 
// Возвращаемое значение:
//    Строка - строка, полученная заменой недопустимых символов в XML-строке.
//
Функция ЗаменитьНедопустимыеСимволыXML(Знач Текст, Знач СимволЗамены = " ") Экспорт
	
	// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
	Если СимволЗамены = "" Тогда Возврат УдалитьНедопустимыеСимволыXMLПрограммно(Текст); КонецЕсли;
	// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
	
	Если ПустаяСтрока(Текст) Тогда Возврат Текст; КонецЕсли;
	
#Если Не ВебКлиент Тогда
	
	ПозицияНачала = 1;
	
	// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
	Позиция = ОбработкаСтрокиXML.НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала, "1.1");
	// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
	// ++ Спец_БСП.Версия1С_20_Ниже
	////Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
	// -- Спец_БСП.Версия1С_20_Ниже
	Пока Позиция > 0 Цикл
		
		Текст = СтрЗаменить(Текст, Сред(Текст, Позиция, 1), СимволЗамены);
		ПозицияНачала = Позиция + СтрДлина(СимволЗамены);
		Если ПозицияНачала > СтрДлина(Текст) Тогда
			Прервать;
		КонецЕсли;
		
		// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
		Позиция = ОбработкаСтрокиXML.НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала, "1.1");
		// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
		// ++ Спец_БСП.Версия1С_20_Ниже
		////Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
		// -- Спец_БСП.Версия1С_20_Ниже
		
	КонецЦикла;
	
	Возврат Текст;
	
#Иначе
	
	// Коды символов от 0 до 2^16-1, которые метод НайтиНедопустимыеСимволыXML
	// считает недопустимыми: 0-8, 11-12, 14-31, 55296-57343.
	Итог = "";
	
	// Косяк EDT
	//@skip-check invocation-parameter-type-intersect 
	Для НомерСимвола = 1 По СтрДлина(Текст) Цикл
		
		Символ = Сред(Текст, НомерСимвола, 1);
		КодСимвола = КодСимвола(Символ);
		Если КодСимвола < 9
			Или КодСимвола > 10    И КодСимвола < 13
			Или КодСимвола > 13    И КодСимвола < 32
			Или КодСимвола > 55295 И КодСимвола < 57344 Тогда
			
			Символ = СимволЗамены;
		КонецЕсли;
		
		Итог = Итог + Символ;
		
	КонецЦикла;
	
	Возврат Итог;
	
#КонецЕсли
	
КонецФункции

// Удаляет недопустимые символы в XML-строке.
//
// Параметры:
//  Текст - Строка - строка, в которой требуется удалить недопустимые символы.
// 
// Возвращаемое значение:
//  Строка - строка, полученная при удалении недопустимых символов в XML-строке.
Функция УдалитьНедопустимыеСимволыXMLПрограммно(Знач Текст) Экспорт
	
	// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
	Возврат ?(ПустаяСтрока(Текст), Текст, ОбработкаСтрокиXML.УдалитьНедопустимыеСимволыXML(Текст, "1.1"));
	// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_20_Ниже
	////Возврат ?(ПустаяСтрока(Текст), Текст, ЗаменитьНедопустимыеСимволыXML(Текст, ""));
	// -- Спец_БСП.Версия1С_20_Ниже
	
КонецФункции

// Параметры:
//  IPДляПроверки - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоНеЛокальныйЧисловойIP(Знач IPДляПроверки, Кэш = Неопределено) Экспорт
	
	Возврат Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению(
					IPДляПроверки,
					"^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$",
					Кэш)
			И Не СтрНачинаетсяС(IPДляПроверки, "127.0.");
	
КонецФункции

// 1С-кая реализация (не работают PERL, многострочные проверки, и т.п.)
// (см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению)
//	
// Параметры:
//  СтрокаДляПроверки - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению.СтрокаДляПроверки
//  РегулярноеВыражение - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению.РегулярноеВыражение
// 
// Возвращаемое значение:
//  Булево - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаСоответствуетРегулярномуВыражению
//
Функция СтрокаСоответствуетРегулярномуВыражению(Знач СтрокаДляПроверки, Знач РегулярноеВыражение) Экспорт
	
#Если Не ВебКлиент Тогда
	
    Попытка
        
        ПаттернДляПроверки = СформироватьОбъектXDTOДляПроверкиРегулярногоВыражения(РегулярноеВыражение);
        ПаттернДляПроверки.TestItem = СтрокаДляПроверки;
        
        Возврат Истина;
        
    Исключение
        
        Возврат Ложь;
        
    КонецПопытки;
	
#Иначе
	
	Возврат Спец_СтроковыеФункцииВызовСервера.СтрокаСоответствуетРегулярномуВыражению(СтрокаДляПроверки, РегулярноеВыражение);
	
#КонецЕсли
	
КонецФункции

// Преобразует число (количество байт) в читаемый вид.
// Например, если передали число 6 291 456, то вернёт "6 МБайт"
// 
// Параметры:
//  КоличествоБайт - Число
// 
// Возвращаемое значение:
//  Строка
//
Функция ПеревестиРазмерИзБайтовВЧитемыйВид(Знач КоличествоБайт) Экспорт
	
	Если КоличествоБайт <= 0 Тогда
		Возврат "0 байт";
	КонецЕсли;
		
	КоличествоБайтОсталось = КоличествоБайт;
	Уровень                = 1;
	
	Пока КоличествоБайтОсталось >= 4096 Цикл КоличествоБайтОсталось = КоличествоБайтОсталось / 1024; Уровень = Уровень + 1; Если Уровень > 5 Тогда Прервать; КонецЕсли; КонецЦикла;
	Если Уровень = 1 Тогда
		Возврат Формат(Окр(КоличествоБайтОсталось, 2), "ЧРД=.; ЧН=0; ЧГ=; ЧФ='Ч байт'");
	ИначеЕсли Уровень = 2 Тогда
		Возврат Формат(Окр(КоличествоБайтОсталось, 2), "ЧРД=.; ЧН=0; ЧГ=; ЧФ='Ч Кбайт'");
	ИначеЕсли Уровень = 3 Тогда
		Возврат Формат(Окр(КоличествоБайтОсталось, 2), "ЧРД=.; ЧН=0; ЧГ=; ЧФ='Ч Мбайт'");
	ИначеЕсли Уровень = 4 Тогда
		Возврат Формат(Окр(КоличествоБайтОсталось, 2), "ЧРД=.; ЧН=0; ЧГ=; ЧФ='Ч Гбайт'");
	ИначеЕсли Уровень = 5 Тогда
		Возврат Формат(Окр(КоличествоБайтОсталось, 2), "ЧРД=.; ЧН=0; ЧГ=; ЧФ='Ч Тбайт'");
	Иначе
		Возврат Формат(Окр(КоличествоБайтОсталось, 2), "ЧРД=.; ЧН=0; ЧГ=; ЧФ='Ч Пбайт'");
	КонецЕсли;
	
КонецФункции

// Преобразует число (количество секунд) в читаемый вид.
// Например, если передали число 7200, то вернёт "2 ч."
// 
// Параметры:
//  КоличествоСекунд - Число
// 
// Возвращаемое значение:
//  Строка
//
Функция ПеревестиСекундыВЧитемыйВид(Знач КоличествоСекунд) Экспорт
	
	Если КоличествоСекунд <= 0 Тогда
		Возврат "0 сек.";
	КонецЕсли;
	
#Если Не ВнешнееСоединение Тогда
	
	МассивКоличествВНужномУровне = Новый Массив(6); // Массив из Число
	
	МассивКоличествВНужномУровне[0] = 60; // Секунд в минуте
	МассивКоличествВНужномУровне[1] = 60; // Минуты в часах
	МассивКоличествВНужномУровне[2] = 24; // Часов в сутках
	МассивКоличествВНужномУровне[3] = 30; // Суток в месяце
	МассивКоличествВНужномУровне[4] = 12; // Месяцев в году
	МассивКоличествВНужномУровне[5] = 100; // Лет в веку
	
	КоличествоСекундОсталось = КоличествоСекунд;
	Для Уровень = 0 По МассивКоличествВНужномУровне.ВГраница() Цикл
		
		Если КоличествоСекундОсталось <= МассивКоличествВНужномУровне[Уровень] * 3 Тогда
			Прервать;
		КонецЕсли;
		
		КоличествоСекундОсталось = КоличествоСекундОсталось / МассивКоличествВНужномУровне[Уровень];
		
	КонецЦикла;
	
	Если Уровень = 0 Тогда
		
		Возврат Формат(Окр(КоличествоСекундОсталось, 2, РежимОкругления.Окр15как20),
				"ЧРГ=.; ЧН='0 сек.'; ЧГ=; ЧФ='Ч сек.'");
		
	ИначеЕсли Уровень = 1 Тогда
		
		Возврат Формат(Окр(КоличествоСекундОсталось, 2, РежимОкругления.Окр15как20),
				"ЧРГ=.; ЧН='0 мин.'; ЧГ=; ЧФ='Ч мин.'");
		
	ИначеЕсли Уровень = 2 Тогда
		
		Возврат Формат(Окр(КоличествоСекундОсталось, 2, РежимОкругления.Окр15как20),
				"ЧРГ=.; ЧН='0 ч.'; ЧГ=; ЧФ='Ч ч.'");
		
	ИначеЕсли Уровень = 3 Тогда
		
		Возврат СтрокаСЧислом(";%1 день;;%1 дня;%1 дней;%1 дня",
				Окр(КоличествоСекундОсталось, 2, РежимОкругления.Окр15как20),
				ВидЧисловогоЗначения.Количественное,
				"ЧРГ=.; ЧН=0; ЧГ=");
		
	ИначеЕсли Уровень = 4 Тогда
		
		Возврат СтрокаСЧислом(";%1 месяц;;%1 месяца;%1 месяцев;%1 месяца",
				Окр(КоличествоСекундОсталось, 2, РежимОкругления.Окр15как20),
				ВидЧисловогоЗначения.Количественное,
				"ЧРГ=.; ЧН=0; ЧГ=");
		
	ИначеЕсли Уровень = 5 Тогда
		
		Возврат СтрокаСЧислом(";%1 год;;%1 года;%1 лет;%1 года",
				Окр(КоличествоСекундОсталось, 2, РежимОкругления.Окр15как20),
				ВидЧисловогоЗначения.Количественное,
				"ЧРГ=.; ЧН=0; ЧГ=");
		
	Иначе
		
		Возврат СтрокаСЧислом(";%1 век;;%1 века;%1 веков;%1 века",
				Окр(КоличествоСекундОсталось, 2, РежимОкругления.Окр15как20),
				ВидЧисловогоЗначения.Количественное,
				"ЧРГ=.; ЧН=0; ЧГ=");
		
	КонецЕсли;
	
#Иначе
	
	Возврат "0 сек.";
	
#КонецЕсли
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Параметры:
//  СтрокаДляОбработки - Строка
//  СимволыКоторыеНеТрогать - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ОставитьТолькоНужныеСимволыВСтроке(Знач СтрокаДляОбработки, Знач СимволыКоторыеНеТрогать) Экспорт
	
	Возврат СтрСоединить(СтрРазделить(СтрокаДляОбработки, СтрСоединить(СтрРазделить(СтрокаДляОбработки, СимволыКоторыеНеТрогать), "")), "");
	
КонецФункции

// Параметры:
//  НужноеИмя - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ОчиститьИмяДляЗапроса(Знач НужноеИмя) Экспорт
	
	Результат = ОставитьТолькоНужныеСимволыВСтроке(НужноеИмя,
			"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя1234567890_");
	
	Если СтрНачинаетсяС(Результат, "0")
			Или СтрНачинаетсяС(Результат, "1")
			Или СтрНачинаетсяС(Результат, "2")
			Или СтрНачинаетсяС(Результат, "3")
			Или СтрНачинаетсяС(Результат, "4")
			Или СтрНачинаетсяС(Результат, "5")
			Или СтрНачинаетсяС(Результат, "6")
			Или СтрНачинаетсяС(Результат, "7")
			Или СтрНачинаетсяС(Результат, "8")
			Или СтрНачинаетсяС(Результат, "9") Тогда
				
		Результат = "_" + Результат;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ТекстЗапроса - Строка
// 
// Возвращаемое значение:
//  Булево
//
Функция ЕстьКакоеЛибоУсловиеВЗапросе(Знач ТекстЗапроса) Экспорт
	
	Возврат СтрНайти(ТекстЗапроса, "ГДЕ ") > 0 Или СтрНайти(ТекстЗапроса, "ГДЕ" + Символы.ПС) > 0
			Или СтрНайти(ТекстЗапроса, "WHERE ") > 0 Или СтрНайти(ТекстЗапроса, "WHERE" + Символы.ПС) > 0;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Параметры:
//  СтрокаДляПроверки - Строка
// 
// Возвращаемое значение:
//  Булево
//
Функция ТолькоЗаглавныеВСтроке(Знач СтрокаДляПроверки)
	
	Для Позиция = 1 По СтрДлина(СтрокаДляПроверки) Цикл Символ = Сред(СтрокаДляПроверки, Позиция, 1); Если Символ <> ВРег(Символ) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
	Возврат Истина;
	
КонецФункции

// Возвращаемое значение:
//  Строка
//
Функция RegexDateTimeISO8601()
	// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
	
	Возврат "^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$";
	
КонецФункции

#Если Не ВебКлиент Тогда

// Параметры:
//  РегулярноеВыражение - см. СтрокаСоответствуетРегулярномуВыражению.РегулярноеВыражение
// 
// Возвращаемое значение:
//	ЗначениеXDTO:
//		* TestItem - Строка
//
Функция СформироватьОбъектXDTOДляПроверкиРегулярногоВыражения(Знач РегулярноеВыражение)
	
	XDTOШаблон = СтрШаблон(
			
			"<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
			|	<package targetNamespace=""sample-my-package"">
			|		<valueType name=""testtypes"" base=""xs:string"">
			|			<pattern>%1</pattern>
			|		</valueType>
			|		<objectType name=""TestObj"">
			|			<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes"" />
			|		</objectType>
			|	</package>
			|</Model>",
			
			СтрЗаменить(РегулярноеВыражение, "&", "&amp;"));
			
	
	ЧтениеXML = Новый ЧтениеXML();
    ЧтениеXML.УстановитьСтроку(XDTOШаблон);
	МодельXDTOДляЧтения = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	МояФабрикаXDTO = Новый ФабрикаXDTO(МодельXDTOДляЧтения);
		
    ПакетДляПроверки = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Возврат МояФабрикаXDTO.Создать(ПакетДляПроверки.Получить("TestObj"));
	
КонецФункции

#КонецЕсли

#Область Типизация

// Возвращаемое значение:
//  Массив из см. НоваяСтруктураРезультатаДляПоискаПохожихСтрок
//
Функция НовыйМассивРезультатПоискаПохожихСтрок()
		
	Возврат Новый Массив();
		
КонецФункции

// Параметры:
//  СтрокаРезультат - Строка
//  РасстояниеЛевенштейна - Число
// 
// Возвращаемое значение:
//  Структура:
// * СтрокаРезультат - Строка
// * РасстояниеЛевенштейна - Число
//
Функция НоваяСтруктураРезультатаДляПоискаПохожихСтрок(Знач СтрокаРезультат, Знач РасстояниеЛевенштейна)
	
	Возврат Новый Структура("СтрокаРезультат, РасстояниеЛевенштейна", СтрокаРезультат, РасстояниеЛевенштейна);
	
КонецФункции

#КонецОбласти

#КонецОбласти
