// @strict-types

// Безопасный режим - отстой (:
//@skip-check server-execution-safe-mode
//@skip-check method-too-many-params

#Область ПрограммныйИнтерфейс

// Формирует и выводит сообщение, которое может быть связано с элементом управления формы.
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле - Строка - наименование реквизита формы.
//  ПутьКДанным - Строка - путь к данным (путь к реквизиту формы).
//  Отказ - Булево - выходной параметр, всегда устанавливается в значение Истина.
//  ИдентификаторНазначения - Неопределено, УникальныйИдентификатор - Уникальный идентификатор назначения сообщения
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  Спец_ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  Спец_ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  Спец_ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  Спец_ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  Спец_ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимого.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(Знач ТекстСообщенияПользователю, Знач КлючДанных = Неопределено, Знач Поле = "", Знач ПутьКДанным = "", Отказ = Ложь, Знач ИдентификаторНазначения = Неопределено) Экспорт
	
	ЭтоОбъект = Ложь;
	Если КлючДанных <> Неопределено И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ЭтоОбъект = ЭтоОбъектныйТип(КлючДанных);
	КонецЕсли;
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле  = Поле;
	
	Если ИдентификаторНазначения <> Неопределено Тогда
		Сообщение.ИдентификаторНазначения = ИдентификаторНазначения;
	КонецЕсли;
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если Не ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
	
	Сообщение.Сообщить();
	Отказ = Истина;
	
КонецПроцедуры

// Помещает ошибки в регистр "Спец_РегистрОшибок".
// 
// Параметры:
//  Источник - Строка
//  		 - Произвольный - Источник ошибки, нужен для дальнейшего определения - где именно возникла ошибка.
//  ТекстОшибкиИлиИнформацияОбОшибке - Строка
//  								 - ИнформацияОбОшибке - Данные об ошибке
//  УровеньБазы - Неопределено, ПеречислениеСсылка.УровеньБазы - Уровень базы для записи ошибки (по умолчанию ГлавныйУзел)
//  ТолькоЗаписьОшибки - Булево - Если ЛОЖЬ, то в текст ошибки будет добавлена информация по текущему клиенту вызова.
//  ИсключитьКэш - Булево - Системный флаг (если ошибки с кэшом, то можно передать ИСТИНА)
//  Скриншот - Неопределено, ДвоичныеДанные - Двоичные данные скриншота экрана (или любого изображения), которое необходимо записать в регистр.
//
Процедура ЗаписатьОшибки(Знач Источник, Знач ТекстОшибкиИлиИнформацияОбОшибке, Знач УровеньБазы = Неопределено, Знач ТолькоЗаписьОшибки = Ложь,
		Знач ИсключитьКэш = Ложь, Знач Скриншот = Неопределено) Экспорт
	
	Если ТолькоЗаписьОшибки Тогда
		ТекстОшибкиДляЗаписи = СокрЛП(ТекстОшибкиИлиИнформацияОбОшибке);
	Иначе
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибкиИлиИнформацияОбОшибке, Источник, ТекстОшибкиДляЗаписи);
	КонецЕсли;
	
	Если ПустаяСтрока(ТекстОшибкиДляЗаписи) Тогда Возврат; КонецЕсли;
	Если УровеньБазы = Неопределено Тогда УровеньБазы = Перечисления.УровеньБазы.ГлавныйУзел; КонецЕсли;
	
	Источник   = Строка(Источник);
	ДатаОшибки = ТекущаяДатаСеанса();
	
	Если Не ИсключитьКэш Тогда
		Спец_ЗаписатьЛог(Источник, Перечисления.Спец_УровниЛогирования.Ошибка, ТекстОшибкиДляЗаписи);
	КонецЕсли;
	
	НаборЗаписей = РегистрыСведений.Спец_РегистрОшибок.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Период.Установить(ДатаОшибки);
	НаборЗаписей.Отбор.Источник.Установить(Источник);
	
	НаборЗаписей.Прочитать();
	Если НаборЗаписей.Количество() Тогда
		
		ЗаписьДляРедактирования = НаборЗаписей.Получить(0);
		
	Иначе
		
		ЗаписьДляРедактирования = НаборЗаписей.Добавить();
		
		ЗаписьДляРедактирования.Период   = ДатаОшибки;
		ЗаписьДляРедактирования.Источник = Источник;
		
	КонецЕсли;
	
	ЗаписьДляРедактирования.ТекстОшибки = ТекстОшибкиДляЗаписи;
	ЗаписьДляРедактирования.УровеньБазы = УровеньБазы;
	
	Если Скриншот <> Неопределено Тогда
		ЗаписьДляРедактирования.Скриншот = Новый ХранилищеЗначения(Скриншот, Новый СжатиеДанных(9));
	КонецЕсли;
	
	Если ИсключитьКэш Тогда
		
		НаборЗаписей.ОбменДанными.Загрузка = Истина;
		НаборЗаписей.ДополнительныеСвойства.Вставить("Спец_ПропуститьОбработки", Истина);
		
		НаборЗаписей.Записать();
		
	Иначе
		
		ЗаписатьОбъект(НаборЗаписей);
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает ключ записи регистра.
// 
// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - Строка - Полное имя объекта метаданных в 1С
//  							 - ОбъектМетаданныхРегистрРасчета
//  							 - ОбъектМетаданныхРегистрСведений
//  							 - ОбъектМетаданныхРегистрБухгалтерии
//  							 - ОбъектМетаданныхРегистрНакопления
//  СтруктураЗначений - Структура - Структура ключевых измерений
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  - РегистрНакопленияКлючЗаписи
//	- РегистрБухгалтерииКлючЗаписи
//	- РегистрСведенийКлючЗаписи
//	- РегистрРасчетаКлючЗаписи
//
Функция ПолучитьКлючЗаписиРегистраПоСтруктуреЗначений(Знач ОбъектМетаданныхИлиПолноеИмя, Знач СтруктураЗначений, Кэш = Неопределено) Экспорт
	
	СтруктураПоМетаданным = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ОбъектМетаданныхИлиПолноеИмя, Кэш);
	Возврат СтруктураПоМетаданным.МенеджерОбъекта.СоздатьКлючЗаписи(СтруктураЗначений);
	
КонецФункции

// Определяет режим эксплуатации информационной базы файловый (Истина) или серверный (Ложь).
// При проверке используется справочник Спец_Базы.
//
// Возвращаемое значение:
//  Булево - Истина, если файловая.
Функция ЭтоФайловаяИнформационнаяБаза() Экспорт
	
	ТекущаяБаза = Спец_ОбщегоНазначенияПовтИсп.ЗначениеПараметраСеанса("Спец_ТекущаяБаза"); // СправочникСсылка.Спец_Базы
	Возврат ?(ЗначениеЗаполнено(ТекущаяБаза), ЗначениеРеквизитаОбъекта(ТекущаяБаза, "ТипБазыДанных") = Перечисления.Спец_ТипыБазыДанных.Файловая, Ложь);
	
КонецФункции

// Метод для сжатия объекта (сериализации).
// 
// Параметры:
//  Объект - Произвольный
// 
// Возвращаемое значение:
//  Строка
//
Функция СериализоватьОбъект(Знач Объект) Экспорт
	
	Если ТипЗнч(Объект) = Тип("ХранилищеЗначения") Тогда Возврат СериализаторXDTO.XMLСтрока(Объект); Иначе ХранилищеЗначения = Новый ХранилищеЗначения(Объект, Новый СжатиеДанных(9)); Возврат СериализаторXDTO.XMLСтрока(ХранилищеЗначения); КонецЕсли;
	
КонецФункции

// Метод для разжатия объекта (десериализации, обратный метод для СериализоватьОбъект).
// 
// Параметры:
//  СтрокаXML - Строка
// 
// Возвращаемое значение:
//  Произвольный
//
Функция ДеСериализоватьОбъект(Знач СтрокаXML) Экспорт
	
	Возврат СериализаторXDTO.XMLЗначение(Тип("ХранилищеЗначения"), СтрокаXML).Получить();
	
КонецФункции

// Возвращает содержимое хранилища значения. Если вызвано с клиента, то нужно учитывать, что значение должно быть сериализуемо.
// 
// Параметры:
//  ХранилищеЗначения - ХранилищеЗначения
// 
// Возвращаемое значение:
//  Произвольный
//
Функция ПолучитьЗначениеХранилищаЗначения(Знач ХранилищеЗначения) Экспорт
	
	Возврат ХранилищеЗначения.Получить();
	
КонецФункции

// Метод для вызова функции / процедуры во внешней обработке.
// Должна быть установлена подсистема "ВнешниеОбработки"
// 
// Параметры:
//  ИмяОбработкиИлиСсылка - Строка - Спец_ОбщегоНазначенияПовтИсп.ПодключитьВнешнююОбработку.ИмяОбработкиИлиСсылка
//  ИмяФункцииИлиПроцедуры - Строка - Имя метода для вызова
//  ЭтоПроцедура - Булево - Флаг того, что нужно вызвать "Выполнить", а не "Вычислить"
//  МассивПараметров - Неопределено
//  				 - Массив из Произвольный,
//  				 - ФиксированныйМассив из Произвольный - Массив параметров для передачи в процедуру
// 
// Возвращаемое значение:
//  Произвольный - Если нужно вызвать функцию (результат выполнения данной функции)
//	Булево - Флаг того, что процедура была выполнена успешно
//
Функция ВызватьФункциюВоВнешнейОбработке(Знач ИмяОбработкиИлиСсылка, Знач ИмяФункцииИлиПроцедуры, Знач ЭтоПроцедура = Истина, Знач МассивПараметров = Неопределено) Экспорт
	
	// ++ Спец_БСП.ВнешниеОбработки
	УстановитьПривилегированныйРежим(Истина);
	УстановитьБезопасныйРежим(Ложь);
	
	АдресОбработки = Спец_ОбщегоНазначенияПовтИсп.ПодключитьВнешнююОбработку(ИмяОбработкиИлиСсылка);
	Спец_Проверить(АдресОбработки, "Не удалось подключить внешнюю обработку " + Строка(ИмяОбработкиИлиСсылка));
	
	//@skip-check module-unused-local-variable
	ВнешняяОбработкаОбъект = ВнешниеОбработки.Создать(АдресОбработки);
	ПараметрыСтрока = "";
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивПараметров);
	Если МассивПараметров.Количество() = 0 Тогда
		
		МассивСтрокаДляПередачи = Новый Массив; // Массив из Строка
		Для i = 0 По МассивПараметров.ВГраница() Цикл
			МассивСтрокаДляПередачи.Добавить(СтрШаблон("МассивПараметров.Получить(%1)", Формат(i, "ЧН=0; ЧГ=")));
		КонецЦикла;
		
		ПараметрыСтрока = СтрСоединить(МассивСтрокаДляПередачи, ",");
		
	КонецЕсли;
	
	ВыполняемыйМетод = "ВнешняяОбработкаОбъект." + ИмяФункцииИлиПроцедуры + "(" + ПараметрыСтрока + ")";
	Если ЭтоПроцедура Тогда
		
		Выполнить ВыполняемыйМетод;
		Результат = Истина; // см. ВызватьФункциюВоВнешнейОбработке
		
	Иначе
		
		Результат = Вычислить(ВыполняемыйМетод); // см. ВызватьФункциюВоВнешнейОбработке
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	Возврат Результат;
	// -- Спец_БСП.ВнешниеОбработки
	
КонецФункции

// Вычисляет контрольную сумму для произвольных данных по указанному алгоритму.
//
// Параметры:
//  Данные   - Произвольный - любое сериализуемое значение.
//  Алгоритм - ХешФункция   - алгоритм расчета контрольной суммы. По умолчанию, MD5.
// 
// Возвращаемое значение:
//  Строка - контрольная сумма строкой без пробелов (например 32 символа).
//
Функция ПолучитьКонтрольнуюСуммуСтрокой(Знач Данные, Знач Алгоритм = Неопределено) Экспорт
	
	Если Алгоритм = Неопределено Тогда
		Алгоритм = ХешФункция.MD5;
	КонецЕсли;
	
	ХешированиеДанных = Новый ХешированиеДанных(Алгоритм);
	Если ТипЗнч(Данные) <> Тип("Строка") И ТипЗнч(Данные) <> Тип("ДвоичныеДанные") Тогда
		Данные = XMLСтрока(Данные);
	КонецЕсли;
	ХешированиеДанных.Добавить(Данные);
	
	ТипОбъекта = ТипЗнч(ХешированиеДанных.ХешСумма);
	Если ТипОбъекта = Тип("ДвоичныеДанные") Тогда
		Возврат Спец_СтроковыеФункцииКлиентСервер.СформироватьТекстовоеПредставлениеОбъекта(ХешированиеДанных.ХешСумма);
	ИначеЕсли ТипОбъекта = Тип("Число") Тогда
		Возврат Формат(ХешированиеДанных.ХешСумма, "ЧГ=");
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

// Возвращает значение константы.
// Есть возможность динамического добавления константы, для этого необходимо передать строку-наименование необходимой константы.
// 		Если нужной константы не существовало, то создаёт со значением по умолчанию.
// Есть возможность иерархического хранения константы, для этого необходимо через слеш прописать нужный путь, например:
// 		"ПараметрыХраненияБазы/ЕщёОднаГруппаДляХраненияКонстанты/НужнаяКонстанта".
// Есть возможность хранения истории значений констант, для этого необходимо передать заполненный параметр НаДату.
// 		Если у константы уже было установлено значение, то НаДату определяет на какую дату необходимо вернуть значение константы.
// 
// Параметры:
//  КодИлиСсылкаПВХ - Строка, ПланВидовХарактеристикСсылка.Спец_Константы - Константа для определения значения.
//  ЗначениеПоУмолчанию - Неопределено, Произвольный - Значение по умолчанию для константы. Заполняется автоматически, если у константы не было указано никакого значения.
//  НаДату - Неопределено, Дата - 
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Произвольный
//
Функция ПолучитьКонстантуСпец(Знач КодИлиСсылкаПВХ, Знач ЗначениеПоУмолчанию = Неопределено, Знач НаДату = Неопределено, Кэш = Неопределено) Экспорт
	
	Возврат ?(ТипЗнч(КодИлиСсылкаПВХ) = Тип("ПланВидовХарактеристикСсылка.Спец_Константы"),
			ПолучитьКонстантуСпецПоПВХ(КодИлиСсылкаПВХ, ЗначениеПоУмолчанию, НаДату, Кэш),
			ПолучитьКонстантуСпецПоКоду(КодИлиСсылкаПВХ, ЗначениеПоУмолчанию, НаДату, Ложь, Кэш));
	
КонецФункции

// Устанавливает значение константы.
// Есть возможность динамического добавления константы, для этого необходимо передать строку-наименование необходимой константы.
// 		Если нужной константы не существовало, то создаёт со значением по умолчанию.
// Есть возможность иерархического хранения константы, для этого необходимо через слеш прописать нужный путь, например:
// 		"ПараметрыХраненияБазы/ЕщёОднаГруппаДляХраненияКонстанты/НужнаяКонстанта".
// 		Если у константы уже было установлено значение, то НаДату определяет на какую дату необходимо вернуть значение константы.
// 
// Параметры:
//  КодИлиСсылкаПВХ - см. ПолучитьКонстантуСпец.КодИлиСсылкаПВХ
//  Значение - Произвольный
//  ХранитьИсторию - Булево
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура УстановитьКонстантуСпец(Знач КодИлиСсылкаПВХ, Знач Значение, Знач ХранитьИсторию = Истина, Кэш = Неопределено) Экспорт
	
	ПериодКонстанты = ?(ХранитьИсторию, ТекущаяДатаСеанса(), Дата(1, 1, 1));
	ПВХ = ?(ТипЗнч(КодИлиСсылкаПВХ) = Тип("ПланВидовХарактеристикСсылка.Спец_Константы"),
			КодИлиСсылкаПВХ,
			ПолучитьКонстантуСпецПоКоду(КодИлиСсылкаПВХ, Значение, ПериодКонстанты, Истина, Кэш));
	
	ПолучитьКонстантуСпецЗаписатьЗначениеПоПВХ(ПВХ, Значение, ПериодКонстанты, ТипЗнч(Значение), Кэш);
	
КонецПроцедуры

// Метод для обновления данных в текущей конфигурации.
// 
// Параметры:
//  ИдентификаторЗадания - Строка - Идентификатор фонового задания.
Процедура ОбновлениеКонфигурации(Знач ИдентификаторЗадания = "") Экспорт
	
	ОбщийКэш = Спец_ПолучитьКэш();
	
	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания("Заполнение констант по умолчанию", ИдентификаторЗадания, 1);
	
	УстановитьКонстантыПоУмолчанию(ОбщийКэш);
	
	ТипБазыДанных = Спец_ОбщегоНазначенияПовтИсп.СтруктураПараметровБазы().ТипБазыДанных;
	
	// ++ Спец_БСП.ПодключаемоеОборудование
	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания("Подключаемое оборудование", ИдентификаторЗадания, 3);
	// ???
	//@skip-check unknown-method-property
	Спец_ОбщегоНазначенияВызовСервера.ОбновитьДрайвераПодключаемогоОборудования();
	// -- Спец_БСП.ПодключаемоеОборудование
	
	// ++ Спец_БСП.Спец_НочнойРасчет
	#Область НочнойРасчет
	
	Спец_РаботаСФоновымиЗаданиями.СообщитьСтатусВыполненияЗадания("Перезаполнение ""Ночного расчёта""", ИдентификаторЗадания, 10);

	// Заполняем предопределенные регламентные задания.
	ТаблицаРезультат = ПолучитьТаблицуТекущихНастроекНочногоРасчета();
	МассивСтрокДляУдаления = Новый Массив; // Массив из СтрокаТаблицыЗначений
	
	РегламентСпецНочнойРасчет = Метаданные.РегламентныеЗадания.Найти("Спец_НочнойРасчет");
	Для Каждого РегламентноеЗадание Из Метаданные.РегламентныеЗадания Цикл
		
		Если РегламентноеЗадание = РегламентСпецНочнойРасчет Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураОтбора = Новый Структура("ИмяМетаданныхРегламента", РегламентноеЗадание.Имя);
		МассивСтрок = ТаблицаРезультат.НайтиСтроки(СтруктураОтбора);
		Если МассивСтрок.Количество() Тогда
			
			Для Каждого Строка Из МассивСтрок Цикл
				МассивСтрокДляУдаления.Добавить(Строка);
			КонецЦикла;
			
			Продолжить;
			
		КонецЕсли;
		
		НаборЗаписей = РегистрыСведений.Спец_НастройкиНочногоРасчета.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.ИмяПроцедурыВыполнения.Установить(РегламентноеЗадание.ИмяМетода);
		НаборЗаписей.Отбор.ИмяМетаданныхРегламента.Установить(РегламентноеЗадание.Имя);
		
		НаборЗаписей.Прочитать();
		НаборЗаписей.Очистить();
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		НоваяЗапись.ИмяПроцедурыВыполнения = РегламентноеЗадание.ИмяМетода;
		НоваяЗапись.ИмяМетаданныхРегламента = РегламентноеЗадание.Имя;
		НоваяЗапись.ПорядокВыполнения = 1;
		
		ЗаписатьОбъект(НаборЗаписей, , "", Ложь, ОбщийКэш);
		
	КонецЦикла;
	
	Для Каждого СтрокаДляУдаления Из МассивСтрокДляУдаления Цикл
		ТаблицаРезультат.Удалить(СтрокаДляУдаления);
	КонецЦикла;
	
	Для Каждого СтрокаДляОчистки Из ТаблицаРезультат Цикл
		
		НаборЗаписей = РегистрыСведений.Спец_НастройкиНочногоРасчета.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.ИмяПроцедурыВыполнения.Установить(СтрокаДляОчистки.ИмяПроцедурыВыполнения);
		НаборЗаписей.Отбор.ИмяМетаданныхРегламента.Установить(СтрокаДляОчистки.ИмяМетаданныхРегламента);
		
		ЗаписатьОбъект(НаборЗаписей, , "", Ложь, ОбщийКэш);
		
	КонецЦикла;
	
	// Заполняем ручные регламентные задания по умолчанию
	ТаблицаРезультат = ПолучитьТаблицуТекущихРучныхНастроекНочногоРасчета();
	Если ТипБазыДанных = Перечисления.Спец_ТипыБазыДанных.PostgreSQL Тогда
		
		// 1. Обновление структуры БД
		СтрокаОбновлениеСтруктурыБД = ТаблицаРезультат.Найти("Спец_PostgreSQL.ОбновитьСтруктуруТаблицPostgreSQL", "ИмяПроцедурыВыполнения");
		Если СтрокаОбновлениеСтруктурыБД = Неопределено Тогда
			
			НаборЗаписей = РегистрыСведений.Спец_НастройкиНочногоРасчета.СоздатьНаборЗаписей();
			
			НаборЗаписей.Отбор.ИмяПроцедурыВыполнения.Установить("Спец_PostgreSQL.ОбновитьСтруктуруТаблицPostgreSQL");
			НаборЗаписей.Отбор.ИмяМетаданныхРегламента.Установить("");
			
			НаборЗаписей.Прочитать();
			НаборЗаписей.Очистить();
			
			НоваяЗапись = НаборЗаписей.Добавить();
			
			НоваяЗапись.ИмяПроцедурыВыполнения = "Спец_PostgreSQL.ОбновитьСтруктуруТаблицPostgreSQL";
			НоваяЗапись.ИмяМетаданныхРегламента = "";
			НоваяЗапись.Запускать = Истина;
			НоваяЗапись.ПорядокВыполнения = 2;
			НоваяЗапись.Ручной = Истина;
			
			ЗаписатьОбъект(НаборЗаписей, , "", Ложь, ОбщийКэш);
			
		КонецЕсли;
		
		// 2. Кластеризация (очистка) всех таблиц
		СтрокаКластеризацияОчисткаВсехТаблиц = ТаблицаРезультат.Найти("Спец_PostgreSQL.КластеризацияОчисткаВсехТаблиц", "ИмяПроцедурыВыполнения");
		Если СтрокаКластеризацияОчисткаВсехТаблиц = Неопределено Тогда
			
			НаборЗаписей = РегистрыСведений.Спец_НастройкиНочногоРасчета.СоздатьНаборЗаписей();
			
			НаборЗаписей.Отбор.ИмяПроцедурыВыполнения.Установить("Спец_PostgreSQL.КластеризацияОчисткаВсехТаблиц");
			НаборЗаписей.Отбор.ИмяМетаданныхРегламента.Установить("");
			
			НаборЗаписей.Прочитать();
			НаборЗаписей.Очистить();
			
			НоваяЗапись = НаборЗаписей.Добавить();
			
			НоваяЗапись.ИмяПроцедурыВыполнения = "Спец_PostgreSQL.КластеризацияОчисткаВсехТаблиц";
			НоваяЗапись.ИмяМетаданныхРегламента = "";
			НоваяЗапись.Запускать = Истина;
			НоваяЗапись.ПорядокВыполнения = 3;
			НоваяЗапись.Ручной = Истина;
			
			ЗаписатьОбъект(НаборЗаписей, , "", Ложь, ОбщийКэш);
			
		КонецЕсли;
		
		// 3. Таблицы в кэш
		СтрокаТаблицыВКэш = ТаблицаРезультат.Найти("Спец_PostgreSQL.ЗакинутьТаблицыВОперативнуюПамять", "ИмяПроцедурыВыполнения");
		Если СтрокаТаблицыВКэш = Неопределено Тогда
			
			НаборЗаписей = РегистрыСведений.Спец_НастройкиНочногоРасчета.СоздатьНаборЗаписей();
			
			НаборЗаписей.Отбор.ИмяПроцедурыВыполнения.Установить("Спец_PostgreSQL.ЗакинутьТаблицыВОперативнуюПамять");
			НаборЗаписей.Отбор.ИмяМетаданныхРегламента.Установить("");
			
			НаборЗаписей.Прочитать();
			НаборЗаписей.Очистить();
			
			НоваяЗапись = НаборЗаписей.Добавить();
			
			НоваяЗапись.ИмяПроцедурыВыполнения = "Спец_PostgreSQL.ЗакинутьТаблицыВОперативнуюПамять";
			НоваяЗапись.ИмяМетаданныхРегламента = "";
			НоваяЗапись.Запускать = Истина;
			НоваяЗапись.ПорядокВыполнения = 4;
			НоваяЗапись.Ручной = Истина;
			
			ЗаписатьОбъект(НаборЗаписей, , "", Ложь, ОбщийКэш);
			
		КонецЕсли;
		
	КонецЕсли;
	
	// 4. Чистка старых лишних данных
	СтрокаКластеризацияОчисткаВсехТаблиц = ТаблицаРезультат.Найти("Спец_МодульРегламентныхЗаданий.ЧисткаСтарыхЛишнихДанных", "ИмяПроцедурыВыполнения");
	Если СтрокаКластеризацияОчисткаВсехТаблиц = Неопределено Тогда
		
		НаборЗаписей = РегистрыСведений.Спец_НастройкиНочногоРасчета.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.ИмяПроцедурыВыполнения.Установить("Спец_МодульРегламентныхЗаданий.ЧисткаСтарыхЛишнихДанных");
		НаборЗаписей.Отбор.ИмяМетаданныхРегламента.Установить("");
		
		НаборЗаписей.Прочитать();
		НаборЗаписей.Очистить();
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		НоваяЗапись.ИмяПроцедурыВыполнения = "Спец_МодульРегламентныхЗаданий.ЧисткаСтарыхЛишнихДанных";
		НоваяЗапись.ИмяМетаданныхРегламента = "";
		НоваяЗапись.Запускать = Истина;
		НоваяЗапись.ПорядокВыполнения = 1;
		НоваяЗапись.Ручной = Истина;
		
		ЗаписатьОбъект(НаборЗаписей, , "", Ложь, ОбщийКэш);
		
	КонецЕсли;
	
	#КонецОбласти
	// -- Спец_БСП.Спец_НочнойРасчет
	
	#Область ОбновлениеТаблицБазыДанных
	
	Если ТипБазыДанных = Перечисления.Спец_ТипыБазыДанных.PostgreSQL Тогда
		
		Попытка
			Спец_PostgreSQL.ОбновитьСтруктуруТаблицPostgreSQL(ИдентификаторЗадания);
		Исключение
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(), "Спец_PostgreSQL.ОбновитьСтруктуруТаблицPostgreSQL");
		КонецПопытки;
		
	КонецЕсли;
	
	#КонецОбласти
	
	Спец_РаботаСФоновымиЗаданиями.ЗавершитьРаботуПоФоновомуЗаданию(ИдентификаторЗадания);
	
КонецПроцедуры

// Возвращает количество строк результат динамического списка (с учётом отборов)
// 
// Параметры:
//  ЭлементСписок - РасширениеТаблицыФормыДляДинамическогоСписка
// 
// Возвращаемое значение:
//  Число
//
Функция ПолучитьКоличествоСтрокРезультатДинамическогоСписка(Знач ЭлементСписок) Экспорт
	
	КоличествоСтрокРезультат = 0;
	
	#Если Сервер Тогда
		
		КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных();
		МакетКомпоновки   = КомпоновщикМакета.Выполнить(ЭлементСписок.ПолучитьИсполняемуюСхемуКомпоновкиДанных(),
				ЭлементСписок.ПолучитьИсполняемыеНастройкиКомпоновкиДанных(),
				,,
				Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
		
		//@skip-check property-return-type
		ИсходныйЗапрос = МакетКомпоновки.НаборыДанных.НаборДанныхДинамическогоСписка.Запрос; // Строка
		
		// Составной запрос или нет
		ПозицияРазделенияЗапросов = СтрНайти(ИсходныйЗапрос, ";" + Символы.ПС, НаправлениеПоиска.СКонца);
		ПозицияИз = СтрНайти(ИсходныйЗапрос,
				"ИЗ" + Символы.ПС,
				,
				?(ПозицияРазделенияЗапросов = 0, 1, ПозицияРазделенияЗапросов));
			
		Если ПозицияИз = 0 Тогда
			Возврат КоличествоСтрокРезультат;
		КонецЕсли;
		
		ПозицияВыбрать = СтрНайти(ИсходныйЗапрос, "ВЫБРАТЬ ", НаправлениеПоиска.СКонца, ПозицияИз);
		Если ПозицияВыбрать = 0 Тогда
			ПозицияВыбрать = СтрНайти(ИсходныйЗапрос, "ВЫБРАТЬ" + Символы.ПС, НаправлениеПоиска.СКонца, ПозицияИз);
		КонецЕсли;
		
		Если ПозицияВыбрать = 0 Тогда
			Возврат КоличествоСтрокРезультат;
		КонецЕсли;
		
		// Убираем упорядочивание
		ПозицияУпорядочить = СтрНайти(ИсходныйЗапрос, "УПОРЯДОЧИТЬ ПО", НаправлениеПоиска.СКонца);
		Если ПозицияУпорядочить Тогда
			ИсходныйЗапрос = Лев(ИсходныйЗапрос, ПозицияУпорядочить);
		КонецЕсли;
		
		Запрос = Новый Запрос();
		
		// Если запрос с объединением, то просто оборачиваем запрос во вложенную таблицу
		Если СтрНайти(ИсходныйЗапрос, "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС, , ПозицияВыбрать) Тогда
			
			// Убираем разрешённые, иначе ошибка (РАЗРЕШЕННЫЕ можно только в первом запросе)
			Запрос.Текст = Сред(ИсходныйЗапрос, 1, ПозицияВыбрать - 1)
					+ СтрШаблон("ВЫБРАТЬ КОЛИЧЕСТВО(*) КАК Спец_КоличествоСтрокРезультат
							|ИЗ (%1) КАК Спец_ТаблицаПоследнегоЗапроса",
							СтрЗаменить(Сред(ИсходныйЗапрос, ПозицияВыбрать), "РАЗРЕШЕННЫЕ", ""));
			
		Иначе
			
			Запрос.Текст = СтрЗаменить(ИсходныйЗапрос,
					Сред(ИсходныйЗапрос, ПозицияВыбрать, ПозицияИз - ПозицияВыбрать - 1),
					"ВЫБРАТЬ КОЛИЧЕСТВО(*) КАК Спец_КоличествоСтрокРезультат");
			
		КонецЕсли;
		
		Для Каждого ПараметрДляУстановки Из МакетКомпоновки.ЗначенияПараметров Цикл
			
			ЗначениеДляУстановки = Неопределено;
			
			Если ТипЗнч(ПараметрДляУстановки.Значение) = Тип("ВыражениеКомпоновкиДанных") Тогда
				
				Попытка
					
					//@skip-check property-return-type
					ЗначениеДляУстановки = Вычислить(Строка(ПараметрДляУстановки.Значение));
					
				Исключение
					
					//@skip-check module-unused-local-variable
					tmp = Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке());
					
				КонецПопытки;
				
			Иначе
				
				ЗначениеДляУстановки = ПараметрДляУстановки.Значение;
				
			КонецЕсли;
			
			Запрос.УстановитьПараметр(ПараметрДляУстановки.Имя, ЗначениеДляУстановки);
			
		КонецЦикла;
		
		Попытка
			Возврат ПолучитьСтруктуруПервойВыборкиЗапроса(Запрос, "Спец_КоличествоСтрокРезультат");
		Исключение
			Возврат КоличествоСтрокРезультат;
		КонецПопытки;
		
	#Иначе
		
		Возврат КоличествоСтрокРезультат;
		
	#КонецЕсли
	
КонецФункции

#Область РаботаССервисЗапросами

// Формирует HTTP сервис-ответ для HTTP-запросов с учётом стандартных заголовков и данных для возврата.
// Есть возможность передать заголовки для скачивания файла.
// 
// Параметры:
//  КодВозврата - Число
//  ДанныеДляВозврата - см. Спец_ОбщегоНазначенияКлиентСервер.ЗаполнитьТелоHTTPЗапроса.ДанныеДляЗапроса
//  ПередатьЗаголовкиСкачиванияФайла - Булево - Если ИСТИНА, то передаёт заголовок для скачивания файла.
//  ИмяФайлаДляСкачивания - Строка - Имя файла для скачивания
//  ИсходныйЗапрос - см. Спец_ОбщегоНазначенияКлиентСервер.ЗаполнитьТелоHTTPЗапроса.ИсходныйЗапрос
// 
// Возвращаемое значение:
//  Неопределено, HTTPСервисОтвет -
Функция ПодготовитьHTTPСервисОтветПоУмолчанию(Знач КодВозврата, Знач ДанныеДляВозврата = Неопределено, Знач ПередатьЗаголовкиСкачиванияФайла = Ложь,
		Знач ИмяФайлаДляСкачивания = "", Знач ИсходныйЗапрос = Неопределено) Экспорт
	
	#Если Не ВнешнееСоединение И Не ТолстыйКлиентОбычноеПриложение Тогда
	
		HTTPСервисОтвет = Новый HTTPСервисОтвет(КодВозврата, , Спец_ОбщегоНазначенияКлиентСервер.ЗаголовкиДляHTTPЗапросовПоУмолчанию());
		Спец_ОбщегоНазначенияКлиентСервер.ЗаполнитьТелоHTTPЗапроса(HTTPСервисОтвет, ДанныеДляВозврата, ИсходныйЗапрос);
		
		Если ПередатьЗаголовкиСкачиванияФайла Тогда
			HTTPСервисОтвет.Заголовки.Вставить("Content-Disposition", "attachment; filename=" + КодироватьСтроку(ИмяФайлаДляСкачивания, СпособКодированияСтроки.КодировкаURL));
		КонецЕсли;
		
		Возврат HTTPСервисОтвет;
		
	#Иначе
		
		Возврат Неопределено;
		
	#КонецЕсли
	
КонецФункции

// Подготавливает запись JSON для HTTP сервис-ответа и добавляет необходимый заголовок для передачи.
// 
// Параметры:
//  HTTPСервисОтвет - HTTPСервисОтвет
// 
// Возвращаемое значение:
//  ЗаписьJSON
Функция ПодготовитьЗаписьJSONПоHTTPСервисОтвету(Знач HTTPСервисОтвет) Экспорт
	
	#Если Не ВнешнееСоединение Тогда
		
		HTTPСервисОтвет.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		Возврат Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьЗаписьJSONПоПотоку(HTTPСервисОтвет.ПолучитьТелоКакПоток());
		
	#Иначе
		
		Возврат Неопределено;
		
	#КонецЕсли
	
КонецФункции

// Возвращает структуру входящего HTTP запроса (с учётом базы-отправителя запроса и потока тела запроса).
// Получает значения заголовков (см. Спец_ОбщегоНазначенияКлиентСервер.ЗаголовкиДляHTTPЗапросовПоУмолчанию)
// 
// Параметры:
//  HTTPСервисЗапрос - HTTPСервисЗапрос
// 
// Возвращаемое значение:
//  Структура:
//	* Отправитель - ОпределяемыйТип.Спец_Магазин - Определяет магазин отправителя HTTP запроса.
// 	* База - СправочникСсылка.Спец_Базы - Базу-отправитель HTTP запроса.
// 	* УровеньБазы - ПеречислениеСсылка.УровеньБазы - Уровень базы-отправителя HTTP запроса. По умолчанию ГлавныйУзел
// 	* РаботаетВБазеРайона - Булево - Определяет, работает ли отправитель в резервной базе.
// 	* Поток - Поток - Поток тела HTTP запроса
//
Функция ПолучитьСтруктуруВходящегоПотокаHTTPСервисЗапроса(Знач HTTPСервисЗапрос) Экспорт
	
	СтруктураПотока = НоваяСтруктураДанныхПоHTTPЗапросу();
	
	#Если Не ВнешнееСоединение Тогда
		
		// База
		Database = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(HTTPСервисЗапрос.Заголовки, "SPEC-Database", ""); // Строка
		Если Не ПустаяСтрока(Database) Тогда
			СтруктураПотока.База = Спец_ОбщегоНазначенияПовтИсп.ПолучитьБазуОтправителяПоЗаголовку(Database);
		КонецЕсли;
		
		// Уровень базы
		BaseLevel = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(HTTPСервисЗапрос.Заголовки, "SPEC-BaseLevel", ""); // Строка
		Если Не ПустаяСтрока(BaseLevel) Тогда
			
			Попытка
				
				//@skip-check statement-type-change
				СтруктураПотока.УровеньБазы = Перечисления.УровеньБазы.Получить(XMLЗначение(Тип("Число"), BaseLevel)); 
				
			Исключение
				
				//@skip-check module-unused-local-variable
				tmp = Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке());
				
			КонецПопытки;
			
		КонецЕсли;
		
		// Работает в базе района
		WorksInReserve = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(HTTPСервисЗапрос.Заголовки, "SPEC-WorksInReserve", "false"); // Строка
		
		Попытка
			
			СтруктураПотока.РаботаетВБазеРайона = XMLЗначение(Тип("Булево"), WorksInReserve);
			
		Исключение
			
			//@skip-check module-unused-local-variable
			tmp = Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке());
			
		КонецПопытки;
		
		// Отправитель
		UID = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(HTTPСервисЗапрос.Заголовки, "SPEC-UID", ""); // Строка
		Если Не ПустаяСтрока(UID) Тогда
			СтруктураПотока.Отправитель = Спец_ОбщегоНазначенияПовтИсп.ПолучитьОтправителяПоЗаголовку(UID);
		КонецЕсли;
		
		// Входящий поток
		СтруктураПотока.Поток = HTTPСервисЗапрос.ПолучитьТелоКакПоток();
		
		//@skip-check constructor-function-return-section
		Возврат СтруктураПотока;
		
	#Иначе
		
		Возврат СтруктураПотока;
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти

#Область РаботаСМетаданнымиИТипами

// Возвращает тип реквизита в 1С. Если тип составной - возвращает первый.
// 
// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - Строка - Объект метаданных или полное имя объекта метаданных для поиска
//  						 	 - см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
//  							 
//  ИмяРеквизита - Строка - Имя реквизита у объекта матеданных
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Тип, Неопределено - 
Функция ПолучитьТипРеквизитаВ1С(Знач ОбъектМетаданныхИлиПолноеИмя, Знач ИмяРеквизита, Кэш = Неопределено) Экспорт
	
	СтруктураПоРеквизитам = ПолучитьСтруктуруВсехРеквизитовОбъекта(ОбъектМетаданныхИлиПолноеИмя, Ложь, Кэш);
	
	СтруктураОтбора = Новый Структура("Имя", ИмяРеквизита);
	
	МетаданныеРеквизит = Спец_РаботаСКоллекциямиКлиентСервер.НайтиСтрокиВКоллекцииСтрок(СтруктураОтбора, СтруктураПоРеквизитам.МассивРеквизитов, Истина); // см. ОбъектМетаданныхРеквизит
	Если МетаданныеРеквизит = Неопределено Тогда
		
		Для Каждого КлючЗначение Из СтруктураПоРеквизитам.ТабличныеЧасти Цикл
			
			МетаданныеРеквизит = Спец_РаботаСКоллекциямиКлиентСервер.НайтиСтрокиВКоллекцииСтрок(СтруктураОтбора, КлючЗначение.Значение, Истина); // см. ОбъектМетаданныхРеквизит
			Если МетаданныеРеквизит <> Неопределено Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	//@skip-check property-return-type
	//@skip-check dynamic-access-method-not-found
	Возврат ?(МетаданныеРеквизит = Неопределено, Неопределено, МетаданныеРеквизит.Тип.Типы().Получить(0)); 
	
КонецФункции

// Возвращает структуру имён, менеджера, типов объекта по метаданным.
// 
// Параметры:
//  Объект - Строка
//  	   - см. ЗаписатьОбъект.ОбъектДляЗаписи
//  	   - ЛюбаяСсылка
//  	   - см. ПолучитьТипРеквизитаВ1С.ОбъектМетаданныхИлиПолноеИмя
//  	   - см. Спец_РаботаСФормами.ПриСозданииНаСервере.Форма
//  	   - Тип
//  	   - Произвольный
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Структура:
// * ИмяОбъекта - Строка - Имя объекта без типа объекта (например, "Спец_Базы")
// * ПолноеИмяОбъекта - Строка - Полное имя объекта в метаданных (например, "Справочник.Спец_Базы")
// * ТипОбъектаЕдинственноеЧисло - Строка - Имя типа объекта в единственном числе (например, "Справочник")
// * ТипОбъектаМножественноеЧисло - Строка - Имя типа объекта во множественном числе (например, "Справочники")
// * Тип - Тип - Если это ссылочный объект, то возвращает Тип("СправочникСсылка.ИмяСправочника")
// 				Если это регистр, то возвращает Тип("РегистрСведенийКлючЗаписи.ИмяРегистра")
// * МенеджерОбъекта - Неопределено
// 					 - БизнесПроцессМенеджер
// 					 - ДокументМенеджер
// 					 - ЗадачаМенеджер
// 					 - КонстантаМенеджерИмяКонстанты
// 					 - ОбработкаМенеджер
// 					 - ОтчетМенеджер
// 					 - ПланВидовРасчетаМенеджер
// 					 - ПланВидовХарактеристикМенеджер
// 					 - ПланОбменаМенеджер
// 					 - ПланСчетовМенеджер
// 					 - ПеречислениеМенеджер
// 					 - РегистрБухгалтерииМенеджер
// 					 - РегистрНакопленияМенеджер
// 					 - РегистрРасчетаМенеджер
// 					 - РегистрСведенийМенеджер
// 					 - СправочникМенеджер
// * МетаданныеОбъекта - см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
//
Функция ПолучитьСтруктуруИмениТипаДанныхОбъекта(Знач Объект, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	МетаданныеОбъекта = Неопределено; // ОбъектМетаданных
	
	ТипОбъекта = ТипЗнч(Объект);
	Если ТипОбъекта = Тип("Тип") Тогда
		
		Если Кэш.КэшПоМетаданным.СтруктураМетаданныхПоТипу[Объект] <> Неопределено Тогда Возврат Кэш.КэшПоМетаданным.СтруктураМетаданныхПоТипу[Объект]; КонецЕсли;
		МетаданныеОбъекта = ОбъектМетаданныхПоТипуВКэш(Объект, Кэш);
		
	ИначеЕсли ТипОбъекта = Тип("Строка") Тогда
		
		Если Кэш.КэшПоМетаданным.СтруктураМетаданныхПоПолномуИмени[Объект] <> Неопределено Тогда Возврат Кэш.КэшПоМетаданным.СтруктураМетаданныхПоПолномуИмени[Объект]; КонецЕсли;
		
	ИначеЕсли ТипОбъекта = Тип("ОбъектМетаданных") Тогда
		
		МетаданныеОбъекта = Объект;
		
	Иначе
		
		Попытка
			
			МетаданныеОбъекта = Объект.Метаданные();
			
		Исключение
			
			Попытка
				
				// Для обычной формы должен был отработать "Объект.Метаданные()" (если это ключевая форма). Для остальных - не можем определить тип.
				Если ТипОбъекта = Тип("Форма") Тогда
					ВызватьИсключение "Нет";
				КонецЕсли;
				
				Если Кэш.КэшПоМетаданным.СтруктураМетаданныхПоТипу[ТипОбъекта] <> Неопределено Тогда Возврат Кэш.КэшПоМетаданным.СтруктураМетаданныхПоТипу[ТипОбъекта]; КонецЕсли;
				МетаданныеОбъекта = ОбъектМетаданныхПоТипуВКэш(ТипОбъекта, Кэш);
				
			Исключение
			
				Возврат НоваяСтруктураРезультатСтруктурыИмениТипа();
			
			КонецПопытки;
			
		КонецПопытки;
		
	КонецЕсли;
	
	СтруктураРезультат = НоваяСтруктураРезультатСтруктурыИмениТипа();
	
	НужноПолучатьМетаданные = (МетаданныеОбъекта = Неопределено Или МетаданныеОбъекта = Ложь);
	Если НужноПолучатьМетаданные И ТипОбъекта <> Тип("Строка") Тогда Возврат СтруктураРезультат; КонецЕсли;
	
	Если ТипОбъекта = Тип("Строка") Тогда
		
		МассивРазделить = СтрРазделить(Объект, ".", Ложь);
		Если МассивРазделить.Количество() = 0 Тогда
			Возврат СтруктураРезультат;
		КонецЕсли;
		
		СтруктураРезультат.ИмяОбъекта = МассивРазделить.Получить(МассивРазделить.ВГраница());
		
		НужноПолучатьМетаданные = Истина;
		ОбъектДляПоиска = Объект;
		
	Иначе
		
		НужноПолучатьМетаданные = Ложь;
		
		СтруктураРезультат.ИмяОбъекта = МетаданныеОбъекта.Имя;
		ОбъектДляПоиска = МетаданныеОбъекта;
		
	КонецЕсли;
	
	ТипДляПроверки = ТипЗнч(ОбъектДляПоиска);
	Если ЭтоКонстанта(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "Константы";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "Константа";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.Константы.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = Константы[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("КонстантаКлючЗначения." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоСправочник(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "Справочники";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "Справочник";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.Справочники.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = Справочники[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("СправочникСсылка." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоДокумент(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "Документы";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "Документ";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.Документы.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = Документы[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("ДокументСсылка." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоПеречисление(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "Перечисления";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "Перечисление";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.Перечисления.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = Перечисления[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("ПеречислениеСсылка." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоПланВидовХарактеристик(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "ПланыВидовХарактеристик";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "ПланВидовХарактеристик";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.ПланыВидовХарактеристик.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = ПланыВидовХарактеристик[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("ПланВидовХарактеристикСсылка." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоПланСчетов(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "ПланыСчетов";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "ПланСчетов";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.ПланыСчетов.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = ПланыСчетов[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("ПланСчетовСсылка." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоПланВидовРасчета(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "ПланыВидовРасчета";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "ПланВидовРасчета";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.ПланыВидовРасчета.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = ПланыВидовРасчета[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("ПланВидовРасчетаСсылка." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоРегистрСведений(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "РегистрыСведений";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "РегистрСведений";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.РегистрыСведений.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = РегистрыСведений[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("РегистрСведенийКлючЗаписи." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоРегистрНакопления(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "РегистрыНакопления";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "РегистрНакопления";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.РегистрыНакопления.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = РегистрыНакопления[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("РегистрНакопленияКлючЗаписи." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоРегистрБухгалтерии(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "РегистрыБухгалтерии";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "РегистрБухгалтерии";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.РегистрыБухгалтерии.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = РегистрыБухгалтерии[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("РегистрБухгалтерииКлючЗаписи." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоРегистрРасчета(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "РегистрыРасчета";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "РегистрРасчета";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.РегистрыРасчета.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = РегистрыРасчета[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("РегистрРасчетаКлючЗаписи." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоБизнесПроцесс(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "БизнесПроцессы";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "БизнесПроцесс";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.БизнесПроцессы.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = БизнесПроцессы[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("БизнесПроцессСсылка." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоЗадача(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "Задачи";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "Задача";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.Задачи.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = Задачи[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("ЗадачаСсылка." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоПланОбмена(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "ПланыОбмена";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "ПланОбмена";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.ПланыОбмена.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			
			СтруктураРезультат.МенеджерОбъекта = ПланыОбмена[СтруктураРезультат.ИмяОбъекта];
			СтруктураРезультат.Тип = Тип("ПланОбменаСсылка." + СтруктураРезультат.ИмяОбъекта);
			
		КонецЕсли;
		
	ИначеЕсли ЭтоЖурналДокументов(ОбъектДляПоиска, Кэш, ТипДляПроверки) Тогда
		
		СтруктураРезультат.ТипОбъектаМножественноеЧисло = "ЖурналыДокументов";
		СтруктураРезультат.ТипОбъектаЕдинственноеЧисло = "ЖурналДокументов";
		
		Если НужноПолучатьМетаданные Тогда
			МетаданныеОбъекта = Метаданные.ЖурналыДокументов.Найти(СтруктураРезультат.ИмяОбъекта);
		КонецЕсли;
		
		Если МетаданныеОбъекта <> Неопределено Тогда
			СтруктураРезультат.МенеджерОбъекта = ЖурналыДокументов[СтруктураРезультат.ИмяОбъекта];
		КонецЕсли;
		
	КонецЕсли;
	
	СтруктураРезультат.МетаданныеОбъекта = МетаданныеОбъекта;
	Если СтруктураРезультат.МетаданныеОбъекта <> Неопределено Тогда СтруктураРезультат.ПолноеИмяОбъекта = СтруктураРезультат.ТипОбъектаЕдинственноеЧисло + "." + СтруктураРезультат.ИмяОбъекта; КонецЕсли;
	
	Если ТипОбъекта = Тип("Тип") Тогда
		Кэш.КэшПоМетаданным.СтруктураМетаданныхПоТипу[Объект] = СтруктураРезультат;
	ИначеЕсли ТипОбъекта <> Тип("Строка") Тогда
		Кэш.КэшПоМетаданным.СтруктураМетаданныхПоТипу[ТипОбъекта] = СтруктураРезультат;
	КонецЕсли;
	Если Не ПустаяСтрока(СтруктураРезультат.ПолноеИмяОбъекта) Тогда
		Кэш.КэшПоМетаданным.СтруктураМетаданныхПоПолномуИмени[СтруктураРезультат.ПолноеИмяОбъекта] = СтруктураРезультат;
	КонецЕсли;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Возвращает полное имя метаданных объекта в 1С по его типу.
// 
// Параметры:
//  ТипДляПроверки - Тип
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
Функция ПолучитьИмяМетаданныхПоТипу(Знач ТипДляПроверки, Кэш = Неопределено) Экспорт
	
	СтруктураМетаданных = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ТипДляПроверки, Кэш);
	Возврат ?(СтруктураМетаданных = Неопределено Или СтруктураМетаданных.МетаданныеОбъекта = Неопределено,
			"",
			СтруктураМетаданных.ПолноеИмяОбъекта);
	
КонецФункции

// Если есть реквизит ГУИД, то возвращает ИСТИНА
// 
// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - см. ПолучитьТипРеквизитаВ1С.ОбъектМетаданныхИлиПолноеИмя
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево - Флаг того, что у переданного объекта метаданных есть реквизит ГУИД
Функция ЕстьГУИДВРеквизитах(Знач ОбъектМетаданныхИлиПолноеИмя, Кэш = Неопределено) Экспорт
	
	Возврат ПолучитьСтруктуруВсехРеквизитовОбъекта(ОбъектМетаданныхИлиПолноеИмя, Истина, Кэш).МассивРеквизитов.Найти("ГУИД") <> Неопределено;
	
КонецФункции

// Возвращает структуру всех реквизитов (имён или объектов метаданных) по объекту метаданных в 1С.
// 
// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - см. ПолучитьТипРеквизитаВ1С.ОбъектМетаданныхИлиПолноеИмя
//  ВозвращатьИмена - Булево - Возвращать имена
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Структура:
//		* МассивРеквизитов - Массив из Строка - Если ВозвращатьИмена = ИСТИНА
//						   - Массив из см. ПолучитьИмяТипаМетаданныхРеквизита.МетаданныеРеквизит - Если ВозвращатьИмена = ЛОЖЬ
//		* ТабличныеЧасти - Структура из КлючИЗначение:
//			** Ключ - Строка
//			** Значение - Массив из Строка - Если ВозвращатьИмена = ИСТИНА
//						- Массив из см. ПолучитьИмяТипаМетаданныхРеквизита.МетаданныеРеквизит - Если ВозвращатьИмена = ЛОЖЬ
Функция ПолучитьСтруктуруВсехРеквизитовОбъекта(Знач ОбъектМетаданныхИлиПолноеИмя, Знач ВозвращатьИмена = Истина, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	Если ТипЗнч(ОбъектМетаданныхИлиПолноеИмя) = Тип("Строка") Тогда
		
		Если ПустаяСтрока(ОбъектМетаданныхИлиПолноеИмя) Тогда
			Возврат НоваяСтруктураРезультатДляПолученияВсехРеквизитов();
		КонецЕсли;
		
		СтруктураПоМетаданным = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ОбъектМетаданныхИлиПолноеИмя, Кэш);
		Если СтруктураПоМетаданным.МетаданныеОбъекта = Неопределено Тогда
			Возврат НоваяСтруктураРезультатДляПолученияВсехРеквизитов();
		КонецЕсли;
		
		ОбъектМетаданных = СтруктураПоМетаданным.МетаданныеОбъекта;
		
	Иначе
		
		ОбъектМетаданных = ОбъектМетаданныхИлиПолноеИмя;
		
	КонецЕсли;
	
	Если ВозвращатьИмена Тогда
		Если Кэш.КэшПоМетаданным.ВсеРеквизитыОбъекта.ЧерезИмена[ОбъектМетаданных] <> Неопределено Тогда Возврат Кэш.КэшПоМетаданным.ВсеРеквизитыОбъекта.ЧерезИмена[ОбъектМетаданных]; КонецЕсли;
	Иначе
		Если Кэш.КэшПоМетаданным.ВсеРеквизитыОбъекта.ЧерезМетаданные[ОбъектМетаданных] <> Неопределено Тогда Возврат Кэш.КэшПоМетаданным.ВсеРеквизитыОбъекта.ЧерезМетаданные[ОбъектМетаданных]; КонецЕсли;
	КонецЕсли;
	
	СтруктураРезультат = НоваяСтруктураРезультатДляПолученияВсехРеквизитов();
	Если Не Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(ОбъектМетаданных, "Реквизиты") Тогда Возврат СтруктураРезультат; КонецЕсли;
	
	ЭтоРегистр = ЭтоРегистр(ОбъектМетаданных, Кэш, Тип("ОбъектМетаданных"));
	
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(ОбъектМетаданных, "СтандартныеРеквизиты") Тогда Для Каждого МетаданныеРеквизита Из ОбъектМетаданных.СтандартныеРеквизиты Цикл СтруктураРезультат.МассивРеквизитов.Добавить(?(ВозвращатьИмена, МетаданныеРеквизита.Имя, МетаданныеРеквизита)); КонецЦикла; КонецЕсли;
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(ОбъектМетаданных, "Реквизиты") Тогда Для Каждого МетаданныеРеквизита Из ОбъектМетаданных.Реквизиты Цикл СтруктураРезультат.МассивРеквизитов.Добавить(?(ВозвращатьИмена, МетаданныеРеквизита.Имя, МетаданныеРеквизита)); КонецЦикла; КонецЕсли;
	
	Для Каждого МетаданныеРеквизита Из Метаданные.ОбщиеРеквизиты Цикл
		
		Если МетаданныеРеквизита.РазделениеДанных <> Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.НеИспользовать
			И Не (МетаданныеРеквизита.РазделениеДанных = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять
				И МетаданныеРеквизита.ИспользованиеРазделяемыхДанных = Метаданные.СвойстваОбъектов.ИспользованиеРазделяемыхДанныхОбщегоРеквизита.НезависимоИСовместно) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ЭлементСостава = МетаданныеРеквизита.Состав.Найти(ОбъектМетаданных);
		Если ЭлементСостава = Неопределено Тогда Продолжить; КонецЕсли;
		
		АвтоматическиТожеВключено = МетаданныеРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
		ВключенРеквизит = ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать
			Или (АвтоматическиТожеВключено И ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Авто);
		
		Если ВключенРеквизит Тогда СтруктураРезультат.МассивРеквизитов.Добавить(?(ВозвращатьИмена, МетаданныеРеквизита.Имя, МетаданныеРеквизита)); КонецЕсли;
		
	КонецЦикла;
	
	Если ЭтоРегистр Тогда
		
		Для Каждого МетаданныеРеквизита Из ОбъектМетаданных.Измерения Цикл СтруктураРезультат.МассивРеквизитов.Добавить(?(ВозвращатьИмена, МетаданныеРеквизита.Имя, МетаданныеРеквизита)); КонецЦикла;
		Для Каждого МетаданныеРеквизита Из ОбъектМетаданных.Ресурсы Цикл СтруктураРезультат.МассивРеквизитов.Добавить(?(ВозвращатьИмена, МетаданныеРеквизита.Имя, МетаданныеРеквизита)); КонецЦикла;
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(ОбъектМетаданных, "ТабличныеЧасти") Тогда
		
		Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			
			МассивРеквизитов = Новый Массив; // Массив из Строка, ОбъектМетаданных
			
			//@skip-check invocation-parameter-type-intersect
			//@skip-check property-return-type
			Для Каждого МетаданныеРеквизита Из ТабличнаяЧасть.СтандартныеРеквизиты Цикл МассивРеквизитов.Добавить(?(ВозвращатьИмена, МетаданныеРеквизита.Имя, МетаданныеРеквизита)); КонецЦикла;
			Для Каждого МетаданныеРеквизита Из ТабличнаяЧасть.Реквизиты Цикл МассивРеквизитов.Добавить(?(ВозвращатьИмена, МетаданныеРеквизита.Имя, МетаданныеРеквизита)); КонецЦикла;
			
			СтруктураРезультат.ТабличныеЧасти.Вставить(ТабличнаяЧасть.Имя, МассивРеквизитов);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если ВозвращатьИмена Тогда Кэш.КэшПоМетаданным.ВсеРеквизитыОбъекта.ЧерезИмена[ОбъектМетаданныхИлиПолноеИмя] = СтруктураРезультат; Иначе Кэш.КэшПоМетаданным.ВсеРеквизитыОбъекта.ЧерезМетаданные[ОбъектМетаданныхИлиПолноеИмя] = СтруктураРезультат; КонецЕсли;
	Возврат СтруктураРезультат;
	
КонецФункции

// Возвращаем объект метаданных реквизит по имени в 1С
//
// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - см. ПолучитьТипРеквизитаВ1С.ОбъектМетаданныхИлиПолноеИмя
//  ИмяРеквизита - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Неопределено, ОбъектМетаданных -
//
Функция ПолучитьМетаданныеРеквизитаПоИмени(Знач ОбъектМетаданныхИлиПолноеИмя, Знач ИмяРеквизита, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	СтруктураРеквизитов = ПолучитьСтруктуруВсехРеквизитовОбъекта(ОбъектМетаданныхИлиПолноеИмя, Ложь, Кэш);
	
	МассивРазделенный = СтрРазделить(ИмяРеквизита, ".", Ложь);
	Если МассивРазделенный.Количество() = 1 Тогда
		
		Если СтруктураРеквизитов.МассивРеквизитов.Количество() = 0 Тогда Возврат Неопределено; КонецЕсли;
		
		ВРегИмяРеквизита = ВРег(ИмяРеквизита);
		Для Каждого Реквизит Из СтруктураРеквизитов.МассивРеквизитов Цикл Если ВРег(Реквизит.Имя) = ВРегИмяРеквизита Тогда Возврат Реквизит; КонецЕсли; КонецЦикла;
		Возврат Неопределено;
		
	ИначеЕсли МассивРазделенный.Количество() = 2 Тогда
		
		Если СтруктураРеквизитов.ТабличныеЧасти.Количество() = 0 Тогда Возврат Неопределено; КонецЕсли;
		
		ВРегИмяТЧ = ВРег(МассивРазделенный.Получить(0));
		Для Каждого КлючЗначение Из СтруктураРеквизитов.ТабличныеЧасти Цикл Если ВРег(КлючЗначение.Ключ) = ВРегИмяТЧ Тогда НужныйМассивРеквизитов = КлючЗначение.Значение; Прервать; КонецЕсли; КонецЦикла;
		
		Если НужныйМассивРеквизитов = Неопределено Тогда Возврат Неопределено; КонецЕсли;
		
		ВРегИмяРеквизита = ВРег(МассивРазделенный.Получить(1));
		Для Каждого Реквизит Из НужныйМассивРеквизитов Цикл Если ВРег(Реквизит.Имя) = ВРегИмяРеквизита Тогда Возврат Реквизит; КонецЕсли; КонецЦикла;
		
		Возврат Неопределено;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Возвращает массив имен ключевых измерений (реквизитов) для нужного регистра.
// 
// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - см. ПолучитьКлючЗаписиРегистраПоСтруктуреЗначений.ОбъектМетаданныхИлиПолноеИмя
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Массив из Строка
Функция ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(Знач ОбъектМетаданныхИлиПолноеИмя, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	Если ТипЗнч(ОбъектМетаданныхИлиПолноеИмя) = Тип("Строка") Тогда
		
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ОбъектМетаданныхИлиПолноеИмя);
		Если ОбъектМетаданных = Неопределено Тогда Возврат Новый Массив; КонецЕсли;
		
	Иначе
		
		ОбъектМетаданных = ОбъектМетаданныхИлиПолноеИмя;
		
	КонецЕсли;
	
	Если Кэш.КэшПоМетаданным.МассивОсновныхИзмерений[ОбъектМетаданных] <> Неопределено Тогда Возврат Кэш.КэшПоМетаданным.МассивОсновныхИзмерений[ОбъектМетаданных]; КонецЕсли;
	
	МассивРезультат = Новый Массив; // Массив из Строка
	Для Каждого МетаданныеРеквизита Из ОбъектМетаданных.СтандартныеРеквизиты Цикл МассивРезультат.Добавить(МетаданныеРеквизита.Имя); КонецЦикла;
	
	ЕстьОсновнойОтбор = ЭтоРегистрСведений(ОбъектМетаданных, Кэш, Тип("ОбъектМетаданных"));
	ЕстьБазовый = ?(Не ЕстьОсновнойОтбор,
			ЭтоРегистрБухгалтерии(ОбъектМетаданных, Кэш, Тип("ОбъектМетаданных")) Или ЭтоРегистрРасчета(ОбъектМетаданных, Кэш, Тип("ОбъектМетаданных")),
			Ложь);
	
	Для Каждого МетаданныеРеквизита Из ОбъектМетаданных.Измерения Цикл
		
		Если ЕстьОсновнойОтбор Тогда
			Если МетаданныеРеквизита.ОсновнойОтбор Тогда МассивРезультат.Добавить(МетаданныеРеквизита.Имя); КонецЕсли;
		ИначеЕсли ЕстьБазовый Тогда
			Если МетаданныеРеквизита.БазовоеИзмерение Тогда МассивРезультат.Добавить(МетаданныеРеквизита.Имя); КонецЕсли;
		Иначе
			МассивРезультат.Добавить(МетаданныеРеквизита.Имя);
		КонецЕсли;
		
	КонецЦикла;
	
	Кэш.КэшПоМетаданным.МассивОсновныхИзмерений[ОбъектМетаданных] = МассивРезультат;
	Возврат МассивРезультат;
	
КонецФункции

// Массив реквизитов где участвует объект.
// 
// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - см. ПолучитьКлючЗаписиРегистраПоСтруктуреЗначений.ОбъектМетаданныхИлиПолноеИмя
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Массив из см. НоваяСтруктураРеквизитаДляПолученияВсехРеквизитовГдеУчаствует
Функция ПолучитьМассивРеквизитовГдеУчаствуетОбъект(Знач ОбъектМетаданныхИлиПолноеИмя, Кэш = Неопределено) Экспорт
	
	МассивРезультат = Новый Массив; // Массив из см. НоваяСтруктураРеквизитаДляПолученияВсехРеквизитовГдеУчаствует
	
	СтруктураПоМетаданным = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ОбъектМетаданныхИлиПолноеИмя, Кэш);
	Если СтруктураПоМетаданным.МетаданныеОбъекта = Неопределено Тогда Возврат МассивРезультат; КонецЕсли;
	
	ТипДляПоиска = ТипЗнч(СтруктураПоМетаданным.МенеджерОбъекта.ПустаяСсылка());
	
	// Проходим по всем объектам
	МассивИмен = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ВсеТипыОбъектовИзМетаданных();
	Для Каждого ИмяОбъекта Из МассивИмен Цикл
		
		Для Каждого МетаданныеОбъекта Из Метаданные[ИмяОбъекта] Цикл // см. ПолучитьТипРеквизитаВ1С.ОбъектМетаданныхИлиПолноеИмя
			
			ПолныйМассивРеквизитов = ПолучитьСтруктуруВсехРеквизитовОбъекта(МетаданныеОбъекта, Ложь, Кэш);
			Для Каждого Реквизит Из ПолныйМассивРеквизитов.МассивРеквизитов Цикл
				
				Если МетаданныеОбъекта = СтруктураПоМетаданным.МетаданныеОбъекта И Реквизит.Имя = "Ссылка" Тогда
					Продолжить;
				КонецЕсли;
				
				Если Реквизит.Тип.СодержитТип(ТипДляПоиска) Тогда
					
					СтруктураОбъекта = НоваяСтруктураРеквизитаДляПолученияВсехРеквизитовГдеУчаствует(МетаданныеОбъекта.ПолноеИмя(), "", Реквизит.Имя);
					МассивРезультат.Добавить(СтруктураОбъекта);
					
				КонецЕсли;
				
			КонецЦикла;
			Для Каждого КлючЗначениеТабличнойЧасти Из ПолныйМассивРеквизитов.ТабличныеЧасти Цикл
				
				Для Каждого Реквизит Из КлючЗначениеТабличнойЧасти.Значение Цикл
					
					Если Реквизит.Тип.СодержитТип(ТипДляПоиска) Тогда
						
						СтруктураОбъекта = НоваяСтруктураРеквизитаДляПолученияВсехРеквизитовГдеУчаствует(МетаданныеОбъекта.ПолноеИмя(), КлючЗначениеТабличнойЧасти.Ключ, Реквизит.Имя); 
						МассивРезультат.Добавить(СтруктураОбъекта);
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Константы отдельно
	Для Каждого МетаданныеКонстанта Из Метаданные.Константы Цикл
		
		Если МетаданныеКонстанта.Тип.СодержитТип(ТипДляПоиска) Тогда
			
			СтруктураОбъекта = НоваяСтруктураРеквизитаДляПолученияВсехРеквизитовГдеУчаствует(МетаданныеОбъекта.ПолноеИмя(), "", "");
			МассивРезультат.Добавить(СтруктураОбъекта);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МассивРезультат;
	
КонецФункции

// Возвращаем имя типа данных по метаданным реквизита, если тип составной - возвращает пустую строку. 
// 
// Параметры:
//  МетаданныеРеквизит - ОбъектМетаданныхРеквизит
//					   - ОбъектМетаданныхИзмерение
//					   - ОбъектМетаданныхРесурс
//					   - ОбъектМетаданныхОбщийРеквизит
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
Функция ПолучитьИмяТипаМетаданныхРеквизита(Знач МетаданныеРеквизит, Кэш = Неопределено) Экспорт
	
	ТипыРеквизита = МетаданныеРеквизит.Тип.Типы();
	Если ТипыРеквизита.Количество() = 1 Тогда
		
		СтруктураМетаданных = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ТипыРеквизита.Получить(0), Кэш);
		Если СтруктураМетаданных <> Неопределено И Не ПустаяСтрока(СтруктураМетаданных.ПолноеИмяОбъекта) Тогда
			Возврат СтруктураМетаданных.ПолноеИмяОбъекта;
		Иначе
			Возврат "";
		КонецЕсли;
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает массив имён табличных частей объекта метаданных.
// 
// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - см. ПолучитьКлючЗаписиРегистраПоСтруктуреЗначений.ОбъектМетаданныхИлиПолноеИмя
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Массив из Строка
Функция ПолучитьМассивИменТабличныхЧастей(Знач ОбъектМетаданныхИлиПолноеИмя, Кэш = Неопределено) Экспорт

	СтруктураРеквизитов = ПолучитьСтруктуруВсехРеквизитовОбъекта(ОбъектМетаданныхИлиПолноеИмя, Ложь, Кэш);
	Возврат Спец_РаботаСКоллекциямиКлиентСервер.ВыгрузитьМассивЗначений(СтруктураРеквизитов.ТабличныеЧасти, "Ключ");

КонецФункции

// Ссылочные типы
//

// Если это объектный тип (ДокументОбъект, СправочникОбъект, и т.п.), то возвращает ИСТИНА
// 
// Параметры:
//  ОбъектДляПроверки - Произвольный
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоОбъектныйТип(Знач ОбъектДляПроверки) Экспорт
	
	ТипXML = XMLТипЗнч(ОбъектДляПроверки);
	Возврат ТипXML <> Неопределено И СтрНайти(ТипXML.ИмяТипа, "Object.") > 0;
	
КонецФункции

// Если переданный тип, объект имеет отношение к ссылочным объектам, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - ЛюбаяСсылка, Тип - Объект для проверки
//  ТипОбъекта - Неопределено, Тип - Тип объекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоСсылочныйТип(Знач ОбъектДляПроверки, Знач ТипОбъекта = Неопределено) Экспорт
	
	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ?(ТипЗнч(ОбъектДляПроверки) = Тип("Тип"), ОбъектДляПроверки, ТипЗнч(ОбъектДляПроверки)); КонецЕсли;
	Возврат Спец_ОбщегоНазначенияПовтИсп.ОписаниеТипаВсеСсылки().СодержитТип(ТипОбъекта);

КонецФункции

// Если переданный объект имеет любое отношение к ссылочным объектам (например, строка "Справочник.Спец_Базы" или форма объекта справочника Спец_Базы), то возвращает ИСТИНА
// 
// Параметры:
//  ОбъектДляПроверки - Произвольный
//  				  - Строка - Объект для проверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - Неопределено, Тип - Тип объекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоСсылка(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт
	
	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда Возврат Спец_ОбщегоНазначенияКлиентСервер.ЭтоСсылка(ОбъектДляПроверки, Кэш, ТипОбъекта); КонецЕсли;
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	Возврат ЭтоСправочник(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоДокумент(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоПеречисление(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоПланВидовХарактеристик(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоПланСчетов(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоПланВидовРасчета(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоБизнесПроцесс(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоЗадача(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоПланОбмена(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоЖурналДокументов(ОбъектДляПроверки, Кэш, ТипОбъекта);
	
КонецФункции

// Если переданный объект имеет любое отношение к справочникам, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоСправочник(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоСправочник(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "Справочники", "ЭтоСправочник", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к документам, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоДокумент(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоДокумент(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "Документы", "ЭтоДокумент", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к перечислениям, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоПеречисление(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоПеречисление(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "Перечисления", "ЭтоПеречисление", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к планам видов характеристик, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоПланВидовХарактеристик(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоПланВидовХарактеристик(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "ПланыВидовХарактеристик", "ЭтоПланВидовХарактеристик", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к планам счетов, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоПланСчетов(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоПланСчетов(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "ПланыСчетов", "ЭтоПланСчетов", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к планам видов расчёта, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоПланВидовРасчета(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоПланВидовРасчета(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "ПланыВидовРасчета", "ЭтоПланВидовРасчета", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к бизнес процессам, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоБизнесПроцесс(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоБизнесПроцесс(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "БизнесПроцессы", "ЭтоБизнесПроцесс", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к задачам, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоЗадача(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоЗадача(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "Задачи", "ЭтоЗадача", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к планам обменов, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоПланОбмена(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоПланОбмена(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "ПланыОбмена", "ЭтоПланОбмена", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к журналам документов, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоЖурналДокументов(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоЖурналДокументов(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "ЖурналыДокументов", "ЭтоЖурналДокументов", Кэш));

КонецФункции

// Регистры
//

// Если переданный объект имеет любое отношение к регистрам (любого типа), то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоРегистр(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Если ТипОбъекта = Тип("Строка") Тогда Возврат Спец_ОбщегоНазначенияКлиентСервер.ЭтоРегистр(ОбъектДляПроверки, Кэш, ТипОбъекта); КонецЕсли;
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;

	Возврат ЭтоРегистрСведений(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоРегистрНакопления(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоРегистрБухгалтерии(ОбъектДляПроверки, Кэш, ТипОбъекта)
			Или ЭтоРегистрРасчета(ОбъектДляПроверки, Кэш, ТипОбъекта);

КонецФункции

// Если переданный объект имеет любое отношение к регистрам сведений, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоРегистрСведений(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоРегистрСведений(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "РегистрыСведений", "ЭтоРегистрСведений", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к регистрам накоплений, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоРегистрНакопления(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоРегистрНакопления(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "РегистрыНакопления", "ЭтоРегистрНакопления", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к регистрам бухгалтерии, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоРегистрБухгалтерии(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоРегистрБухгалтерии(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "РегистрыБухгалтерии", "ЭтоРегистрБухгалтерии", Кэш));

КонецФункции

// Если переданный объект имеет любое отношение к регистрам расчёта, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоРегистрРасчета(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоРегистрРасчета(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "РегистрыРасчета", "ЭтоРегистрРасчета", Кэш));

КонецФункции

// Отдельные типы
//

// Если переданный объект имеет любое отношение к константам, то возвращает ИСТИНА.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоКонстанта(Знач ОбъектДляПроверки, Кэш = Неопределено, Знач ТипОбъекта = Неопределено) Экспорт

	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектДляПроверки); КонецЕсли;
	Возврат ?(ТипОбъекта = Тип("Строка"),
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоКонстанта(ОбъектДляПроверки, Кэш, ТипОбъекта),
			ЭтоКакойТоОбъектПоИмениВКэш(ОбъектДляПроверки, ТипОбъекта, "Константы", "ЭтоКонстанта", Кэш));

КонецФункции

#КонецОбласти

#Область РаботаСОбъектамиБазы

// Получить ссылочный объект с блокированием (Заблокировать).
// 
// Параметры:
//  СсылкаНаОбъект - ЛюбаяСсылка - Ссылка на объект
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТекстОшибки - Строка - Текст ошибки
// 
// Возвращаемое значение:
//		- ПланСчетовОбъект
//  	- ПланВидовХарактеристикОбъект
//  	- БизнесПроцессОбъект
//  	- ПланВидовРасчетаОбъект
//  	- ПланОбменаОбъект
//  	- СправочникОбъект
//  	- ДокументОбъект
//  	- ЗадачаОбъект
//		- Неопределено - Если объект не удалось заблокировать
Функция ПолучитьОбъектСБлокированием(Знач СсылкаНаОбъект, Кэш = Неопределено, ТекстОшибки = "") Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	Если Не ЭтоСсылочныйТип(СсылкаНаОбъект) Тогда Возврат СсылкаНаОбъект; КонецЕсли;
	
	Объект = Неопределено; // см. ЗаписатьОбъект.ОбъектДляЗаписи
	ОбщийТекстСообщения = "";
	Для i = 1 По Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.КоличествоПопытокБлокированияСсылочныхОбъектов, 3) Цикл
		
		Попытка
			
			Если Объект <> Неопределено Тогда
				Объект.Прочитать();
			Иначе
				Объект = СсылкаНаОбъект.ПолучитьОбъект();
			КонецЕсли;
			
			Объект.Заблокировать();
			Возврат Объект;
			
		Исключение
			
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(),
					"Спец_ОбщегоНазначения.ПолучитьОбъектСБлокированием(...) -> Попытка блокирования №" + Формат(i, "ЧН=0; ЧГ="),
					ОбщийТекстСообщения);
			
			Спец_КомпонентаДополнительныеФункцииКлиентСервер.Пауза(100, Кэш); // Делаем небольшую паузу, чтобы дать время завершить другую транзакцию.
			
		КонецПопытки;
		
	КонецЦикла;
	
	Спец_СтроковыеФункцииКлиентСервер.ДобавитьСтрокуВТекст(ОбщийТекстСообщения, ТекстОшибки, Символы.ПС + Символы.ПС);
	Возврат Неопределено;
	
КонецФункции

// Метод для записи объекта. После записи вызывается метод "Разблокировать".
// Если объект не был модифицирован (не был изменён) и передан флаг ПроверятьМодифицированность = Истина, то запись не будет вызвана.
// 
// Параметры:
//  ОбъектДляЗаписи - БизнесПроцессОбъект
//  				- ДокументОбъект
//  				- ЗадачаОбъект
//  				- ПланВидовРасчетаОбъект
//  				- ПланВидовХарактеристикОбъект
//  				- ПланОбменаОбъект
//  				- ПланСчетовОбъект
//  				- ПерерасчетНаборЗаписей
//  				- РегистрБухгалтерииНаборЗаписей
//  				- РегистрНакопленияНаборЗаписей
//  				- РегистрРасчетаНаборЗаписей
//  				- РегистрСведенийНаборЗаписей
//  				- РегистрСведенийМенеджерЗаписи
//  				- СправочникОбъект
//  ПараметрЗаписи - Неопределено
//  			   - РежимЗаписиДокумента - В случае, если ОбъектДляЗаписи - документ
//  			   - Булево - Флаг "Замещать" для регистров
//  ТекстОшибки - Строка, Неопределено - В данный параметр будут помещены тексты ошибок, если запись не была выполнена.
//  Отказ - Булево, Неопределено - Флаг отказа
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  КоличествоОграничениеПопытокЗаписи - Число - Количество ограничение попыток записи
//  СтруктураРеквизитовОтбор - Неопределено -
//  						 - см. ПолучитьСтруктуруВсехРеквизитовОбъекта
//  ПроверятьМодифицированность - Булево - Флаг того, нужно ли проверять модифицированность
// 
// Возвращаемое значение:
//  Булево - Флаг успешности выполнения
Функция ЗаписатьОбъект(Знач ОбъектДляЗаписи, Знач ПараметрЗаписи = Неопределено, ТекстОшибки = "", Отказ = Ложь,
		Кэш = Неопределено, Знач КоличествоОграничениеПопытокЗаписи = 1, Знач СтруктураРеквизитовОтбор = Неопределено, Знач ПроверятьМодифицированность = Истина) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	ТипОбъектаДляЗаписи = ТипЗнч(ОбъектДляЗаписи);
	ЭтоСсылка           = ЭтоОбъектныйТип(ОбъектДляЗаписи);
	ЭтоДокумент         = ЭтоСсылка И ЭтоДокумент(ОбъектДляЗаписи, Кэш, ТипОбъектаДляЗаписи);
	ЭтоРегистр          = Не ЭтоСсылка И ЭтоРегистр(ОбъектДляЗаписи, Кэш, ТипОбъектаДляЗаписи);
	
	Если ПроверятьМодифицированность И Не ОбъектМодифицирован(ОбъектДляЗаписи, СтруктураРеквизитовОтбор, Кэш) Тогда // Для больших объектов медленная, придумать обход.
		
		Если ЭтоСсылка И ОбъектДляЗаписи.Заблокирован() Тогда ОбъектДляЗаписи.Разблокировать(); КонецЕсли;
		Возврат Истина;
		
	КонецЕсли;
	
	ОбщийТекстСообщения = "";
	Для i = 1 По КоличествоОграничениеПопытокЗаписи Цикл
		
		Попытка
			
			Если ЭтоДокумент Или ЭтоРегистр Тогда
				ОбъектДляЗаписи.Записать(ПараметрЗаписи);
			Иначе
				ОбъектДляЗаписи.Записать();
			КонецЕсли;
			
			Если ЭтоСсылка И ОбъектДляЗаписи.Заблокирован() Тогда
				ОбъектДляЗаписи.Разблокировать();
			КонецЕсли;
			
			Возврат Истина;
			
		Исключение
			
			МассивТекстСообщений = Новый Массив(); // Массив из Строка
			
			МассивТекстСообщений.Добавить(СтрШаблон("Не удалось записать объект '%1'!", Строка(ОбъектДляЗаписи)));
			МассивТекстСообщений.Добавить(Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб));
			
			МассивСообщений = ПолучитьСообщенияПользователю(Истина);
			Если МассивСообщений.Количество() Тогда
				
				МассивТекстСообщений.Добавить("Сообщения:");
				Для Каждого СообщениеПользователю Из МассивСообщений Цикл
					МассивТекстСообщений.Добавить(Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(СообщениеПользователю.Текст, Символы.Таб));
				КонецЦикла;
				
			КонецЕсли;
			
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(СтрСоединить(МассивТекстСообщений, Символы.ПС),
					"Спец_ОбщегоНазначения.ЗаписатьОбъект(...) -> Попытка записи №" + Формат(i, "ЧН=0; ЧГ="),
					ОбщийТекстСообщения);
			
		КонецПопытки;
		
	КонецЦикла;
	
	Спец_СтроковыеФункцииКлиентСервер.ДобавитьСтрокуВТекст(ОбщийТекстСообщения, ТекстОшибки, Символы.ПС + Символы.ПС);
	Отказ = Истина;
	
	Возврат Ложь;
	
КонецФункции

// Метод для удаления дублей по ссылке.
// Удаляются все ссылки из массива дублей, и во всех объектах, где они встречаются, подставляется НормальнаяСсылка.
// Типы объектов должны совпадать.
// Все изменения происходят в одной транзакции. Если происходит какая-либо ошибка, то транзакция отменяется
// 
// Параметры:
//  НормальнаяСсылка - ЛюбаяСсылка
//  МассивДублейСсылки - Массив из ЛюбаяСсылка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  МожноЧерезБД - Булево - Если ИСТИНА, то удаления объектов будут выполнены через запрос в БД (если такая возможность есть).
//  ТекстыОшибок - Строка - Тексты ошибок
// 
// Возвращаемое значение:
//  Булево - Флаг успешного выполнения
Функция УдалитьДублиПоСсылке(Знач НормальнаяСсылка, Знач МассивДублейСсылки, Кэш = Неопределено, Знач МожноЧерезБД = Ложь, ТекстыОшибок = "") Экспорт
	
	Если Не ЗначениеЗаполнено(НормальнаяСсылка) Или МассивДублейСсылки.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш();	КонецЕсли;
	ТаблицаПоСсылкам = НайтиПоСсылкам(МассивДублейСсылки);
	
	УстановитьПривилегированныйРежим(Истина);
	
	НачатьТранзакцию();
	
	Попытка
		
		Отказ = Ложь;
		ТекстыОшибокЛокальные = "";
		
		Для Каждого СтрокаРезультат Из ТаблицаПоСсылкам Цикл
			
			Если ЭтоРегистрСведений(СтрокаРезультат.Метаданные, Кэш, Тип("ОбъектМетаданных")) Тогда
				
				МенеджерЗаписи = РегистрыСведений[СтрокаРезультат.Метаданные.Имя].СоздатьМенеджерЗаписи();
				ЗаполнитьЗначенияСвойств(МенеджерЗаписи, СтрокаРезультат.Данные);
				
				МенеджерЗаписи.Прочитать();
				Если МенеджерЗаписи.Выбран() Тогда
					
					СтруктураРеквизитов = ПолучитьСтруктуруВсехРеквизитовОбъекта(СтрокаРезультат.Метаданные, Истина, Кэш);
					Для Каждого ИмяРеквизита Из СтруктураРеквизитов.МассивРеквизитов Цикл
						
						Если МенеджерЗаписи[ИмяРеквизита] = СтрокаРезультат.Ссылка Тогда
							МенеджерЗаписи[ИмяРеквизита] = НормальнаяСсылка;
						КонецЕсли;
						
					КонецЦикла;
					
					ЗаписатьОбъект(МенеджерЗаписи, , ТекстыОшибокЛокальные, Отказ, Кэш, 3, , Ложь);
					
				КонецЕсли;
				
			ИначеЕсли ЭтоСсылка(СтрокаРезультат.Метаданные, Кэш, Тип("ОбъектМетаданных")) Тогда
				
				//@skip-check invocation-parameter-type-intersect
				Объект = ПолучитьОбъектСБлокированием(СтрокаРезультат.Данные, Кэш, ТекстыОшибок);
				Если Объект = Неопределено Тогда
					
					Отказ = Истина;
					Продолжить;
					
				КонецЕсли;
				
				СтруктураРеквизитов = ПолучитьСтруктуруВсехРеквизитовОбъекта(СтрокаРезультат.Метаданные, Истина, Кэш);
				Для Каждого ИмяРеквизита Из СтруктураРеквизитов.МассивРеквизитов Цикл
					
					Если Объект[ИмяРеквизита] = СтрокаРезультат.Ссылка Тогда
						Объект[ИмяРеквизита] = НормальнаяСсылка;
					КонецЕсли;
					
				КонецЦикла;
				Для Каждого КлючЗначение Из СтруктураРеквизитов.ТабличныеЧасти Цикл
					
					Для Каждого СтрокаТЧ Из Объект[КлючЗначение.Ключ] Цикл
						
						Для Каждого РеквизитТЧ Из КлючЗначение.Значение Цикл
							
							Если СтрокаТЧ[РеквизитТЧ] = СтрокаРезультат.Ссылка Тогда
								СтрокаТЧ[РеквизитТЧ] = НормальнаяСсылка;
							КонецЕсли;
							
						КонецЦикла;
						
					КонецЦикла;
					
				КонецЦикла;
				
				ЗаписатьОбъект(Объект, , ТекстыОшибокЛокальные, Отказ, Кэш, 3, , Ложь);
				
			КонецЕсли;
			
			Спец_Проверить(Не Отказ, ТекстыОшибокЛокальные);
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		УстановитьПривилегированныйРежим(Ложь);
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(), "УдалитьДублиПоСсылке", ТекстыОшибок);
		Возврат Ложь;
		
	КонецПопытки;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	СтруктураПоМетаданным = ПолучитьСтруктуруИмениТипаДанныхОбъекта(НормальнаяСсылка, Кэш);
	
	ТаблицаДляУдаления = НоваяТаблицаСКолонкойСсылкаПоМассивуТипов(Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(ТипЗнч(СтруктураПоМетаданным.МенеджерОбъекта.ПустаяСсылка())));
	Для Каждого СсылкаДляУдаления Из МассивДублейСсылки Цикл ТаблицаДляУдаления.Добавить().Ссылка = СсылкаДляУдаления; КонецЦикла;
	
	Если МожноЧерезБД И Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.УдалитьДанныеПоОбъекту1СВБазеДанных(ТаблицаДляУдаления, СтруктураПоМетаданным.ПолноеИмяОбъекта, ТекстыОшибок, Кэш) Тогда
		Возврат Истина;
	КонецЕсли;
	
	УдалитьДанныеПоОбъекту1СВБазеДанныхЧерез1С(ТаблицаДляУдаления, СтруктураПоМетаданным.ПолноеИмяОбъекта, ТекстыОшибок, Кэш);
	Возврат Истина;
	
КонецФункции

// Возвращает признак того, что у объекта есть изменённые реквизиты (есть изменения, модифицирован)
// 
// Параметры:
//  ОбъектДляПроверки - см. ЗаписатьОбъект.ОбъектДляЗаписи
//  СтруктураРеквизитовОтбор - Неопределено
//  						 - см. ПолучитьСтруктуруВсехРеквизитовОбъекта
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево - Флаг того, что объект модифицирован
Функция ОбъектМодифицирован(Знач ОбъектДляПроверки, Знач СтруктураРеквизитовОтбор = Неопределено, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	МетаданныеОбъекта = ОбъектДляПроверки.Метаданные();
	Если Спец_ОбработчикиПодписокНаСобытия.ПропуститьВсеПроверкиПоОбъекту(МетаданныеОбъекта, Неопределено, Кэш) Тогда
		Возврат Истина;
	КонецЕсли;
	
	СтруктураИлиМассивДоЗаписи = ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи(ОбъектДляПроверки, МетаданныеОбъекта, Кэш);
	Если СтруктураИлиМассивДоЗаписи = Неопределено Тогда Возврат Истина; КонецЕсли;
	
	СтруктураРеквизитов = ?(СтруктураРеквизитовОтбор = Неопределено, ПолучитьСтруктуруВсехРеквизитовОбъекта(МетаданныеОбъекта, Истина, Кэш), СтруктураРеквизитовОтбор);
	
	МассивИменРеквизитов = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураРеквизитов, "МассивРеквизитов", Новый Массив);
	Если ЭтоРегистр(МетаданныеОбъекта, Кэш, Тип("ОбъектМетаданных")) Тогда
		
		Если СтруктураИлиМассивДоЗаписи.Количество() <> ОбъектДляПроверки.Количество() Тогда Возврат Истина; КонецЕсли;
		
		i = 0;
		Для Каждого СтрокаЗаписи Из СтруктураИлиМассивДоЗаписи Цикл ЗаписьОбъекта = ОбъектДляПроверки[i]; Для Каждого ИмяРеквизита Из МассивИменРеквизитов Цикл Если Не Спец_РаботаСКоллекциямиКлиентСервер.ДанныеСовпадают(ЗаписьОбъекта[ИмяРеквизита], СтрокаЗаписи[ИмяРеквизита]) Тогда Возврат Истина; КонецЕсли; КонецЦикла; i = i + 1; КонецЦикла;
		Возврат Ложь;
		
	ИначеЕсли ЭтоСсылка(МетаданныеОбъекта, Кэш, Тип("ОбъектМетаданных")) Тогда
		
		Если Не ЗначениеЗаполнено(СтруктураИлиМассивДоЗаписи.Ссылка) Тогда
			Возврат Истина;
		КонецЕсли;
		
		Для Каждого ИмяРеквизита Из МассивИменРеквизитов Цикл Если Не Спец_РаботаСКоллекциямиКлиентСервер.ДанныеСовпадают(ОбъектДляПроверки[ИмяРеквизита], СтруктураИлиМассивДоЗаписи[ИмяРеквизита]) Тогда Возврат Истина; КонецЕсли; КонецЦикла;
		
		ТабличныеЧасти = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(СтруктураРеквизитов, "ТабличныеЧасти", Новый Структура()); // Структура
		Для Каждого КлючЗначение Из ТабличныеЧасти Цикл
			
			ТабличнаяЧастьОбъекта = ОбъектДляПроверки[КлючЗначение.Ключ]; // Массив из Структура
			ТабличнаяЧастьСсылки = СтруктураИлиМассивДоЗаписи[КлючЗначение.Ключ]; // Массив из Структура
			
			Если ТабличнаяЧастьОбъекта.Количество() <> ТабличнаяЧастьСсылки.Количество() Тогда Возврат Истина; КонецЕсли;
			Для i = 0 По ТабличнаяЧастьОбъекта.Количество() - 1 Цикл Для Каждого ИмяРеквизита Из КлючЗначение.Значение Цикл Если Не Спец_РаботаСКоллекциямиКлиентСервер.ДанныеСовпадают(ТабличнаяЧастьОбъекта[i][ИмяРеквизита], ТабличнаяЧастьСсылки[i][ИмяРеквизита]) Тогда Возврат Истина; КонецЕсли; КонецЦикла; КонецЦикла;
			
		КонецЦикла;
		
		Возврат Ложь;
		
	Иначе
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// Получить структуру или таблицу объекта до записи.
// 
// Параметры:
//  ОбъектДляПроверки - см. ЗаписатьОбъект.ОбъектДляЗаписи
//	ОбъектМетаданных - ОбъектМетаданныхПланВидовХарактеристик
//  				 - ОбъектМетаданныхСправочник
//  				 - ОбъектМетаданныхПланСчетов
//  				 - ОбъектМетаданныхЗадача
//  				 - ОбъектМетаданныхДокумент
//  				 - ОбъектМетаданныхБизнесПроцесс
//  				 - ОбъектМетаданныхПланВидовРасчета
//  				 - ОбъектМетаданныхПланОбмена
//  				 - ОбъектМетаданныхРегистрРасчета
//  				 - ОбъектМетаданныхРегистрСведений
//  				 - ОбъектМетаданныхРегистрБухгалтерии
//  				 - ОбъектМетаданныхПерерасчет
//  				 - ОбъектМетаданныхРегистрНакопления
//  				 - ОбъектМетаданных
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  - Структура - Если объект для проверки это ссылочный объект, табличные части в виде массива структур, структура обязательно содержит следующие поля:
//		* Ссылка - ЛюбаяСсылка
//	- Массив из Структура - Если объект для проверки это регистр, массив строк записей.
//	- Неопределено - Если объект для проверки это новая ссылка (если не записанная в БД) или неизвестный объект.
Функция ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи(Знач ОбъектДляПроверки, Знач ОбъектМетаданных, Кэш = Неопределено) Экспорт
	
	ТипОбъекта = ТипЗнч(ОбъектДляПроверки);
	Если ЭтоСсылка(ОбъектДляПроверки, Кэш, ТипОбъекта) Тогда
		
		Если Не ЗначениеЗаполнено(ОбъектДляПроверки.Ссылка) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.Текст = СтрШаблон(
				
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	*
				|ИЗ
				|	%1 КАК Спец_Таблица
				|ГДЕ
				|	Спец_Таблица.Ссылка = &Ссылка",
				
				ОбъектМетаданных.ПолноеИмя());
		
		Запрос.УстановитьПараметр("Ссылка", ОбъектДляПроверки.Ссылка);
		Возврат ПолучитьСтруктуруПервойВыборкиЗапроса(Запрос);
		
	ИначеЕсли ЭтоРегистр(ОбъектДляПроверки, Кэш, ТипОбъекта) Тогда
		
		ПостроительЗапроса = Новый ПостроительЗапроса(
				
				"ВЫБРАТЬ
				|	*
				|ИЗ
				|	" + ОбъектМетаданных.ПолноеИмя() + " КАК Спец_Таблица");
		
		ПостроительЗапроса.ЗаполнитьНастройки();
		
		Для Каждого ЭлементОтбора Из ОбъектДляПроверки.Отбор Цикл
			
			Если Не ЭлементОтбора.Использование Тогда
				Продолжить;
			КонецЕсли;
			
			// Нельзя уникальный идентификатор в построитель запроса
			Если ЭлементОтбора.ТипЗначения.СодержитТип(Тип("УникальныйИдентификатор")) Тогда
				Продолжить;
			КонецЕсли;
			
			ДоступноеПоле = ПостроительЗапроса.ДоступныеПоля.Найти(ЭлементОтбора.Имя);
			Если ДоступноеПоле = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ЭлементНовогоОтбора = ПостроительЗапроса.Отбор.Добавить(ДоступноеПоле.Имя);
			ЗаполнитьЗначенияСвойств(ЭлементНовогоОтбора, ЭлементОтбора);
			
		КонецЦикла;
		
		Возврат ПостроительЗапроса.ПолучитьЗапрос().Выполнить().Выгрузить();
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы по ссылке на объект.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
// Если передан элемент объект, то обращения к БД не будет, значение реквизита будет взято из объекта
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя, то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  СсылкаИлиОбъект - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//  		        - см. ЗаписатьОбъект.ОбъектДляЗаписи
//  ИменаРеквизитов - Строка - имена реквизитов, перечисленные через запятую, в формате требований к свойствам структуры.
//                    Например, "Код, Наименование, Родитель".
//                    Допускается указание имени реквизита через точку.
//                    Допускается задать имя реквизита результат, например "Код КАК КодСправочника".
//                    
//            		- Структура
//            		- ФиксированнаяСтруктура - в качестве ключа передается
//                       псевдоним поля для возвращаемой структуры с результатом, а в качестве
//                       значения (опционально) фактическое имя поля в таблице.
//                       Если ключ задан, а значение не определено, то имя поля берется из ключа.
//                       Допускается указание имени поля через точку, но при этом параметр КодЯзыка для такого поля
//                       учитываться не будет.
//            		- Массив из Строка
//            		- ФиксированныйМассив из Строка - имена реквизитов в формате требований к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя;
//                                если есть ограничение на уровне записей, то все реквизиты вернутся со 
//                                значением Неопределено; если нет прав для работы с таблицей, то возникнет исключение;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу 
//                                или любой из реквизитов.
//                     - Неопределено - Для того, чтобы можно было не передавать этот параметр и EDT не ругался
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если в параметр Реквизиты передана пустая строка, то возвращается пустая структура.
//              Если в параметр Ссылка передана пустая ссылка, то возвращается структура, 
//              соответствующая именам реквизитов со значениями Неопределено.
//              Если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//              то все реквизиты вернутся со значением Неопределено.
Функция ЗначенияРеквизитовОбъекта(Знач СсылкаИлиОбъект, Знач ИменаРеквизитов, Знач ВыбратьРазрешенные = Ложь, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	МетаданныеОбъекта = ОбъектМетаданныхПоТипуВКэш(ТипЗнч(СсылкаИлиОбъект), Кэш);
	Спец_Проверить(МетаданныеОбъекта <> Ложь, "Пришёл неизвестный тип!", "Спец_ОбщегоНазначения.ЗначенияРеквизитовОбъекта");
	
	// 1. Разбираем реквизиты
	МассивДляЗапроса   = Новый Массив;
	СтруктураРезультат = Новый Структура;
	ЭтоОбъектныйТип    = ЭтоОбъектныйТип(СсылкаИлиОбъект);
	
	ТипВходныхРеквизитов = ТипЗнч(ИменаРеквизитов);
	Если ТипВходныхРеквизитов = Тип("Строка") Тогда ИменаРеквизитов = СтрРазделить(ИменаРеквизитов, ",", Ложь); ТипВходныхРеквизитов = Тип("Массив"); КонецЕсли;
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИменаРеквизитов, ТипВходныхРеквизитов) Тогда
		
		Для Каждого ИмяРеквизита Из ИменаРеквизитов Цикл
			
			ИмяРеквизита = СокрЛП(ИмяРеквизита);
			
			МассивРазделенныйМассив = Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяРеквизита, " КАК ");
			Если МассивРазделенныйМассив.Количество() = 1 Тогда
				
				ИмяДляЗапроса = ИмяРеквизита;
				ИмяПсевдонима = Спец_СтроковыеФункцииКлиентСервер.ОчиститьИмяДляЗапроса(ИмяРеквизита);
				
			ИначеЕсли МассивРазделенныйМассив.Количество() = 2 Тогда
				
				ИмяДляЗапроса = СокрЛП(МассивРазделенныйМассив.Получить(0));
				ИмяПсевдонима = Спец_СтроковыеФункцииКлиентСервер.ОчиститьИмяДляЗапроса(МассивРазделенныйМассив.Получить(1));
				
			Иначе
				
				ВызватьИсключение "Пришёл странный реквизит: " + ИмяРеквизита;
				
			КонецЕсли;
			
			// Запрос в цикле, если обращения через точку
			//@skip-check query-in-loop
			ДобавитьПолеДляОбработки(СсылкаИлиОбъект, МассивДляЗапроса, Неопределено, СтруктураРезультат, ИмяДляЗапроса, ИмяПсевдонима, ЭтоОбъектныйТип, Кэш);
			
		КонецЦикла;
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ИменаРеквизитов, ТипВходныхРеквизитов)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(ИменаРеквизитов, ТипВходныхРеквизитов) Тогда
		
		//@skip-check query-in-loop
		//@skip-check invocation-parameter-type-intersect
		Для Каждого КлючЗначение Из ИменаРеквизитов Цикл ДобавитьПолеДляОбработки(СсылкаИлиОбъект, МассивДляЗапроса, Неопределено, СтруктураРезультат, КлючЗначение.Значение, КлючЗначение.Ключ, ЭтоОбъектныйТип, Кэш); КонецЦикла;
		
	Иначе
		
		ВызватьИсключение "Неизвестный тип реквизитов для разбора!";
		
	КонецЕсли;
	
	// 2. Формируем запрос
	Если ЭтоОбъектныйТип Тогда Возврат СтруктураРезультат; КонецЕсли;
	
	Запрос = Новый Запрос(СтрШаблон(
			
			"ВЫБРАТЬ %1ПЕРВЫЕ 1
			|	%2
			|ИЗ
			|	%3 КАК Таблица
			|ГДЕ
			|	Таблица.Ссылка = &Ссылка",
			
			?(ВыбратьРазрешенные, "РАЗРЕШЕННЫЕ ", ""),
			СтрСоединить(МассивДляЗапроса, "," + Символы.ПС + Символы.Таб),
			МетаданныеОбъекта.ПолноеИмя()));
	
	Запрос.УстановитьПараметр("Ссылка", СсылкаИлиОбъект);
	
	Попытка
		
		ВыборкаРезультат = Запрос.Выполнить().Выбрать();
		
	Исключение
		
		ТекстИсключения = СтрШаблон("Не удалось выполнить запрос ""ЗначенияРеквизитовОбъекта""!%1Ошибка при выполнении:%1%2%1Текст запроса:%1%3",
				Символы.ПС,
				Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб),
				Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(Запрос.Текст, Символы.Таб));
		
		ВызватьИсключение ТекстИсключения;
		
	КонецПопытки;
	
	Если ВыборкаРезультат.Следующий() Тогда ЗаполнитьЗначенияСвойств(СтруктураРезультат, ВыборкаРезультат); КонецЕсли;
	Возврат СтруктураРезультат;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы по ссылке на объект.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  СсылкаИлиОбъект - см. ЗначенияРеквизитовОбъекта.СсылкаИлиОбъект
//  ИмяРеквизита - Строка - имя получаемого реквизита.
//                          Допускается указание имени реквизита через точку.
//                    		Допускается задать имя реквизита результат, например "Код КАК КодСправочника".
//  ВыбратьРазрешенные - см. ЗначенияРеквизитовОбъекта.ВыбратьРазрешенные
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Произвольный - значение указанного реквизита.
Функция ЗначениеРеквизитаОбъекта(Знач СсылкаИлиОбъект, Знач ИмяРеквизита, Знач ВыбратьРазрешенные = Ложь, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	Для Каждого КлючЗначение Из ЗначенияРеквизитовОбъекта(СсылкаИлиОбъект, ИмяРеквизита, ВыбратьРазрешенные, Кэш) Цикл Возврат КлючЗначение.Значение; КонецЦикла;
	Возврат Неопределено;
	
КонецФункции

// Возвращает значения реквизитов, прочитанные из информационной базы для нескольких объектов.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  МассивСсылокИлиОбъектов - Массив из см. ЗначенияРеквизитовОбъекта.СсылкаИлиОбъект
//         - ФиксированныйМассив из см. ЗначенияРеквизитовОбъекта.СсылкаИлиОбъект
//  ИменаРеквизитов - см. ЗначенияРеквизитовОбъекта.ИменаРеквизитов
//  ВыбратьРазрешенные - Булево - см. ЗначенияРеквизитовОбъекта.ВыбратьРазрешенные
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - список объектов и значений их реквизитов:
//   * Ключ - ЛюбаяСсылка - ссылка на объект;
//   * Значение - Структура:
//    ** Ключ - Строка - имя реквизита;
//    ** Значение - Произвольный - значение реквизита.
Функция ЗначенияРеквизитовОбъектов(Знач МассивСсылокИлиОбъектов, Знач ИменаРеквизитов, Знач ВыбратьРазрешенные = Ложь, Кэш = Неопределено) Экспорт
	
	Если МассивСсылокИлиОбъектов.Количество() = 0 Тогда Возврат Новый Соответствие; КонецЕсли;
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	// 1. Разбираем реквизиты
	МассивДляЗапроса   = Новый Массив;
	МассивЧистыхИмен   = Новый Массив;
	СтруктураРезультат = Новый Структура;
	
	ТипВходныхРеквизитов = ТипЗнч(ИменаРеквизитов);
	Если ТипВходныхРеквизитов = Тип("Строка") Тогда ИменаРеквизитов = СтрРазделить(ИменаРеквизитов, ",", Ложь); ТипВходныхРеквизитов = Тип("Массив"); КонецЕсли;
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИменаРеквизитов, ТипВходныхРеквизитов) Тогда
		
		Для Каждого ИмяРеквизита Из ИменаРеквизитов Цикл
			
			ИмяРеквизита = СокрЛП(ИмяРеквизита);
			
			МассивРазделенныйМассив = Спец_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяРеквизита, " КАК ");
			Если МассивРазделенныйМассив.Количество() = 1 Тогда
				
				ИмяДляЗапроса = ИмяРеквизита;
				ИмяПсевдонима = Спец_СтроковыеФункцииКлиентСервер.ОчиститьИмяДляЗапроса(ИмяРеквизита);
				
			ИначеЕсли МассивРазделенныйМассив.Количество() = 2 Тогда
				
				ИмяДляЗапроса = СокрЛП(МассивРазделенныйМассив.Получить(0));
				ИмяПсевдонима = Спец_СтроковыеФункцииКлиентСервер.ОчиститьИмяДляЗапроса(МассивРазделенныйМассив.Получить(1));
				
			Иначе
				
				ВызватьИсключение "Пришёл странный реквизит: " + ИмяРеквизита;
				
			КонецЕсли;
			
			// Запрос в цикле, если обращения через точку
			//@skip-check query-in-loop
			ДобавитьПолеДляОбработки(Неопределено, МассивДляЗапроса, МассивЧистыхИмен, СтруктураРезультат, ИмяДляЗапроса, ИмяПсевдонима, Ложь, Кэш);
			
		КонецЦикла;
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ИменаРеквизитов, ТипВходныхРеквизитов)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(ИменаРеквизитов, ТипВходныхРеквизитов) Тогда
		
		//@skip-check query-in-loop
		//@skip-check invocation-parameter-type-intersect
		Для Каждого КлючЗначение Из ИменаРеквизитов Цикл ДобавитьПолеДляОбработки(Неопределено, МассивДляЗапроса, МассивЧистыхИмен, СтруктураРезультат, КлючЗначение.Значение, КлючЗначение.Ключ, Ложь, Кэш); КонецЦикла;
		
	Иначе
		
		ВызватьИсключение "Неизвестный тип реквизитов для разбора!";
		
	КонецЕсли;
	
	ПрисоединяемТаблицу     = МассивСсылокИлиОбъектов.Количество() > 500; // Для большого количества объектов лучше использовать внутреннее соединение
	СоответствиеРезультат   = Новый Соответствие;
	СоответствиеТипов       = НовоеСоответствиеТиповДляЗначенияРеквизитовОбъектов();
	МассивТипов             = Новый Массив; // Массив из Тип
	МассивТекстыЗапросов    = Новый Массив; // Массив из Строка
	МассивСсылокДляПередачи = Новый Массив; // Массив из ЛюбаяСсылка
	ИменаРеквизитов         = СтрСоединить(МассивЧистыхИмен, ",");
	СтруктураПараметров     = Новый Структура;
	
	Для Каждого СсылкаИлиОбъект Из МассивСсылокИлиОбъектов Цикл
		
		ТипСсылки = ТипЗнч(СсылкаИлиОбъект);
		Если ЭтоСсылочныйТип(СсылкаИлиОбъект, ТипСсылки) Тогда
			
			Если СоответствиеТипов[ТипСсылки] = Неопределено Тогда
				
				МетаданныеОбъекта = ОбъектМетаданныхПоТипуВКэш(ТипСсылки, Кэш);
				
				ЧистоеИмя = СтрЗаменить(МетаданныеОбъекта.ПолноеИмя(), ".", "");
				Если ПрисоединяемТаблицу Тогда
					
					МассивТекстыЗапросов.Добавить(СтрШаблон(
							
							"ВЫБРАТЬ " + ?(ВыбратьРазрешенные, "РАЗРЕШЕННЫЕ", "") + "
							|	Таблица.Ссылка КАК Спец_Ссылка,
							|	%1
							|ИЗ
							|	%2 КАК Таблица
							|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ втТаблицаСсылок КАК втТаблицаСсылок
							|		ПО (Таблица.Ссылка = ВЫРАЗИТЬ(втТаблицаСсылок.Ссылка КАК %2))",
							
							СтрСоединить(МассивДляЗапроса, ","),
							МетаданныеОбъекта.ПолноеИмя()));
					
				Иначе
					
					МассивТекстыЗапросов.Добавить(СтрШаблон(
							
							"ВЫБРАТЬ " + ?(ВыбратьРазрешенные, "РАЗРЕШЕННЫЕ", "") + "
							|	Таблица.Ссылка КАК Спец_Ссылка,
							|	%1
							|ИЗ
							|	%2 КАК Таблица
							|ГДЕ
							|	Таблица.Ссылка В(&МассивСсылок_%3)",
							
							СтрСоединить(МассивДляЗапроса, ","),
							МетаданныеОбъекта.ПолноеИмя(),
							ЧистоеИмя));
					
				КонецЕсли;
				
				МассивТипов.Добавить(ТипСсылки);
				СоответствиеТипов[ТипСсылки] = ЧистоеИмя;
				СтруктураПараметров.Вставить("МассивСсылок_" + ЧистоеИмя, Новый Массив);
				
			КонецЕсли;
			
			//@skip-check dynamic-access-method-not-found
			Если ПрисоединяемТаблицу Тогда МассивСсылокДляПередачи.Добавить(СсылкаИлиОбъект); Иначе СтруктураПараметров["МассивСсылок_" + СоответствиеТипов[ТипСсылки]].Добавить(СсылкаИлиОбъект); КонецЕсли;
			
		ИначеЕсли ЭтоОбъектныйТип(СсылкаИлиОбъект) Тогда
			
			//@skip-check query-in-loop
			СоответствиеРезультат[СсылкаИлиОбъект] = ЗначенияРеквизитовОбъекта(СсылкаИлиОбъект, ИменаРеквизитов, ВыбратьРазрешенные, Кэш);
			Продолжить;
			
		Иначе
			
			Продолжить;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Запрос = Новый Запрос(СтрШаблон(
			
			?(ПрисоединяемТаблицу,
						
					"ВЫБРАТЬ
					|	ИсходныеДанные.Ссылка КАК Ссылка
					|ПОМЕСТИТЬ втТаблицаСсылок
					|ИЗ
					|	&ИсходныеДанные КАК ИсходныеДанные
					|;
					|
					|
					|%1",
					
					"%1"),
			
			СтрСоединить(МассивТекстыЗапросов, Спец_КонстантыКлиентСервер.РазделительОбъединяющихЗапросов())));
	
	Если ПрисоединяемТаблицу Тогда
		
		ТаблицаДляЗапроса = НоваяТаблицаСКолонкойСсылкаПоМассивуТипов(МассивТипов);
		Для Каждого СсылкаИлиОбъект Из МассивСсылокДляПередачи Цикл ТаблицаДляЗапроса.Добавить().Ссылка = СсылкаИлиОбъект; КонецЦикла;
		Запрос.УстановитьПараметр("ИсходныеДанные", ТаблицаДляЗапроса);
		
	Иначе
		
		Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьОбъект(СтруктураПараметров, Запрос.Параметры);
		
	КонецЕсли;
	
	Попытка
		
		ВыборкаРезультат = Запрос.Выполнить().Выбрать();
		
	Исключение
		
		ТекстИсключения = СтрШаблон("Не удалось выполнить запрос ""ЗначенияРеквизитовОбъектов""!%1Ошибка при выполнении:%1%2%1Текст запроса:%1%3",
				Символы.ПС,
				Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб),
				Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(Запрос.Текст));
		
		ВызватьИсключение ТекстИсключения;
		
	КонецПопытки;
	
	Пока ВыборкаРезультат.Следующий() Цикл
		
		СтруктураПоСсылке = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(СтруктураПоСсылке, ВыборкаРезультат);
		
		//@skip-check property-return-type
		СоответствиеРезультат[ВыборкаРезультат.Спец_Ссылка] = СтруктураПоСсылке;
		
	КонецЦикла;
	
	Возврат СоответствиеРезультат;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  МассивСсылокИлиОбъектов - см. ЗначенияРеквизитовОбъектов.МассивСсылокИлиОбъектов
//  ИмяРеквизита - Строка - имя получаемого реквизита.
//                          Допускается указание имени реквизита через точку.
//                    		Допускается задать имя реквизита результат, например "Код КАК КодСправочника".
//  ВыбратьРазрешенные - см. ЗначенияРеквизитовОбъекта.ВыбратьРазрешенные
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//      * Ключ     - ЛюбаяСсылка  - ссылка на объект,
//      * Значение - Произвольный - значение прочитанного реквизита.
Функция ЗначениеРеквизитаОбъектов(Знач МассивСсылокИлиОбъектов, Знач ИмяРеквизита, Знач ВыбратьРазрешенные = Ложь, Кэш = Неопределено) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылокИлиОбъектов, ИмяРеквизита, ВыбратьРазрешенные, Кэш);
	
	ДляВозврата = Новый Соответствие;
	Для Каждого КлючЗначение Из ЗначенияРеквизитов Цикл Для Каждого КлючЗначениеПоОбъекту Из КлючЗначение.Значение Цикл ДляВозврата[КлючЗначение.Ключ] = КлючЗначениеПоОбъекту.Значение; КонецЦикла; КонецЦикла;
	Возврат ДляВозврата;
	
КонецФункции

// Найти по ссылкам программно (аналог НайтиПоСсылкам, только с дополнительными ограничениями).
// Сделано, так как можно очень крепко влететь по памяти, используя платформенный механизм.
// 
// Параметры:
//  МассивОбъектовДляПоиска - Массив из ЛюбаяСсылка
//  						- ФиксированныйМассив из ЛюбаяСсылка
//  МассивОбъектовМетаданныхИлиПолныхИмен - Массив из см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданныхИлиПолноеИмя
//  								 	  - ФиксированныйМассив из см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданныхИлиПолноеИмя
//  								 		Массив метаданных, по которым искать объекты.
//  								 		
//  МассивМетаданныхИлиИменДляИсключения - Массив из Строка
//  									 - Массив из см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
//  									 - ФиксированныйМассив из Строка
//  									 - ФиксированныйМассив из см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных -
//  								 		Массив имён метаданных, по которым НЕ искать объекты.
//  									 
//  КоличествоОграничениеЗаписейВЗапросе - Число - Количество ограничение записей в одном запросе запросе.
//  ВозвращатьТолькоДанные - Булево - Если ИСТИНА, то вернётся массив найденных объектов, в противном случае таблица, аналогичная НайтиПоСсылкам
//  КоличествоМетаданныхВОдномЗапросе - Число - Количество ограничение метаданных в одном запросе
//  ВключитьУпорядочиваниеДляСсылочных - Булево - Включить упорядочивание в запросе для ссылочных объектов
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	- Массив из Произвольный
//	- ТаблицаЗначений:
// 		* ИсходныйОбъект - ЛюбаяСсылка
// 		* ПолноеИмяМетаданных - Строка
// 		* Данные - Произвольный
//
//@skip-check query-in-loop
Функция НайтиПоСсылкамПрограммно(Знач МассивОбъектовДляПоиска, Знач МассивОбъектовМетаданныхИлиПолныхИмен = Неопределено, Знач МассивМетаданныхИлиИменДляИсключения = Неопределено,
		Знач КоличествоОграничениеЗаписейВЗапросе = 65536, Знач ВозвращатьТолькоДанные = Ложь, Знач КоличествоМетаданныхВОдномЗапросе = 1024, 
		Знач ВключитьУпорядочиваниеДляСсылочных = Ложь, Кэш = Неопределено) Экспорт
	
	ОбъектДляВозврата = НовыйОбъектДляВозвратаНайтиПоСсылкамПрограммно(ВозвращатьТолькоДанные);
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивОбъектовДляПоиска);
	
	Если МассивОбъектовДляПоиска.Количество() = 0 Тогда Возврат ОбъектДляВозврата; КонецЕсли;
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ЧистыйМассивМетаданных        = НайтиПоСсылкамПрограммно_СформироватьМассивМетаданныхДляПоиска(МассивОбъектовМетаданныхИлиПолныхИмен, МассивМетаданныхИлиИменДляИсключения, Кэш);
	СоответствиеПараметровЗапроса = НайтиПоСсылкамПрограммно_СформироватьСоответствиеПараметровЗапроса(МассивОбъектовДляПоиска, Кэш);
	ТекстЗапросаОграничение       = "ПЕРВЫЕ " + Формат(КоличествоОграничениеЗаписейВЗапросе, "ЧН=65536; ЧГ=");
	
	МассивПоПакетам = Спец_РаботаСКоллекциямиКлиентСервер.РазбитьКоллекциюПоПакетам(ЧистыйМассивМетаданных, КоличествоМетаданныхВОдномЗапросе);
	Для Каждого ПакетПоМетаданным Из МассивПоПакетам Цикл // Массив из см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданныхИлиПолноеИмя
		
		// 2. Составляем тексты запросов
		МассивТекстыЗапросов          = Новый Массив; // Массив из Строка
		МассивТекстыСсылочныхЗапросов = Новый Массив; // Массив из Строка
		ЕстьРегистры                  = Ложь;
		
		Для Каждого ОбъектМетаданных Из ПакетПоМетаданным Цикл // ОбъектМетаданных
			
			//@skip-check dynamic-access-method-not-found
			ПолноеИмяОбъекта = ОбъектМетаданных.ПолноеИмя(); // Строка
			Если ЭтоКонстанта(ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
				
				НайтиПоСсылкамПрограммно_СформироватьЗапросыДляКонстанты(ОбъектМетаданных,
						ПолноеИмяОбъекта,
						СоответствиеПараметровЗапроса,
						ВозвращатьТолькоДанные,
						МассивТекстыСсылочныхЗапросов);
				
			ИначеЕсли ЭтоСсылка(ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
				
				НайтиПоСсылкамПрограммно_СформироватьЗапросыДляСсылочногоТипа(ОбъектМетаданных,
						ПолноеИмяОбъекта,
						СоответствиеПараметровЗапроса,
						ТекстЗапросаОграничение,
						ВозвращатьТолькоДанные,
						Кэш,
						МассивТекстыСсылочныхЗапросов);
				
			ИначеЕсли ЭтоРегистр(ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
				
				ЕстьРегистры = Истина;
				НайтиПоСсылкамПрограммно_СформироватьЗапросыДляРегистра(ОбъектМетаданных,
						ПолноеИмяОбъекта,
						СоответствиеПараметровЗапроса,
						ТекстЗапросаОграничение,
						ВозвращатьТолькоДанные,
						Кэш,
						МассивТекстыЗапросов);
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если МассивТекстыСсылочныхЗапросов.Количество() Тогда
			
			Если ВозвращатьТолькоДанные Тогда
				
				МассивТекстыЗапросов.Добавить(СтрШаблон(
						
						"ВЫБРАТЬ РАЗЛИЧНЫЕ %3
						|	Спец_ТаблицаОбъекта.Данные КАК Данные
						|ИЗ
						|	(%1) КАК Спец_ТаблицаОбъекта
						|%2",
						
						Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(СтрСоединить(МассивТекстыСсылочныхЗапросов, Спец_КонстантыКлиентСервер.РазделительОбъединяющихЗапросов())),
						?(ВключитьУпорядочиваниеДляСсылочных, "УПОРЯДОЧИТЬ ПО Данные АВТОУПОРЯДОЧИВАНИЕ", ""),
						ТекстЗапросаОграничение));
				
			Иначе
				
				МассивТекстыЗапросов.Добавить(СтрШаблон(
						
						"ВЫБРАТЬ РАЗЛИЧНЫЕ %3
						|	Спец_ТаблицаОбъекта.ИсходныйОбъект КАК ИсходныйОбъект,
						|	Спец_ТаблицаОбъекта.ПолноеИмяМетаданных КАК ПолноеИмяМетаданных,
						|	Спец_ТаблицаОбъекта.Данные КАК Данные
						|ИЗ
						|	(%1) КАК Спец_ТаблицаОбъекта
						|%2",
						
						Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(СтрСоединить(МассивТекстыСсылочныхЗапросов, Спец_КонстантыКлиентСервер.РазделительОбъединяющихЗапросов())),
						?(ВключитьУпорядочиваниеДляСсылочных, "УПОРЯДОЧИТЬ ПО Данные АВТОУПОРЯДОЧИВАНИЕ", ""),
						ТекстЗапросаОграничение));
				
			КонецЕсли;
			
		КонецЕсли;
		
		// 3. Выполняем запрос (если что-то есть для выполнения)
		Если МассивТекстыЗапросов.Количество() = 0 Тогда Продолжить; КонецЕсли;
		
		Запрос = Новый Запрос(СтрСоединить(МассивТекстыЗапросов, Спец_КонстантыКлиентСервер.РазделительЗапросов()));
		Для Каждого КлючЗначение Из СоответствиеПараметровЗапроса Цикл
			Запрос.УстановитьПараметр(КлючЗначение.Значение.ИмяПараметра, КлючЗначение.Значение.ЗначениеПараметра);
		КонецЦикла;
		
		// Можно сразу вернуть результат
		Если Не ЕстьРегистры И МассивПоПакетам.Количество() = 1 Тогда
			 
			Возврат ?(ВозвращатьТолькоДанные,
					Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Данные"),
					Запрос.Выполнить().Выгрузить());
			
		КонецЕсли;
		
		ПакетыЗапросов = Запрос.ВыполнитьПакет();
		
		// 4. Обрабатываем результаты запросов
		Для Каждого ПакетЗапроса Из ПакетыЗапросов Цикл
			
			ВыборкаПоОбъектам = ПолучитьВыборкуПоОбъектам(ПакетЗапроса);
			Пока ВыборкаПоОбъектам.Следующий() Цикл
				
				Если ВозвращатьТолькоДанные Тогда
					
					Если Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(ВыборкаПоОбъектам, "ПолноеИмяМетаданных") Тогда // Это регистр
						
						СтруктураПоМетаданным   = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ВыборкаПоОбъектам.ПолноеИмяМетаданных, Кэш);
						ИменаРеквизитовДляКлюча = СтрСоединить(ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(СтруктураПоМетаданным.МетаданныеОбъекта, Кэш), ",");
						Если Не ПустаяСтрока(ИменаРеквизитовДляКлюча) Тогда
							
							СтруктураКлюча = Новый Структура(ИменаРеквизитовДляКлюча);
							ЗаполнитьЗначенияСвойств(СтруктураКлюча, ВыборкаПоОбъектам, ИменаРеквизитовДляКлюча);
							
							ОбъектДляВозврата.Добавить(СтруктураПоМетаданным.МенеджерОбъекта.СоздатьКлючЗаписи(СтруктураКлюча));
							
						Иначе
							
							ОбъектДляВозврата.Добавить(СтруктураПоМетаданным.МенеджерОбъекта.СоздатьКлючЗаписи(Новый Структура));
							
						КонецЕсли;
						
					Иначе
						
						ОбъектДляВозврата.Добавить(ВыборкаПоОбъектам.Данные);
						
					КонецЕсли;
					
				ИначеЕсли ЭтоРегистр(ВыборкаПоОбъектам.ПолноеИмяМетаданных, Кэш, Тип("Строка")) Тогда
					
					СтруктураПоМетаданным   = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ВыборкаПоОбъектам.ПолноеИмяМетаданных, Кэш);
					ИменаРеквизитовДляКлюча = СтрСоединить(ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(СтруктураПоМетаданным.МетаданныеОбъекта, Кэш), ",");
					
					НоваяСтрокаТаблицы = ОбъектДляВозврата.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрокаТаблицы, ВыборкаПоОбъектам, "ИсходныйОбъект, ПолноеИмяМетаданных");
					
					Если Не ПустаяСтрока(ИменаРеквизитовДляКлюча) Тогда
						
						СтруктураКлюча = Новый Структура(ИменаРеквизитовДляКлюча);
						ЗаполнитьЗначенияСвойств(СтруктураКлюча, ВыборкаПоОбъектам, ИменаРеквизитовДляКлюча);
						
						НоваяСтрокаТаблицы.Данные = СтруктураПоМетаданным.МенеджерОбъекта.СоздатьКлючЗаписи(СтруктураКлюча);
						
					Иначе
						
						НоваяСтрокаТаблицы.Данные = СтруктураПоМетаданным.МенеджерОбъекта.СоздатьКлючЗаписи(Новый Структура);
						
					КонецЕсли;
					
				Иначе
					
					НоваяСтрокаТаблицы = ОбъектДляВозврата.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрокаТаблицы, ВыборкаПоОбъектам, "ИсходныйОбъект, ПолноеИмяМетаданных, Данные");
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат ОбъектДляВозврата;
	
КонецФункции

// Возвращает флаг того, что передали пустую или битую ссылку.
// 
// Параметры:
//  СсылкаДляПроверки - ЛюбаяСсылка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоПустаяИлиБитаяСсылка(Знач СсылкаДляПроверки, Кэш = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(СсылкаДляПроверки) Тогда Возврат Истина; КонецЕсли; // Отсеиваем пустые ссылки
	
	СтруктураПоМетаданным = ПолучитьСтруктуруИмениТипаДанныхОбъекта(СсылкаДляПроверки, Кэш);
	Если СтруктураПоМетаданным.МетаданныеОбъекта = Неопределено
		Или Не ЭтоСсылка(СтруктураПоМетаданным.ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Запрос = Новый Запрос(СтрШаблон(
			
			"ВЫБРАТЬ
			|	ИСТИНА
			|ИЗ
			|	%1 КАК ТаблицаОбъекта
			|ГДЕ
			|	ТаблицаОбъекта.Ссылка = &Ссылка",
			
			СтруктураПоМетаданным.ПолноеИмяОбъекта));
	
	Запрос.УстановитьПараметр("Ссылка", СсылкаДляПроверки);
	Возврат Запрос.Выполнить().Пустой();
	
КонецФункции

// Обработка заполнения объекта по структуре. Вызывается из модуля объекта, если данные заполнения имеют тип "Структура".
// 
// Параметры:
//  Источник - см. ЗаписатьОбъект.ОбъектДляЗаписи
//  ДанныеЗаполнения - Структура
//  ТипДанныхЗаполнения - Тип
//
Процедура ОбработкаЗаполненияОбъектаПоСтруктуре(Знач Источник, Знач ДанныеЗаполнения, Знач ТипДанныхЗаполнения = Неопределено) Экспорт
	
	Если Не Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ДанныеЗаполнения, ТипДанныхЗаполнения) Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(Источник, ДанныеЗаполнения);
	Для Каждого ТабличнаяЧасть Из Источник.Метаданные().ТабличныеЧасти Цикл
		
		//@skip-check dynamic-access-method-not-found
		Источник[ТабличнаяЧасть.Имя].Очистить();
		//@skip-check invocation-parameter-type-intersect
		Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьТаблицу(
				Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСтруктуры(ДанныеЗаполнения, ТабличнаяЧасть.Имя, Новый Массив()),
				Источник[ТабличнаяЧасть.Имя]);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область РаботаТаблицамиИЗапросами

// Возвращает структуру первой выборки из запроса. Удобно использовать для запросов, у которых ВЫБРАТЬ ПЕРВЫЕ 1.
// 
// Параметры:
//  ЗапросДляПолучения - Запрос - Запрос для получения первого результата.
//  ИмяКолонки - Строка - Если указано, то вернёт значение в данной колонке в результате запроса.
// 
// Возвращаемое значение:
//  - Структура - Если ИмяКолонки не указано
//	- Произвольный - Если ИмяКолонки указано
Функция ПолучитьСтруктуруПервойВыборкиЗапроса(Знач ЗапросДляПолучения, Знач ИмяКолонки = "") Экспорт
	
	ТаблицаРезультат = ЗапросДляПолучения.Выполнить().Выгрузить();
	СтрокаРезультат  = ?(ТаблицаРезультат.Количество() = 0, СкопироватьТаблицуБезNull(ТаблицаРезультат).Добавить(), ТаблицаРезультат.Получить(0));
	
	Возврат ?(ПустаяСтрока(ИмяКолонки),
			ПреобразоватьСтрокуТаблицыЗначенийВСтруктуру(СтрокаРезультат, ТаблицаРезультат.Колонки),
			СтрокаРезультат[ИмяКолонки]);
	
КонецФункции

// Преобразует таблицу значений в массив строк. Может использоваться для передачи на клиент данных.
// Полученный массив содержит структуры, каждая из которых повторяет структуру колонок таблицы значений.
// Если в колонках лежит таблица значений, дерево значений или результат запроса, то они так же преобразуются в массив структур.
//
// Не рекомендуется использовать для преобразования таблиц значений с большим количеством строк!
// 
// Параметры:
//  ТаблицаДляПреобразования - ТаблицаЗначений - исходная таблица значений.
// 
// Возвращаемое значение:
//  Массив из Структура - Массив структур строк, полученных из таблицы для преобразования.
Функция ПреобразоватьТаблицуЗначенийВМассивСтрок(Знач ТаблицаДляПреобразования) Экспорт
	
	МассивРезультат = Новый Массив; // Массив из Структура
	Для Каждого Строка Из ТаблицаДляПреобразования Цикл МассивРезультат.Добавить(ПреобразоватьСтрокуТаблицыЗначенийВСтруктуру(Строка, ТаблицаДляПреобразования.Колонки)); КонецЦикла;
	Возврат МассивРезультат;
	
КонецФункции

// Метод для преобразования строки таблицы значений в структуру.
// Свойства структуры и их значения совпадают с колонками переданной строки.
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений, ВыборкаИзРезультатаЗапроса - Строка таблицы для преобразования
//  КолонкиТаблицыЗначений - Неопределено, КоллекцияКолонокТаблицыЗначений - Колонки таблицы значений
// 
// Возвращаемое значение:
//  Структура - Структура результат преобразования
Функция ПреобразоватьСтрокуТаблицыЗначенийВСтруктуру(Знач СтрокаТаблицыЗначений, Знач КолонкиТаблицыЗначений = Неопределено) Экспорт
	
	СтруктураРезультат = Новый Структура();
	Если КолонкиТаблицыЗначений = Неопределено Тогда КолонкиТаблицыЗначений = СтрокаТаблицыЗначений.Владелец().Колонки; КонецЕсли;
	
	Для Каждого Колонка Из КолонкиТаблицыЗначений Цикл
		
		ТипЗначения = ТипЗнч(СтрокаТаблицыЗначений[Колонка.Имя]);
		Если ТипЗначения = Тип("ТаблицаЗначений") Тогда
			
			//@skip-check invocation-parameter-type-intersect
			СтруктураРезультат.Вставить(Колонка.Имя, ПреобразоватьТаблицуЗначенийВМассивСтрок(СтрокаТаблицыЗначений[Колонка.Имя]));
			
		ИначеЕсли ТипЗначения = Тип("РезультатЗапроса") Тогда
			
			МассивРезультат = Новый Массив; // Массив из Структура
			РезультатЗапроса = СтрокаТаблицыЗначений[Колонка.Имя]; // РезультатЗапроса
			ВыборкаРезультат = РезультатЗапроса.Выбрать();
			Пока ВыборкаРезультат.Следующий() Цикл МассивРезультат.Добавить(ПреобразоватьСтрокуТаблицыЗначенийВСтруктуру(ВыборкаРезультат, РезультатЗапроса.Колонки)); КонецЦикла;
			СтруктураРезультат.Вставить(Колонка.Имя, МассивРезультат);
			
		Иначе
			
			СтруктураРезультат.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Метод для помещения таблицы значений в менеджер временных таблиц.
// 
// Параметры:
//  ТаблицаИсходныеДанные - ТаблицаЗначений - Таблица для помещения в МВТ
//  ИмяТаблицыДляПомещения - Строка - Имя временной таблицы для помещения
//  МенеджерВременныхТаблиц - Неопределено, МенеджерВременныхТаблиц - Менеджер временных таблиц результат.
// 
// Возвращаемое значение:
//  МенеджерВременныхТаблиц
Функция ПоместитьИсходныеДанныеВМенеджерВременныхТаблиц(Знач ТаблицаИсходныеДанные, Знач ИмяТаблицыДляПомещения = "втИсходныеДанные", МенеджерВременныхТаблиц = Неопределено) Экспорт
	
	Если МенеджерВременныхТаблиц = Неопределено Тогда
		МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц();
	КонецЕсли;
	
	МассивТекстЗапроса = Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве("ВЫБРАТЬ"); // Массив из Строка
	
	МассивТекстКолонок = Новый Массив; // Массив из Строка
	Для Каждого Колонка Из ТаблицаИсходныеДанные.Колонки Цикл МассивТекстКолонок.Добавить(СтрШаблон("	ИсходныеДанные.%1 КАК %1", Колонка.Имя)); КонецЦикла;
	
	МассивТекстЗапроса.Добавить(СтрСоединить(МассивТекстКолонок, "," + Символы.ПС));
	МассивТекстЗапроса.Добавить(
		"ПОМЕСТИТЬ " + ИмяТаблицыДляПомещения + "
		|ИЗ
		|	&ИсходныеДанные КАК ИсходныеДанные");
	
	Запрос = Новый Запрос;
	
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = СтрСоединить(МассивТекстЗапроса, Символы.ПС);
	
	Запрос.УстановитьПараметр("ИсходныеДанные", ТаблицаИсходныеДанные);
	
	Запрос.Выполнить();
	Возврат МенеджерВременныхТаблиц;
	
КонецФункции

// Преобразует массив строк в таблицу значений. Обратный метод для ПреобразоватьТаблицуЗначенийВМассивСтрок.
// Если внутри массива структур встречается массив структур (вложенная таблица), то она также преобразуется.
// ТаблицаРезультат передавать с нужными колонками (с нужными типами)
// Иначе будет создана таблица, где все типы колонок будут взяты из первой строки.
// 
// Параметры:
//  МассивДляПреобразования - Массив из Структура - Массив для преобразования
//  ТаблицаРезультат - Неопределено, ТаблицаЗначений - Таблица результат с установленными типами колонок.
// 
// Возвращаемое значение:
//  ТаблицаЗначений
Функция ПреобразоватьМассивСтрокВТаблицуЗначений(Знач МассивДляПреобразования, ТаблицаРезультат = Неопределено) Экспорт
	
	МассивКолонокСТаблицей = Новый Массив; // Массив из Строка
	Если ТаблицаРезультат = Неопределено Тогда
		
		ТаблицаРезультат = Новый ТаблицаЗначений();
		Если МассивДляПреобразования.Количество() = 0 Тогда
			Возврат ТаблицаРезультат;
		КонецЕсли;
		
		НулеваяСтрока = МассивДляПреобразования.Получить(0);
		СоответствиеТипов = НовоеСоответствиеДляПреобразованияМассиваСтрокВТаблицуЗначений();
		
		Для Каждого КлючЗначение Из НулеваяСтрока Цикл
			
			ТипКолонки = ТипЗнч(КлючЗначение.Значение);
			Если ТипКолонки = Тип("Массив")
				Или ТипКолонки = Тип("ФиксированныйМассив") Тогда
				
				ТипКолонки = Тип("ТаблицаЗначений");
				МассивКолонокСТаблицей.Добавить(КлючЗначение.Ключ);
				
			КонецЕсли;
			
			СоответствиеТипов[КлючЗначение.Ключ] = Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(ТипКолонки);
			
		КонецЦикла;
		
		Для Каждого КлючЗначение Из СоответствиеТипов Цикл
			ТаблицаРезультат.Колонки.Добавить(КлючЗначение.Ключ, Новый ОписаниеТипов(КлючЗначение.Значение));
		КонецЦикла;
		
	Иначе
		
		Для Каждого КолонкаТаблицы Из ТаблицаРезультат.Колонки Цикл
			
			Если КолонкаТаблицы.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений")) Тогда
				МассивКолонокСТаблицей.Добавить(КолонкаТаблицы.Имя);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	ИменаКолонокСТаблицей = СтрСоединить(МассивКолонокСТаблицей, ",");
	//@skip-check invocation-parameter-type-intersect
	Для Каждого ИсходнаяСтрока Из МассивДляПреобразования Цикл НоваяСтрока = ТаблицаРезультат.Добавить(); ЗаполнитьЗначенияСвойств(НоваяСтрока, ИсходнаяСтрока, , ИменаКолонокСТаблицей); Для Каждого КолонкаТаблицы Из МассивКолонокСТаблицей Цикл НоваяСтрока[КолонкаТаблицы] = ПреобразоватьМассивСтрокВТаблицуЗначений(ИсходнаяСтрока[КолонкаТаблицы]); КонецЦикла; КонецЦикла;
	//@skip-check constructor-function-return-section
	Возврат ТаблицаРезультат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Возвращаемое значение:
//  см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
Функция ПолучитьКэш() Экспорт
	
	АдресКэшКомпонент = Спец_ПолучитьЗначениеПеременной("КэшСервер", Ложь); // Строка
	Если АдресКэшКомпонент <> Неопределено И ЭтоАдресВременногоХранилища(АдресКэшКомпонент) Тогда
		
		КэшКомпонент = ПолучитьИзВременногоХранилища(АдресКэшКомпонент); // см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
		Если КэшКомпонент = Неопределено Или КэшКомпонент.ДляПроверкиЦелостности = Неопределено Тогда // Все очистилось, собираем заново.
			
			УдалитьИзВременногоХранилища(АдресКэшКомпонент);
			АдресКэшКомпонент = Неопределено;
			
		Иначе
			
			Возврат КэшКомпонент;
			
		КонецЕсли;
		
	КонецЕсли;
	
	КэшКомпонент = Спец_ОбщегоНазначенияКлиентСервер.БазовыйКэш();
	АдресКэшКомпонент = ПоместитьВоВременноеХранилище(КэшКомпонент, Новый УникальныйИдентификатор);
	
	Спец_УстановитьЗначениеПеременной("КэшСервер", АдресКэшКомпонент);
	//@skip-check constructor-function-return-section
	Возврат КэшКомпонент;
	
КонецФункции

Процедура ЗапуститьДемонКластера() Экспорт
	
	Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоWindows() Тогда
		Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы(СтрШаблон("""%1ras.exe"" cluster", КаталогПрограммы()), Ложь, Ложь);
	Иначе
		Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы(СтрШаблон("'%1ras' --daemon cluster", КаталогПрограммы()), Истина, Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  Имя - Строка
// 
// Возвращаемое значение:
//  ОбщийМодуль
Функция СерверныйМодульМенеджера(Знач Имя) Экспорт
	
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег("Константы") Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыСведений") Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыНакопления") Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыБухгалтерии") Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыРасчета") Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Справочники") Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Документы") Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Отчеты") Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Обработки") Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("БизнесПроцессы") Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ЖурналыДокументов") Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Задачи") Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыСчетов") Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыОбмена") Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовХарактеристик") Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовРасчета") Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	
	Возврат Вычислить(Имя);
	
КонецФункции

// Возвращаемое значение:
//	ОписаниеТипов  
Функция ПолучитьОписаниеСсылочныхТипов() Экспорт
	
	ОписаниеТипаЛюбаяСсылкаXDTO = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип("http://v8.1c.ru/8.1/data/core", "TypeDescription"));
	ОписаниеТипаЛюбаяСсылкаXDTO.TypeSet.Добавить(СериализаторXDTO.ЗаписатьXDTO(Новый РасширенноеИмяXML(
			"http://v8.1c.ru/8.1/data/enterprise/current-config", "AnyRef")));
	
	ОписаниеТипаЛюбаяСсылка = СериализаторXDTO.ПрочитатьXDTO(ОписаниеТипаЛюбаяСсылкаXDTO);
	
	// Описание типов расширения
	УстановитьПривилегированныйРежим(Истина);
	
	Попытка
		
		СсылочныеТипыРасширений = Новый Массив;
		
		РасширенияСеанса = РасширенияКонфигурации.Получить(, ИсточникРасширенийКонфигурации.СеансАктивные);
		Для Каждого Расширение Из РасширенияСеанса Цикл
			
			// ++ Спец_БСП.Версия1С_13_ВышеИлиРавно
			Если Не Расширение.ИзменяетСтруктуруДанных() Тогда
				Продолжить;
			КонецЕсли;
			// -- Спец_БСП.Версия1С_13_ВышеИлиРавно
				
			ОМДРасширения = Новый ОбъектМетаданныхКонфигурация(Расширение.ПолучитьДанные());
			Для Каждого ТипОМД Из ТипыОбъектовМетаданныхСсылочногоТипа() Цикл
				ДополнитьТипы(СсылочныеТипыРасширений, ТипОМД, ОМДРасширения);
			КонецЦикла;
			
		КонецЦикла;
		
		Если СсылочныеТипыРасширений.Количество() Тогда
			ОписаниеТипаЛюбаяСсылка = Новый ОписаниеТипов(ОписаниеТипаЛюбаяСсылка, СсылочныеТипыРасширений);
		КонецЕсли;
		
	Исключение
		
		//@skip-check module-unused-local-variable
		tmp = Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке());
		
	КонецПопытки;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат ОписаниеТипаЛюбаяСсылка;
	
КонецФункции

// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
Процедура УстановитьКонстантыПоУмолчанию(Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	НачатьТранзакцию();
	
	// 1. Telegram
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ИдентификаторБота, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ИдентификаторыПолучателей, Новый Массив, , Ложь);
	
	// 2. Взаимодействия
	
	// 2.1. ОтправкаEMail
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.АдресСервераPOP3, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.АдресСервераSMTP, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПарольEMail, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПарольSMTP, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПодписьПисьмаEMail, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПользовательEMail, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПользовательSMTP, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПортPOP3, 110, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПортSMTP, 25, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ТаймаутОтправкиEMail, Спец_КонстантыКлиентСервер.СекундВМинуте(), , Ложь);
	
	// 3. ОбщиеПараметры
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ИмяПользователяПоУмолчанию, "Администратор", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.КоличествоПопытокБлокированияСсылочныхОбъектов, 3, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ЛимитПамятиДляПотоков, Спец_КонстантыКлиентСервер.БайтВКилобайте(256), , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.МинимальныйУровеньЛогирования, Неопределено, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ОбщийFTPКаталог, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПарольПользователяПоУмолчанию, "", , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков, Спец_КонстантыКлиентСервер.БайтВКилобайте(64), , Ложь);
	
	Если Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПервоначальноеЗаполнениеВыполнено, Ложь) <> Истина Тогда
		Спец_УстановитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПервоначальноеЗаполнениеВыполнено, Истина);
	КонецЕсли;
	
	// 3.1. ПараметрыЗаписиОбъектов
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ОбъектыДляКоторыхНеПроверятьМодифицированность, Новый Массив(), , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ОбъектыДляКоторыхПроверятьМодифицированность, Новый Массив(), , Ложь);
	
	// 3.2. ПараметрыЗапускаПриложения
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ВключитьУведомленияПользователей, Истина, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПериодОбновленияНовыхУведомлений, 15, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПодключатьОбработчикЗавершенияРаботыПользователей, Ложь, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.УстанавливатьЗаголовокБазы, Ложь, , Ложь);
	
	МассивПользователиКоторымНеНадоЗаканчивать = Новый Массив; // Массив из Строка
	
	МассивПользователиКоторымНеНадоЗаканчивать.Добавить("Администратор");
	МассивПользователиКоторымНеНадоЗаканчивать.Добавить("Лыков Александр Андреевич");
	МассивПользователиКоторымНеНадоЗаканчивать.Добавить("Лыков Андрей Юрьевич");
	МассивПользователиКоторымНеНадоЗаканчивать.Добавить("Козлов Петр Владимирович");
	
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ПользователиКоторымНеНадоЗаканчивать, МассивПользователиКоторымНеНадоЗаканчивать, , Ложь);
	
	// 3.3. ПараметрыУдаленияСтарыхДанных
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.КоличествоЧасовДляЧисткиTMP, 72, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.СрокХраненияИсторииДанных, 90, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.СрокХраненияЛогов, 48, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.СрокХраненияОшибок, 30, , Ложь);
	
	// 3.4. ПараметрыФоновыхЗаданий
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.КоличествоЗаданийОграничение, 16, , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ОбщееКоличествоЗаданийОграничение, 512, , Ложь);
	
	// 3.5. РаботаСБазойДанных
	УстановитьКонстантыПоУмолчанию_ОбновитьИнформациюПоБазе(Кэш);
	
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ДатаПоследнейКластеризации, Дата(1, 1, 1), , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ДатаПоследнейРеиндексации, Дата(1, 1, 1), , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.ДатаСбросаСтатистики, Дата(1, 1, 1), , Ложь);
	Спец_ПолучитьКонстанту(ПланыВидовХарактеристик.Спец_Константы.КоличествоТаблицИзЧастоИспользуемыхВКэш, 4, , Ложь);
	
	ЗафиксироватьТранзакцию();
	
	ОбновитьПовторноИспользуемыеЗначения();
	
КонецПроцедуры

//@skip-check statement-type-change
//@skip-check invocation-parameter-type-intersect
//@skip-check typed-value-adding-to-untyped-collection
//
// Параметры:
//  Объект1 - см. Спец_РаботаСКоллекциямиКлиентСервер.РазностьОбъектов.ОбъектУменьшаемое
//  Объект2 - см. Спец_РаботаСКоллекциямиКлиентСервер.РазностьОбъектов.ОбъектВычитаемое
//  ОписаниеТипов - см. Спец_РаботаСКоллекциямиКлиентСервер.РазностьОбъектов.ОписаниеТипов
// 
// Возвращаемое значение:
//  см. Спец_РаботаСКоллекциямиКлиентСервер.РазностьОбъектов
//
Функция РазностьОбъектов_ЧерезЗапрос(Знач Объект1, Знач Объект2, Знач ОписаниеТипов = Неопределено) Экспорт
	
	ИсходныйТип       = ТипЗнч(Объект1);
	ЭтоМассив         = Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(Объект1, ИсходныйТип);
	ЭтоСтруктура      = Не ЭтоМассив И Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(Объект1, ИсходныйТип);
	ЭтоСоответствие   = Не ЭтоСтруктура И Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(Объект1, ИсходныйТип);
	ЭтоСписокЗначения = Не ЭтоСоответствие И ИсходныйТип = Тип("СписокЗначений");
	
	Если ЭтоСтруктура Тогда
		
		ОписаниеТипов = Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(1024);
		
	ИначеЕсли ОписаниеТипов = Неопределено Тогда
		
		МассивДобавляемыхТипов = Новый Массив; // Массив из Тип
		
		МассивДобавляемыхТипов.Добавить(Тип("Строка"));
		МассивДобавляемыхТипов.Добавить(Тип("Булево"));
		МассивДобавляемыхТипов.Добавить(Тип("Дата"));
		МассивДобавляемыхТипов.Добавить(Тип("Число"));
		
		ОписаниеТипов = Новый ОписаниеТипов(Спец_ОбщегоНазначенияПовтИсп.ОписаниеТипаВсеСсылки(), МассивДобавляемыхТипов, , , Новый КвалификаторыСтроки(1024));
		
	КонецЕсли;
	
	ТаблицаИсходная = НоваяТаблицаДляРазностиОбъектов(ОписаниеТипов);
	ТаблицаВычитания = НоваяТаблицаДляРазностиОбъектов(ОписаниеТипов);
	
	Если ЭтоМассив Тогда
		
		Для Каждого Строка Из Объект1 Цикл ТаблицаИсходная.Добавить().Значение = Строка; КонецЦикла;
		Для Каждого Строка Из Объект2 Цикл ТаблицаВычитания.Добавить().Значение = Строка; КонецЦикла;
		
	ИначеЕсли ЭтоСтруктура Или ЭтоСоответствие Тогда
		
		Для Каждого Строка Из Объект1 Цикл ТаблицаИсходная.Добавить().Значение = Строка.Ключ; КонецЦикла;
		Для Каждого Строка Из Объект2 Цикл ТаблицаВычитания.Добавить().Значение = Строка.Ключ; КонецЦикла;
		
	ИначеЕсли ЭтоСписокЗначения Тогда
		
		Для Каждого Строка Из Объект1 Цикл ТаблицаИсходная.Добавить().Значение = Строка.Значение; КонецЦикла;
		Для Каждого Строка Из Объект2 Цикл ТаблицаВычитания.Добавить().Значение = Строка.Значение; КонецЦикла;
		
	Иначе
		
		ВызватьИсключение "Неизвестный тип данных";
		
	КонецЕсли;
	
	// Для PostgreSQL индексирование по-другому работает.
	Индексируем = ОписаниеТипов.Типы().Количество() = 1 И Спец_ОбщегоНазначенияПовтИсп.СтруктураПараметровБазы().ТипБазыДанных <> Перечисления.Спец_ТипыБазыДанных.PostgreSQL;
	
	Запрос = Новый Запрос;
	
	#Область ТекстЗапроса
	
	Запрос.Текст =
	
	"ВЫБРАТЬ
	|	ТаблицаИсходная.Значение КАК Значение
	|ПОМЕСТИТЬ втИсходныеЗначения
	|ИЗ
	|	&ТаблицаИсходная КАК ТаблицаИсходная
	|
	|%1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаВычитания.Значение КАК Значение
	|ПОМЕСТИТЬ втТаблицаВычитания
	|ИЗ
	|	&ТаблицаВычитания КАК ТаблицаВычитания
	|
	|%1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	втИсходныеЗначения.Значение КАК Значение
	|ИЗ
	|	втИсходныеЗначения КАК втИсходныеЗначения
	|		ЛЕВОЕ СОЕДИНЕНИЕ втТаблицаВычитания КАК втТаблицаВычитания
	|		ПО втИсходныеЗначения.Значение = втТаблицаВычитания.Значение
	|ГДЕ
	|	втТаблицаВычитания.Значение ЕСТЬ NULL";
	
	#КонецОбласти
	
	Запрос.УстановитьПараметр("ТаблицаИсходная", ТаблицаИсходная);
	Запрос.УстановитьПараметр("ТаблицаВычитания", ТаблицаВычитания);
	
	Запрос.Текст = СтрШаблон(Запрос.Текст, ?(Индексируем, "ИНДЕКСИРОВАТЬ ПО ЗНАЧЕНИЕ", ""));
	
	МассивРезультат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Значение"); // Массив из Произвольный
	Если ЭтоСтруктура Тогда
		
		Результат = Новый Структура;
		Для Каждого Ключ Из МассивРезультат Цикл Результат.Вставить(Ключ, Объект1[Ключ]); КонецЦикла;
		Возврат Результат;
		
	ИначеЕсли ЭтоСоответствие Тогда
		
		Результат = Новый Соответствие;
		Для Каждого Ключ Из МассивРезультат Цикл Результат.Вставить(Ключ, Объект1.Получить(Ключ)); КонецЦикла;
		
		Возврат Результат;
		
	ИначеЕсли ЭтоСписокЗначения Тогда
		
		Результат = Новый СписокЗначений;
		Для Каждого Значение Из МассивРезультат Цикл Строка = Объект1.НайтиПоЗначению(Значение); Результат.Добавить(Строка.Значение, Строка.Представление, Строка.Пометка, Строка.Картинка); КонецЦикла;
		Возврат Результат;
		
	Иначе
		
		Возврат МассивРезультат;
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  СтрокаКоманды - Строка
//  ДождатьсяЗавершения - Булево
//  ВозвращатьРезультат - Булево
//  ТипОСКэш - Неопределено, ПеречислениеСсылка.Спец_ОперационныеСистемы -
// 
// Возвращаемое значение:
//  Булево, Строка -
//
//@skip-check missing-temporary-file-deletion
Функция ВыполнитьКомандуСистемы(Знач СтрокаКоманды, Знач ДождатьсяЗавершения, Знач ВозвращатьРезультат, Знач ТипОСКэш = Неопределено) Экспорт
	
	Если ВозвращатьРезультат Тогда
		
		ДополнительныеПараметры = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКоманды(); 
		
		// Выполняем cmd с параметрами
		Если ТипОСКэш <> Неопределено Тогда
			
			Если ТипОСКэш = Перечисления.Спец_ОперационныеСистемы.Windows Тогда
				
				ШаблонКоманды = "cmd /d /U /C ""%1 > ""%2"" 2>&1""";
				ДополнительныеПараметры.КодировкаДляЧтения = "cp866";
				
			ИначеЕсли ТипОСКэш = Перечисления.Спец_ОперационныеСистемы.Wine Тогда
				
				ШаблонКоманды = "wineconsole cmd /d /U /C ""%1 > ""%2"" 2>&1""";
				
			Иначе
				
				ШаблонКоманды = "%1 > '%2' 2>&1";
				
			КонецЕсли;
			
		ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоWindows() Тогда
			
			ШаблонКоманды = "cmd /d /U /C ""%1 > ""%2"" 2>&1""";
			ДополнительныеПараметры.КодировкаДляЧтения = "cp866";
			
		ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоWine() Тогда
			
			ШаблонКоманды = "wineconsole cmd /d /U /C ""%1 > ""%2"" 2>&1""";
			
		Иначе
			
			ШаблонКоманды = "%1 > '%2' 2>&1";
			
		КонецЕсли;
		
		СтрокаКоманды = СтрШаблон(ШаблонКоманды, СтрокаКоманды, ДополнительныеПараметры.ВременныйФайл);
		
		Попытка
			
			ЗапуститьПриложение(СтрокаКоманды, , ДождатьсяЗавершения);
			
		Исключение
			
			ТекстОшибкиДляЗаписи = "";
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(),
					"Спец_ОбщегоНазначения.ВыполнитьКомандуСистемы(...)",
					ТекстОшибкиДляЗаписи);
			
			ЗаписьТекста = Новый ЗаписьТекста(ДополнительныеПараметры.ВременныйФайл, ДополнительныеПараметры.КодировкаДляЧтения);
			ЗаписьТекста.Записать(ТекстОшибкиДляЗаписи);
			ЗаписьТекста.Закрыть();
			
		КонецПопытки;
		
		Возврат Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом(0, ДополнительныеПараметры);
		
	Иначе
		
		Если ТипОСКэш <> Неопределено Тогда
			
			Если ТипОСКэш = Перечисления.Спец_ОперационныеСистемы.Windows Тогда
				СтрокаКоманды = СтрШаблон("cmd /d /C ""%1""", СтрокаКоманды);
			ИначеЕсли ТипОСКэш = Перечисления.Спец_ОперационныеСистемы.Wine Тогда
				СтрокаКоманды = СтрШаблон("wineconsole cmd /d /C ""%1""", СтрокаКоманды);
			КонецЕсли;
			
		ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоWindows() Тогда
			
			СтрокаКоманды = СтрШаблон("cmd /d /C ""%1""", СтрокаКоманды);
			
		ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоWine() Тогда
			
			СтрокаКоманды = СтрШаблон("wineconsole cmd /d /C ""%1""", СтрокаКоманды);
			
		КонецЕсли;
		
		ЗапуститьПриложение(СтрокаКоманды, , ДождатьсяЗавершения);
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  ЗначениеПеречисления - ПеречислениеСсылка
//  ИмяПеречисления - Строка
// 
// Возвращаемое значение:
//  Число
Функция ПорядокПеречисленияВМетаданных(Знач ЗначениеПеречисления, Знач ИмяПеречисления) Экспорт
	
	Возврат ?(ЗначениеЗаполнено(ЗначениеПеречисления),
			Перечисления[ИмяПеречисления].Индекс(ЗначениеПеречисления),
			-1);
	
КонецФункции

// Параметры:
//  ЗначениеПеречисления - ПеречислениеСсылка
// 
// Возвращаемое значение:
//  Строка
Функция ИмяПеречисленияВМетаданных(Знач ЗначениеПеречисления) Экспорт
	
	Если Не ЗначениеЗаполнено(ЗначениеПеречисления) Тогда
		Возврат "";
	КонецЕсли;
	
	МетаданныеПеречисления = ЗначениеПеречисления.Метаданные();
	Возврат МетаданныеПеречисления.ЗначенияПеречисления[ПорядокПеречисленияВМетаданных(ЗначениеПеречисления, МетаданныеПеречисления.Имя)].Имя;
	
КонецФункции

// Параметры:
//  СоответствиеДляУстановки - Соответствие из КлючИЗначение:
//		* Ключ - Произвольный
//		* Значение - Произвольный
//
// Возвращаемое значение:
//  Структура:
//		* ВключитьУведомленияПользователей - Булево
//		* ПодключатьОбработчикЗавершенияРаботыПользователей - Булево
//		* УстанавливатьЗаголовокБазы - Булево
//		* ПериодОбновленияНовыхУведомлений - Число
//		* ЗаголовокДляУстановки - Строка
//		* СоответствиеКомпонентДляПереустановки - см. НовоеСоответствиеДляРаботыСКомпонентами
//
Функция ПолучитьСтруктуруПараметровДляЗапуска(Знач СоответствиеДляУстановки) Экспорт
	
	УстановитьМассивЗначенийПеременных(СоответствиеДляУстановки);
	
	СтруктураРезультат = НоваяСтруктураПараметровДляЗапуска();

	МассивКонстантДляЗапроса = Новый Массив; // Массив из ПланВидовХарактеристикСсылка.Спец_Константы
	
	Попытка
		
		МассивКонстантДляЗапроса.Добавить(ПланыВидовХарактеристик.Спец_Константы.ПервоначальноеЗаполнениеВыполнено);
		МассивКонстантДляЗапроса.Добавить(ПланыВидовХарактеристик.Спец_Константы.ВключитьУведомленияПользователей);
		МассивКонстантДляЗапроса.Добавить(ПланыВидовХарактеристик.Спец_Константы.ПодключатьОбработчикЗавершенияРаботыПользователей);
		МассивКонстантДляЗапроса.Добавить(ПланыВидовХарактеристик.Спец_Константы.УстанавливатьЗаголовокБазы);
		МассивКонстантДляЗапроса.Добавить(ПланыВидовХарактеристик.Спец_Константы.ПериодОбновленияНовыхУведомлений);
		
	Исключение
		
		Возврат СтруктураРезультат;
		
	КонецПопытки;
	
	ТаблицаРезультат = ПолучитьТаблицуЗначенийКонстантДляПараметровЗапуска(МассивКонстантДляЗапроса);
	
	СтрокаПервоначальноеЗаполнениеВыполнено = ТаблицаРезультат.Найти(ПланыВидовХарактеристик.Спец_Константы.ПервоначальноеЗаполнениеВыполнено, "Константа");
	Если СтрокаПервоначальноеЗаполнениеВыполнено = Неопределено Или СтрокаПервоначальноеЗаполнениеВыполнено.ЗначениеКонстанты <> Истина Тогда
		Возврат СтруктураРезультат;
	КонецЕсли;
	
	СтрокаВключитьУведомленияПользователей = ТаблицаРезультат.Найти(ПланыВидовХарактеристик.Спец_Константы.ВключитьУведомленияПользователей, "Константа");
	СтруктураРезультат.ВключитьУведомленияПользователей = СтрокаВключитьУведомленияПользователей <> Неопределено И СтрокаВключитьУведомленияПользователей.ЗначениеКонстанты = Истина;
	
	СтрокаПодключатьОбработчикЗавершенияРаботыПользователей = ТаблицаРезультат.Найти(ПланыВидовХарактеристик.Спец_Константы.ПодключатьОбработчикЗавершенияРаботыПользователей, "Константа");
	СтруктураРезультат.ПодключатьОбработчикЗавершенияРаботыПользователей = СтрокаПодключатьОбработчикЗавершенияРаботыПользователей <> Неопределено И СтрокаПодключатьОбработчикЗавершенияРаботыПользователей.ЗначениеКонстанты = Истина;
	
	СтрокаУстанавливатьЗаголовокБазы = ТаблицаРезультат.Найти(ПланыВидовХарактеристик.Спец_Константы.УстанавливатьЗаголовокБазы, "Константа");
	СтруктураРезультат.УстанавливатьЗаголовокБазы = СтрокаУстанавливатьЗаголовокБазы <> Неопределено И СтрокаУстанавливатьЗаголовокБазы.ЗначениеКонстанты = Истина;
	
	СтрокаПериодОбновленияНовыхУведомлений = ТаблицаРезультат.Найти(ПланыВидовХарактеристик.Спец_Константы.ПериодОбновленияНовыхУведомлений, "Константа");
	Если СтрокаПериодОбновленияНовыхУведомлений = Неопределено Или ТипЗнч(СтрокаПериодОбновленияНовыхУведомлений.ЗначениеКонстанты) <> Тип("Число") Тогда
		СтруктураРезультат.ПериодОбновленияНовыхУведомлений = 30;
	Иначе
		СтруктураРезультат.ПериодОбновленияНовыхУведомлений = СтрокаПериодОбновленияНовыхУведомлений.ЗначениеКонстанты;
	КонецЕсли;
	
	Если СтруктураРезультат.УстанавливатьЗаголовокБазы Тогда
		
		СтруктураРезультат.ЗаголовокДляУстановки = СтрШаблон("%1 - %2 (%3)",
				Спец_ОбщегоНазначенияПовтИсп.СтруктураПараметровБазы().НаименованиеБазы,
				Спец_ПолучитьЗначениеПеременной("ТекущийПользовательПолноеИмя", Ложь),
				Спец_ПолучитьЗначениеПеременной("ИмяПользователяОСКлиент", Ложь));
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыСеанса.Спец_ТекущийПользователь) Тогда
		ВнешниеКомпонентыДляПереустановки(СтруктураРезультат.СоответствиеКомпонентДляПереустановки);
	КонецЕсли; 
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Параметры:
//  База - СправочникСсылка.Спец_Базы, Неопределено -
// 
// Возвращаемое значение:
//  ФиксированнаяСтруктура:
//		* ИмяБазы - Строка
//		* НаименованиеБазы - Строка
//		* ПолныйАдресFTP - Строка
//		* АдресСервераИБ - Строка
//		* ВидБазы - ПеречислениеСсылка.Спец_ВидыБаз
//		* ПортКластераИБ - Число
//		* ПутьФайловВеб - Строка
//		* СтрокаПодключенияКБазеДанных - Строка
//		* СтрокаПодключенияКБазеДанныхНаСервере - Строка
//		* Магазин - ОпределяемыйТип.Спец_Магазин
//		* ГУИДМагазина - ОпределяемыйТип.Спец_UID
//		* ТипБазыДанных - ПеречислениеСсылка.Спец_ТипыБазыДанных
//
Функция СтруктураПараметровБазы(Знач База = Неопределено) Экспорт
	
	Если База = Неопределено Тогда База = Спец_ОбщегоНазначенияПовтИсп.ЗначениеПараметраСеанса("Спец_ТекущаяБаза"); КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Базы.Код КАК ИмяБазы,
	|	Базы.Наименование КАК НаименованиеБазы,
	|	Базы.АдресFTPДляОбменов + ""/"" + Базы.ВнутреннийПутьКаталогаFTP + ""/"" КАК ПолныйАдресFTP,
	|	Базы.АдресСервераИБ КАК АдресСервераИБ,
	|	Базы.ВидБазы КАК ВидБазы,
	|	Базы.ПортКластераИБ КАК ПортКластераИБ,
	|	Базы.ПутьФайловВеб КАК ПутьФайловВеб,
	|	Базы.СтрокаПодключенияКБазеДанных КАК СтрокаПодключенияКБазеДанных,
	|	Базы.СтрокаПодключенияКБазеДанныхНаСервере КАК СтрокаПодключенияКБазеДанныхНаСервере,
	|	Базы.Магазин КАК Магазин,
	|	Базы.ТипБазыДанных КАК ТипБазыДанных
	|ИЗ
	|	Справочник.Спец_Базы КАК Базы
	|ГДЕ
	|	Базы.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", База);
	
	СтруктураРезультат = ПолучитьСтруктуруПервойВыборкиЗапроса(Запрос); // см. СтруктураПараметровБазы
	СтруктураРезультат.Вставить("ГУИДМагазина", XMLСтрока(СтруктураРезультат.Магазин));
	
	//@skip-check constructor-function-return-section
	Возврат Новый ФиксированнаяСтруктура(СтруктураРезультат);
	
КонецФункции

// Параметры:
//  КлючОбъекта - Строка
//  КлючНастроек - Строка
//  НастройкиДляСохранения - Структура, ФиксированнаяСтруктура -
//
Процедура ДополнитьПользовательскиеНастройкиФормыВХранилищеНастроек(Знач КлючОбъекта, Знач КлючНастроек, Знач НастройкиДляСохранения) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТекущаяСтруктураНастроек = ХранилищеНастроекДанныхФорм.Загрузить(КлючОбъекта, КлючНастроек);
	Если ТекущаяСтруктураНастроек = Неопределено Тогда ТекущаяСтруктураНастроек = Новый Структура(); КонецЕсли;
	
	Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьОбъект(НастройкиДляСохранения, ТекущаяСтруктураНастроек, Истина);
	ХранилищеНастроекДанныхФорм.Сохранить(КлючОбъекта, КлючНастроек, ТекущаяСтруктураНастроек);
	
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры

// Параметры:
//  ИмяПользователя - Строка
//
// Возвращаемое значение:
//  СправочникСсылка.Спец_Пользователи
//
Функция НайтиСоздатьПользователяПоИмени(Знач ИмяПользователя) Экспорт
	
	Если ПустаяСтрока(ИмяПользователя) Тогда
		Возврат Справочники.Спец_Пользователи.ПустаяСсылка();
	КонецЕсли;
	
	// Ищем не по имени, а по ХЕШу.
	ХешСтрока = ПолучитьКонтрольнуюСуммуСтрокой(ИмяПользователя); // Строка
	УИДПользователя = Новый УникальныйИдентификатор(Лев(ХешСтрока, 8) + "-"
				+ Сред(ХешСтрока, 9, 4) + "-"
				+ Сред(ХешСтрока, 13, 4) + "-"
				+ Сред(ХешСтрока, 17, 4) + "-"
				+ Сред(ХешСтрока, 21));
	
	ТекущийПользовательСсылка = Справочники.Спец_Пользователи.ПолучитьСсылку(УИДПользователя);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	
	"ВЫБРАТЬ
	|	ИСТИНА
	|ИЗ
	|	Справочник.Спец_Пользователи КАК Спец_Пользователи
	|ГДЕ
	|	Спец_Пользователи.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", ТекущийПользовательСсылка);
	Если Запрос.Выполнить().Пустой() Тогда
		
		ТекущийПользовательОбъект = Справочники.Спец_Пользователи.СоздатьЭлемент();
		ТекущийПользовательОбъект.УстановитьСсылкуНового(ТекущийПользовательСсылка);
		
		ТекущийПользовательОбъект.Наименование = ИмяПользователя;
		ТекущийПользовательОбъект.РежимЗапуска = Перечисления.Спец_РежимыОсновногоОкна.Обычный;
		
		ТекущийПользовательОбъект.Записать();
		
	КонецЕсли;
	
	Возврат ТекущийПользовательСсылка;
	
КонецФункции

// Параметры:
//	НаименованиеКомпоненты - Строка
// 
// Возвращаемое значение:
//  Булево
//
Функция КомпонентаНеРаботаетУПользователя(Знач НаименованиеКомпоненты) Экспорт
	
	ИмяКомпьютера = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьИмяКомпьютера(Истина);
	Если ПустаяСтрока(ИмяКомпьютера) Тогда
		ИмяКомпьютера = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьИмяКомпьютера(Ложь, Истина);
	КонецЕсли;
	
	Запрос = Новый Запрос();
	Запрос.Текст =
	
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПользователиПараметрыРаботыСКомпонентами.КомпонентаНеРаботает
	|ИЗ
	|	Справочник.Спец_Пользователи.ПараметрыРаботыСКомпонентами КАК ПользователиПараметрыРаботыСКомпонентами
	|ГДЕ
	|	ПользователиПараметрыРаботыСКомпонентами.Ссылка = &Ссылка
	|	И ПользователиПараметрыРаботыСКомпонентами.НаименованиеКомпоненты = &НаименованиеКомпоненты
	|	И ПользователиПараметрыРаботыСКомпонентами.ИмяКомпьютераКлиента = &ИмяКомпьютераКлиента";
	
	Запрос.УстановитьПараметр("Ссылка"                 , ПараметрыСеанса.Спец_ТекущийПользователь);
	Запрос.УстановитьПараметр("НаименованиеКомпоненты" , НаименованиеКомпоненты);
	Запрос.УстановитьПараметр("ИмяКомпьютераКлиента"   , ИмяКомпьютера);
	
	Возврат ПолучитьСтруктуруПервойВыборкиЗапроса(Запрос, "КомпонентаНеРаботает");
	
КонецФункции

// Параметры:
//  МассивСтруктурКомпонент - Массив из Структура:
//	* НаименованиеКомпоненты - Строка
//	* КомпонентаНеРаботает - Булево
//	* НомерВерсии - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура УстановитьПараметрРаботыСКомпонентамиМассовый(Знач МассивСтруктурКомпонент, Кэш = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(ПараметрыСеанса.Спец_ТекущийПользователь) Тогда
		Возврат;
	КонецЕсли;
	
	Кэш = Спец_ПолучитьКэш();
	Для Каждого СтруктураКомпоненты Из МассивСтруктурКомпонент Цикл
		//@skip-check query-in-loop
		УстановитьПараметрРаботыСКомпонентами(СтруктураКомпоненты.НаименованиеКомпоненты, СтруктураКомпоненты.КомпонентаНеРаботает, СтруктураКомпоненты.НомерВерсии, Кэш);
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
//  НаименованиеКомпоненты - Строка
//  КомпонентаНеРаботает - Булево
//  НомерВерсии - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура УстановитьПараметрРаботыСКомпонентами(Знач НаименованиеКомпоненты, Знач КомпонентаНеРаботает, Знач НомерВерсии, Кэш = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(ПараметрыСеанса.Спец_ТекущийПользователь) Тогда
		Возврат;
	КонецЕсли;
	
	Если Кэш = Неопределено Тогда
		Кэш = Спец_ПолучитьКэш();
	КонецЕсли;
	
	ИмяКомпьютераКлиента = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьИмяКомпьютера(Истина);
	ИмяПользователяОС    = Спец_ОбщегоНазначенияКлиентСервер.ТекущийПользовательСистемы(Истина);
	
	Запрос = Новый Запрос();
	Запрос.Текст =
	
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПользователиТекущегоКомпьютера.Пользователь КАК Пользователь
	|ИЗ
	|	(ВЫБРАТЬ
	|		ПользователиПараметрыРаботыСКомпонентами.Ссылка КАК Пользователь
	|	ИЗ
	|		Справочник.Спец_Пользователи.ПараметрыРаботыСКомпонентами КАК ПользователиПараметрыРаботыСКомпонентами
	|	ГДЕ
	|		ПользователиПараметрыРаботыСКомпонентами.ИмяКомпьютераКлиента = &ИмяКомпьютераКлиента
	|		И ПользователиПараметрыРаботыСКомпонентами.ИмяПользователяОС = &ИмяПользователяОС
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		&ТекущийПользователь) КАК ПользователиТекущегоКомпьютера";
	
	Запрос.УстановитьПараметр("ИмяКомпьютераКлиента" , ИмяКомпьютераКлиента);
	Запрос.УстановитьПараметр("ИмяПользователяОС"    , ИмяПользователяОС);
	Запрос.УстановитьПараметр("ТекущийПользователь"  , ПараметрыСеанса.Спец_ТекущийПользователь);
	
	ВыборкаПоПользователям = Запрос.Выполнить().Выбрать();
	Пока ВыборкаПоПользователям.Следующий() Цикл
		
		СправочникОбъект = ПолучитьОбъектСБлокированием(ПараметрыСеанса.Спец_ТекущийПользователь, Кэш); // СправочникОбъект.Спец_Пользователи
		Если СправочникОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураОтбора = Новый Структура("НаименованиеКомпоненты, ИмяКомпьютераКлиента, ИмяПользователяОС",
				НаименованиеКомпоненты,
				ИмяКомпьютераКлиента,
				ИмяПользователяОС);
		
		МассивСтрок = СправочникОбъект.ПараметрыРаботыСКомпонентами.НайтиСтроки(СтруктураОтбора);
		Если МассивСтрок.Количество() = 0 Тогда
			
			СтрокаКомпоненты = СправочникОбъект.ПараметрыРаботыСКомпонентами.Добавить();
			
			СтрокаКомпоненты.НаименованиеКомпоненты = НаименованиеКомпоненты;
			СтрокаКомпоненты.ИмяКомпьютераКлиента   = ИмяКомпьютераКлиента;
			СтрокаКомпоненты.ИмяПользователяОС      = ИмяПользователяОС;
			
		Иначе
			
			СтрокаКомпоненты = МассивСтрок.Получить(0);
			
		КонецЕсли;
		
		СтрокаКомпоненты.КомпонентаНеРаботает = КомпонентаНеРаботает;
		СтрокаКомпоненты.НомерПоследнейУстановленнойВерсии = НомерВерсии;
		
		СправочникОбъект.ДополнительныеСвойства.Вставить("Спец_ПропуститьПроверки", Истина);
		ЗаписатьОбъект(СправочникОбъект, , , , Кэш, , , Ложь);
		
	КонецЦикла;
	
КонецПроцедуры

#Область ДанныеИзБД

// Параметры:
//  МассивМетаданныхОтбор - Массив из см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданныхИлиПолноеИмя
//  					  - см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданныхИлиПолноеИмя
//  					  - Неопределено
//  ВИменахБД - Булево
// 
// Возвращаемое значение:
//	ТаблицаЗначений:
//		* ИмяТаблицыХранения - Строка
//		* ИмяТаблицы - Строка
//		* Назначение - Строка
//		* Метаданные - Строка
//		* Поля - ТаблицаЗначений:
//			** ИмяПоляХранения - Строка
//			** ИмяПоля - Строка
//			** Метаданные - Строка
//		* Индексы - ТаблицаЗначений:
//			** ИмяИндексаХранения - Строка
//			** Поля - ТаблицаЗначений:
//				*** ИмяПоляХранения - Строка
//				*** ИмяПоля - Строка
//				*** Метаданные - Строка
Функция ПолучитьТаблицуСтруктурыХраненияБД(Знач МассивМетаданныхОтбор = Неопределено, Знач ВИменахБД = Истина) Экспорт
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивМетаданныхОтбор);
	Если МассивМетаданныхОтбор.Количество() Тогда
		Возврат ПолучитьСтруктуруХраненияБазыДанных(МассивМетаданныхОтбор, ВИменахБД);
	Иначе
		Возврат ПолучитьСтруктуруХраненияБазыДанных(, ВИменахБД);
	КонецЕсли;
	
КонецФункции

// Параметры:
//  КодТаблицы - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьНаименованиеТаблицыВ1СПоКоду.КодТаблицы
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьНаименованиеТаблицыВ1СПоКоду
Функция ПолучитьИмяТаблицыВ1СПоКодуЧерез1С(Знач КодТаблицы, Кэш = Неопределено) Экспорт
	
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	
	ТаблицаПоБД = ПолучитьТаблицуСтруктурыХраненияБД();
	Для Каждого СтрокаДанныеИзБД Из ТаблицаПоБД Цикл
		
		КодТаблицы = Спец_КомпонентаДополнительныеФункцииКлиентСервер.СтрокаВЧисло(СтрокаДанныеИзБД.ИмяТаблицыХранения, Кэш);
		Если КодТаблицы = КодТаблицы Тогда
			Возврат СтрокаДанныеИзБД.ИмяТаблицы;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат "";
	
КонецФункции

// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - см. ПолучитьТипРеквизитаВ1С.ОбъектМетаданныхИлиПолноеИмя
// 
// Возвращаемое значение:
//  см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьИмяТаблицыИзБД
Функция ПолучитьИмяТаблицыИзБДЧерез1С(Знач ОбъектМетаданныхИлиПолноеИмя) Экспорт
	
	ТаблицаПоБД = ПолучитьТаблицуСтруктурыХраненияБД(ОбъектМетаданныхИлиПолноеИмя);
	Для Каждого СтрокаИзБД Из ТаблицаПоБД Цикл Если Не ПустаяСтрока(СтрокаИзБД.ИмяТаблицы) Тогда Возврат СтрокаИзБД.ИмяТаблицыХранения; КонецЕсли; КонецЦикла;
	Возврат "";
	
КонецФункции

// Параметры:
//  ОбъектМетаданныхИлиПолноеИмя - см. ПолучитьТипРеквизитаВ1С.ОбъектМетаданныхИлиПолноеИмя
//  ИмяРеквизита - Строка
// 
// Возвращаемое значение:
//  см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьИмяРеквизитаИзБД
Функция ПолучитьИмяРеквизитаИзБДЧерез1С(Знач ОбъектМетаданныхИлиПолноеИмя, Знач ИмяРеквизита) Экспорт
	
	ТаблицаПоБД = ПолучитьТаблицуСтруктурыХраненияБД(Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(ОбъектМетаданныхИлиПолноеИмя), Истина);
	Для Каждого СтрокаИзБД Из ТаблицаПоБД Цикл Если Не ПустаяСтрока(СтрокаИзБД.ИмяТаблицы) Тогда СтруктураОтбора = Новый Структура("ИмяПоля", ИмяРеквизита); Возврат СтрСоединить(СтрокаИзБД.Поля.Скопировать(СтруктураОтбора).ВыгрузитьКолонку("ИмяПоляХранения"), ","); КонецЕсли; КонецЦикла;
	
	Возврат "";
	
КонецФункции

// Параметры:
//  ИсходныеДанные - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.НайтиСоздатьОбъектыРегистра.ИсходныеДанные
//  СтруктураПараметров - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.НайтиСоздатьОбъектыРегистра.СтруктураПараметров
//  ТекстыОшибок - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.НайтиСоздатьОбъектыРегистра.ТекстОшибок
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
Процедура НайтиСоздатьОбъектыРегистраЧерез1С(Знач ИсходныеДанные, Знач СтруктураПараметров, ТекстыОшибок = "", Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	МассивИзмерений = ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(СтруктураПараметров.ИмяМетаданныхВ1С, Кэш);
	Если СтруктураПараметров.ТипОбновления = Перечисления.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьНеСоздавать
		Или СтруктураПараметров.ТипОбновления = Перечисления.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьСоздавать Тогда
		
		ИсключатьДляЗаполнения = СтрСоединить(МассивИзмерений, ",");
		
	КонецЕсли;
	
	СтруктураМетаданных = ПолучитьСтруктуруИмениТипаДанныхОбъекта(СтруктураПараметров.ИмяМетаданныхВ1С, Кэш);
	Для Каждого СтрокаДляЗаписи Из ИсходныеДанные Цикл
		
		НаборЗаписей = СтруктураМетаданных.МенеджерОбъекта.СоздатьНаборЗаписей();
		Для Каждого ИмяИзмерения Из МассивИзмерений Цикл НаборЗаписей.Отбор[ИмяИзмерения].Установить(СтрокаДляЗаписи[ИмяИзмерения]); КонецЦикла;
		
		НаборЗаписей.Прочитать();
		Если НаборЗаписей.Количество() = 0 Тогда
			
			Если СтруктураПараметров.ТипОбновления = Перечисления.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиНеОбновлятьСоздавать
				Или СтруктураПараметров.ТипОбновления = Перечисления.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьСоздавать Тогда
				
				ЗаписьДляРедактирования = НаборЗаписей.Добавить();
				ЗаполнитьЗначенияСвойств(ЗаписьДляРедактирования, СтрокаДляЗаписи);
				
				ЗаписатьОбъект(НаборЗаписей, , ТекстыОшибок, , Кэш);
				
			Иначе
				
				Продолжить;
				
			КонецЕсли;
			
		Иначе
			
			Если СтруктураПараметров.ТипОбновления = Перечисления.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьНеСоздавать
				Или СтруктураПараметров.ТипОбновления = Перечисления.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьСоздавать Тогда
				
				ЗаписьДляРедактирования = НаборЗаписей.Получить(0);
				
			Иначе
				
				Продолжить;
				
			КонецЕсли;
			
			ЗаполнитьЗначенияСвойств(ЗаписьДляРедактирования, СтрокаДляЗаписи, , ИсключатьДляЗаполнения);
			ЗаписатьОбъект(НаборЗаписей, , ТекстыОшибок, , Кэш);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
//  ИсходныеДанные - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.УдалитьДанныеПоОбъекту1СВБазеДанных.ИсходныеДанные
//  ОбъектМетаданныхИлиПолноеИмя - см. ПолучитьТипРеквизитаВ1С.ОбъектМетаданныхИлиПолноеИмя
//  ТекстыОшибок - Строка - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.УдалитьДанныеПоОбъекту1СВБазеДанных.ТекстОшибок
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
Процедура УдалитьДанныеПоОбъекту1СВБазеДанныхЧерез1С(Знач ИсходныеДанные, Знач ОбъектМетаданныхИлиПолноеИмя, ТекстыОшибок = "", Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	
	СтруктураМетаданных = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ОбъектМетаданныхИлиПолноеИмя, Кэш);
	Если СтруктураМетаданных.МенеджерОбъекта = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(ИсходныеДанные);
	Если ЭтоСсылка(СтруктураМетаданных.ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
		
		Если ИсходныеДанные.Количество() = 0 Тогда
			
			ВыборкаПоОбъектам = СтруктураМетаданных.МенеджерОбъекта.Выбрать();
			Пока ВыборкаПоОбъектам.Следующий() Цикл
				
				ЭлементОбъект = ПолучитьОбъектСБлокированием(ВыборкаПоОбъектам.Ссылка, Кэш, ТекстыОшибок);
				Если ЭлементОбъект = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Попытка
					
					ЭлементОбъект.Удалить();
					
				Исключение
					
					Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(),
							"Спец_ОбщегоНазначения.УдалитьДанныеПоОбъекту1СВБазеДанных_Через1С(...)",
							ТекстыОшибок);
					
				КонецПопытки;
				
			КонецЦикла;
			
		Иначе
			
			Для Каждого СтрокаДляУдаления Из ИсходныеДанные Цикл
				
				ЭлементОбъект = ПолучитьОбъектСБлокированием(СтрокаДляУдаления.Ссылка, Кэш, ТекстыОшибок);
				Если ЭлементОбъект = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Попытка
					
					ЭлементОбъект.Удалить();
					
				Исключение
					
					Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(),
							"Спец_ОбщегоНазначения.УдалитьДанныеПоОбъекту1СВБазеДанных_Через1С(...)",
							ТекстыОшибок);
					
				КонецПопытки;
				
			КонецЦикла;
			
		КонецЕсли;
		
	ИначеЕсли ЭтоРегистр(СтруктураМетаданных.ПолноеИмяОбъекта, Кэш, Тип("Строка")) Тогда
		
		Если ИсходныеДанные.Количество() = 0 Тогда
			
			НаборЗаписей = СтруктураМетаданных.МенеджерОбъекта.СоздатьНаборЗаписей();
			ЗаписатьОбъект(НаборЗаписей, , ТекстыОшибок, , Кэш);
			
		Иначе
			
			МассивРеквизитов = ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(СтруктураМетаданных.ПолноеИмяОбъекта, Кэш);
			Для Каждого СтрокаДляУдаления Из ИсходныеДанные Цикл
				
				НаборЗаписей = СтруктураМетаданных.МенеджерОбъекта.СоздатьНаборЗаписей();
				Для Каждого ИмяРеквизита Из МассивРеквизитов Цикл
					
					Если Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(СтрокаДляУдаления, ИмяРеквизита) Тогда
						НаборЗаписей.Отбор[ИмяРеквизита].Установить(СтрокаДляУдаления[ИмяРеквизита]);
					КонецЕсли;
					
				КонецЦикла;
				
				ЗаписатьОбъект(НаборЗаписей, , ТекстыОшибок, , Кэш);
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ЧертовВебКлиент

// Параметры:
//  ЗначениеДляПреобразования - Произвольный
// 
// Возвращаемое значение:
//  Строка
Функция XMLСтрокаПрограммно(Знач ЗначениеДляПреобразования) Экспорт
	
	Попытка Возврат СериализаторXDTO.XMLСтрока(ЗначениеДляПреобразования); Исключение Возврат ""; КонецПопытки;
	
КонецФункции

// Параметры:
//	ТипДляПреобразования - Тип
//  СтрокаXML - Строка
// 
// Возвращаемое значение:
//  Произвольный
Функция XMLЗначениеПрограммно(Знач ТипДляПреобразования, Знач СтрокаXML) Экспорт
	
	Попытка Возврат СериализаторXDTO.XMLЗначение(ТипДляПреобразования, СтрокаXML); Исключение Возврат Неопределено; КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область КонстантыИПараметрыСеанса

// Параметры:
//  ПВХ - ПланВидовХарактеристикСсылка.Спец_Константы
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  СправочникСсылка.Спец_МассивЗначенийКонстант
//
Функция ПолучитьМассовоеЗначениеПоПВХ(Знач ПВХ, Кэш = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(ПВХ) Тогда Возврат Справочники.Спец_МассивЗначенийКонстант.ПустаяСсылка(); КонецЕсли;
	
	Запрос = Новый Запрос();
	Запрос.Текст =
	
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Спец_МассивЗначенийКонстант.Ссылка КАК МассовоеЗначение
	|ИЗ
	|	Справочник.Спец_МассивЗначенийКонстант КАК Спец_МассивЗначенийКонстант
	|ГДЕ
	|	Спец_МассивЗначенийКонстант.Владелец = &Владелец";
	
	Запрос.УстановитьПараметр("Владелец", ПВХ);
	Возврат ПолучитьСтруктуруПервойВыборкиЗапроса(Запрос, "МассовоеЗначение");
	
КонецФункции

// Параметры:
//  ИмяПеременной - Строка
// 
// Возвращаемое значение:
//  Произвольный
Функция ПолучитьЗначениеПеременной(Знач ИмяПеременной) Экспорт
	
	Возврат ПараметрыСеанса.Спец_ОбщиеЗначения.Получить(ИмяПеременной);
	
КонецФункции

// Параметры:
//  ИмяПеременной - Строка
//  ЗначениеДляУстановки - Произвольный
Процедура УстановитьЗначениеПеременной(Знач ИмяПеременной, Знач ЗначениеДляУстановки) Экспорт
	
	СоответствиеТекущее = Новый Соответствие(ПараметрыСеанса.Спец_ОбщиеЗначения);
	СоответствиеТекущее[ИмяПеременной] = ЗначениеДляУстановки;
	
	ПараметрыСеанса.Спец_ОбщиеЗначения = Новый ФиксированноеСоответствие(СоответствиеТекущее);
	
КонецПроцедуры

// Параметры:
//  СоответствиеДляУстановки - Соответствие из КлючИЗначение:
//		* Ключ - Произвольный
//		* Значение - Произвольный
Процедура УстановитьМассивЗначенийПеременных(Знач СоответствиеДляУстановки) Экспорт
	
	СоответствиеТекущее = Новый Соответствие(ПараметрыСеанса.Спец_ОбщиеЗначения);
	Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьОбъект(СоответствиеДляУстановки, СоответствиеТекущее, Истина);
	
	ПараметрыСеанса.Спец_ОбщиеЗначения = Новый ФиксированноеСоответствие(СоответствиеТекущее);
	
КонецПроцедуры

// Параметры:
//  ИменаПараметровСеанса - Неопределено, Массив из Строка -
Процедура УстановитьПараметрыСеанса(Знач ИменаПараметровСеанса) Экспорт
	
	// ++ Спец_БСП.ПодключаемоеОборудование
	// ПодключаемоеОборудование
	//@skip-check unknown-method-property
	МенеджерОборудованияВызовСервера.УстановкаПараметровСеанса(ИменаПараметровСеанса);
	// Конец ПодключаемоеОборудование
	// -- Спец_БСП.ПодключаемоеОборудование
	
	// Если неопределено, то это первая инициализация. Всегда инициализируем текущего пользователя и его стиль.
	Если ИменаПараметровСеанса = Неопределено Тогда
		
		ПараметрыСеанса.Спец_ТекущийПользователь = НайтиСоздатьТекущегоПользователя();
		НужныйСтиль = ЗначениеРеквизитаОбъекта(ПараметрыСеанса.Спец_ТекущийПользователь, "ОсновнойСтиль"); // Строка
		
		#Если Не ВнешнееСоединение Тогда
			
			Если Не ПустаяСтрока(НужныйСтиль) И Метаданные.Стили.Найти(НужныйСтиль) <> Неопределено Тогда
				ГлавныйСтиль = БиблиотекаСтилей[НужныйСтиль];
			КонецЕсли;
			
		#КонецЕсли
		
		Возврат;
		
	КонецЕсли;
	
	Для Каждого ИмяПараметра Из ИменаПараметровСеанса Цикл
		
		Если ИмяПараметра = Метаданные.ПараметрыСеанса.Спец_ОбщиеЗначения.Имя Тогда
			//@skip-check unknown-method-property
			Спец_ОбщегоНазначенияВызовСервера.УстановитьПараметрыСервера();
		ИначеЕсли ИмяПараметра = Метаданные.ПараметрыСеанса.Спец_ТекущаяБаза.Имя Тогда
			//@skip-check unknown-method-property
			Спец_ОбщегоНазначенияВызовСервера.УстановитьТекущуюБазу();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
//  ИмяПараметра - Строка
// 
// Возвращаемое значение:
//  Произвольный
Функция ЗначениеПараметраСеанса(Знач ИмяПараметра) Экспорт
	
	Возврат ?(Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(ПараметрыСеанса, ИмяПараметра),
			ПараметрыСеанса[ИмяПараметра],
			Неопределено);
	
КонецФункции

#КонецОбласти

#Область КрасивыеУведомления

// Возвращаемое значение:
//  Структура:
//		* Период - Дата
//		* ИмяПользователя - Строка
//		* Отправитель - Строка
//		* ТекстСообщения - Строка
//		* ТипУведомления - ПеречислениеСсылка.Спец_ТипыУведомленийПользователя
//		* ДействиеПриНажатииДляОповещения1С - Строка
//
Функция ПолучитьСтруктуруУведомленияДляОтправкиТекущемуПользователю() Экспорт
	
	Запрос = Новый Запрос();
	Запрос.Текст =
	
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	УведомленияДляПользователей.Период КАК Период,
	|	УведомленияДляПользователей.ИмяПользователя КАК ИмяПользователя,
	|	УведомленияДляПользователей.Отправитель КАК Отправитель,
	|	УведомленияДляПользователей.ТекстСообщения КАК ТекстСообщения,
	|	УведомленияДляПользователей.ТипУведомления КАК ТипУведомления,
	|	УведомленияДляПользователей.ДействиеПриНажатииДляОповещения1С КАК ДействиеПриНажатииДляОповещения1С
	|ИЗ
	|	РегистрСведений.Спец_УведомленияДляПользователей КАК УведомленияДляПользователей
	|ГДЕ
	|	УведомленияДляПользователей.ИмяПользователя = &ИмяПользователя
	|
	|УПОРЯДОЧИТЬ ПО
	|	Период";

	Запрос.УстановитьПараметр("ИмяПользователя", Спец_ОбщегоНазначенияКлиентСервер.ТекущийПользователь1С());
	
	СтруктураРезультат = ПолучитьСтруктуруПервойВыборкиЗапроса(Запрос); // см. ПолучитьСтруктуруУведомленияДляОтправкиТекущемуПользователю
	Если ЗначениеЗаполнено(СтруктураРезультат.Период) Тогда // Сразу чистим, независимо от того, успешно ли отправилось уведомление или нет.
		
		НаборЗаписей = РегистрыСведений.Спец_УведомленияДляПользователей.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.Период.Установить(СтруктураРезультат.Период);
		НаборЗаписей.Отбор.ИмяПользователя.Установить(СтруктураРезультат.ИмяПользователя);
		
		ЗаписатьОбъект(НаборЗаписей);
		
	КонецЕсли;
	
	//@skip-check constructor-function-return-section
	Возврат СтруктураРезультат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

//@skip-check dynamic-access-method-not-found
//
// Параметры:
//  ОбъектДляПроверки - см. ЭтоСсылка.ОбъектДляПроверки
//  ТипОбъекта - см. ЭтоСсылка.ТипОбъекта
//  ИмяМенеджера - Строка
//  ИмяФункцииВКэше - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоКакойТоОбъектПоИмениВКэш(Знач ОбъектДляПроверки, Знач ТипОбъекта, Знач ИмяМенеджера, Знач ИмяФункцииВКэше, Кэш)
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	Если ТипОбъекта = Тип("ОбъектМетаданных") Тогда
		
		Если Кэш.КэшПоМетаданным.ЭтоКакойТоОбъектПоИмени[ИмяФункцииВКэше][ОбъектДляПроверки] = Неопределено Тогда Кэш.КэшПоМетаданным.ЭтоКакойТоОбъектПоИмени[ИмяФункцииВКэше][ОбъектДляПроверки] = Метаданные[ИмяМенеджера].Содержит(ОбъектДляПроверки); КонецЕсли;
		Возврат Кэш.КэшПоМетаданным.ЭтоКакойТоОбъектПоИмени[ИмяФункцииВКэше][ОбъектДляПроверки];
		
	Иначе
		
		ТипДляПроверки = ?(ТипОбъекта = Тип("Тип"), ОбъектДляПроверки, ТипОбъекта);
		Если Кэш.КэшПоМетаданным.ЭтоКакойТоОбъектПоИмени[ИмяФункцииВКэше][ТипДляПроверки] = Неопределено Тогда МетаданныеПоТипу = ОбъектМетаданныхПоТипуВКэш(ТипДляПроверки, Кэш); Кэш.КэшПоМетаданным.ЭтоКакойТоОбъектПоИмени[ИмяФункцииВКэше][ТипДляПроверки] = ?(МетаданныеПоТипу = Ложь, Ложь, Метаданные[ИмяМенеджера].Содержит(МетаданныеПоТипу)); КонецЕсли;
		Возврат Кэш.КэшПоМетаданным.ЭтоКакойТоОбъектПоИмени[ИмяФункцииВКэше][ТипДляПроверки];
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  ТипДляПроверки - Тип 
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
Функция ОбъектМетаданныхПоТипуВКэш(Знач ТипДляПроверки, Знач Кэш)
	
	Если Кэш.КэшПоМетаданным.ОбъектМетаданныхПоТипу[ТипДляПроверки] = Неопределено Тогда
		
		Кэш.КэшПоМетаданным.ОбъектМетаданныхПоТипу[ТипДляПроверки] = Метаданные.НайтиПоТипу(ТипДляПроверки);
		Если Кэш.КэшПоМетаданным.ОбъектМетаданныхПоТипу[ТипДляПроверки] = Неопределено Тогда Кэш.КэшПоМетаданным.ОбъектМетаданныхПоТипу[ТипДляПроверки] = Ложь; КонецЕсли;
		
	КонецЕсли;
	
	Возврат Кэш.КэшПоМетаданным.ОбъектМетаданныхПоТипу[ТипДляПроверки];
	
КонецФункции

// Параметры:
//  СсылкаИлиОбъект - Неопределено - 
//  				- см. ЗначенияРеквизитовОбъекта.СсылкаИлиОбъект
//  МассивДляЗапроса - Массив из Строка
//  МассивЧистыхИмен - Неопределено, Массив из Строка - 
//  СтруктураРезультат - см. ЗначенияРеквизитовОбъекта
//  ИмяДляЗапроса - Строка
//  ИмяПсевдонима - Строка
//  ЭтоОбъектныйТип - Булево
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
Процедура ДобавитьПолеДляОбработки(Знач СсылкаИлиОбъект, Знач МассивДляЗапроса, Знач МассивЧистыхИмен, Знач СтруктураРезультат, Знач ИмяДляЗапроса,
		Знач ИмяПсевдонима, Знач ЭтоОбъектныйТип, Знач Кэш)
	
	Если Не ЗначениеЗаполнено(ИмяПсевдонима) Тогда
		ИмяПсевдонима = Спец_СтроковыеФункцииКлиентСервер.ОчиститьИмяДляЗапроса(ИмяДляЗапроса);
	ИначеЕсли Не ЗначениеЗаполнено(ИмяДляЗапроса) Тогда
		ИмяДляЗапроса = ИмяПсевдонима;
	КонецЕсли;
	
	ЕстьТочка = СтрНайти(ИмяДляЗапроса, ".") > 0;
	Если ЭтоОбъектныйТип Тогда
		
		Если Не ЕстьТочка Тогда
			
			Если СтруктураРезультат <> Неопределено Тогда СтруктураРезультат.Вставить(ИмяПсевдонима, СсылкаИлиОбъект[ИмяДляЗапроса]); КонецЕсли;
			Если МассивЧистыхИмен <> Неопределено Тогда МассивЧистыхИмен.Добавить(ИмяПсевдонима); КонецЕсли;
			
		Иначе
			
			МассивРазделенный      = СтрРазделить(ИмяДляЗапроса, ".", Ложь);
			ИмяРеквизитаДляЗапроса = СокрЛП(МассивРазделенный.Получить(0));
			МассивРазделенный.Удалить(0);
			
			//@skip-check invocation-parameter-type-intersect
			Если СтруктураРезультат <> Неопределено Тогда СтруктураРезультат.Вставить(ИмяПсевдонима, ЗначениеРеквизитаОбъекта(СсылкаИлиОбъект[ИмяРеквизитаДляЗапроса], СокрЛП(СтрСоединить(МассивРазделенный, ".")), , Кэш)); КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		
		МассивДляЗапроса.Добавить(СтрШаблон("Таблица.%1 КАК %2", ИмяДляЗапроса, ИмяПсевдонима));
		Если СтруктураРезультат <> Неопределено Тогда СтруктураРезультат.Вставить(ИмяПсевдонима); КонецЕсли;
		Если МассивЧистыхИмен <> Неопределено Тогда МассивЧистыхИмен.Добавить(ИмяПсевдонима); КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры

// Параметры:
//  ИсходнаяТаблица - ТаблицаЗначений
// 
// Возвращаемое значение:
//  ТаблицаЗначений
Функция СкопироватьТаблицуБезNull(Знач ИсходнаяТаблица)
	
	ТаблицаРезультат = Новый ТаблицаЗначений;
	Для Каждого КолонкаТаблицы Из ИсходнаяТаблица.Колонки Цикл ТаблицаРезультат.Колонки.Добавить(КолонкаТаблицы.Имя, Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТиповБезNull(КолонкаТаблицы.ТипЗначения)); КонецЦикла;
	
	Возврат ТаблицаРезультат;
	
КонецФункции

// Возвращаемое значение:
//  Массив из Строка
Функция ТипыОбъектовМетаданныхСсылочногоТипа()
	
	ТипыОбъектовМетаданныхСсылочногоТипа = Новый Массив(); // см. ТипыОбъектовМетаданныхСсылочногоТипа
	
	ТипыОбъектовМетаданныхСсылочногоТипа.Добавить("Справочники");
	ТипыОбъектовМетаданныхСсылочногоТипа.Добавить("Документы");
	ТипыОбъектовМетаданныхСсылочногоТипа.Добавить("БизнесПроцессы");
	ТипыОбъектовМетаданныхСсылочногоТипа.Добавить("Задачи");
	ТипыОбъектовМетаданныхСсылочногоТипа.Добавить("ПланыСчетов");
	ТипыОбъектовМетаданныхСсылочногоТипа.Добавить("ПланыОбмена");
	ТипыОбъектовМетаданныхСсылочногоТипа.Добавить("ПланыВидовХарактеристик");
	ТипыОбъектовМетаданныхСсылочногоТипа.Добавить("ПланыВидовРасчета");
	
	Возврат ТипыОбъектовМетаданныхСсылочногоТипа;
	
КонецФункции

// Параметры:
//  СсылочныеТипы - Массив из Тип
//  ТипОМД - Строка
//  ОМДРасширения - ОбъектМетаданныхКонфигурация
Процедура ДополнитьТипы(Знач СсылочныеТипы, Знач ТипОМД, Знач ОМДРасширения)
	
	ПринадлежностьОбъекта = Метаданные.СвойстваОбъектов.ПринадлежностьОбъекта.Собственный; 
	
	Для Каждого ОМД Из ОМДРасширения[ТипОМД] Цикл // ОбъектМетаданныхКонфигурация
		
		Если ОМД.ПринадлежностьОбъекта <> ПринадлежностьОбъекта Тогда
			Продолжить;
		КонецЕсли;
		
		СсылкаДляОпределенияТипа = ПредопределенноеЗначение(ОМД.ПолноеИмя() + ".ПустаяСсылка");
		СсылочныеТипы.Добавить(ТипЗнч(СсылкаДляОпределенияТипа));
		
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
Процедура УстановитьКонстантыПоУмолчанию_ОбновитьИнформациюПоБазе(Знач Кэш)
	
	Если Не ЗначениеЗаполнено(ПараметрыСеанса.Спец_ТекущаяБаза) Тогда Возврат; КонецЕсли;
	
	СтруктураАдресаИБ = Спец_ОбщегоНазначенияКлиентСервер.СтруктураИмениАдресаТипаБазыДанных();
	
	СправочникБазаОбъект = ПараметрыСеанса.Спец_ТекущаяБаза.ПолучитьОбъект();
	Если Не Спец_СтроковыеФункцииКлиентСервер.ЭтоНеЛокальныйЧисловойIP(СправочникБазаОбъект.АдресСервераИБ, Кэш)
		И Спец_СтроковыеФункцииКлиентСервер.ЭтоНеЛокальныйЧисловойIP(СтруктураАдресаИБ.ИмяСервераИБ, Кэш) Тогда
			
		СправочникБазаОбъект.АдресСервераИБ = СтруктураАдресаИБ.ИмяСервераИБ;
		
	КонецЕсли;
	
	Если Не СтруктураАдресаИБ.ЭтоФайловаяБаза Тогда
		
		Если СправочникБазаОбъект.ПортКластераИБ = 0 Тогда
			СправочникБазаОбъект.ПортКластераИБ = 1545;
		КонецЕсли;
		
		// ++ Спец_БСП.Версия1С_14_ВышеИлиРавно
		#Если Не ВнешнееСоединение Тогда
			
			База = Спец_ОбщегоНазначенияКлиентСервер.ПодключитьсяКБазеВКластере(СтруктураАдресаИБ.ИмяСервераИБ, СправочникБазаОбъект.ПортКластераИБ, СтруктураАдресаИБ.ИмяБазыИБ);
			Если База <> Неопределено Тогда
				
				Если База.СУБД = "MSSQLServer" Тогда
					СправочникБазаОбъект.ТипБазыДанных = Перечисления.Спец_ТипыБазыДанных.MSSQLServer;
				ИначеЕсли База.СУБД = "PostgreSQL" Тогда
					СправочникБазаОбъект.ТипБазыДанных = Перечисления.Спец_ТипыБазыДанных.PostgreSQL;
				ИначеЕсли База.СУБД = "IBMDB2" Тогда
					СправочникБазаОбъект.ТипБазыДанных = Перечисления.Спец_ТипыБазыДанных.IBMDB2;
				ИначеЕсли База.СУБД = "OracleDatabase" Тогда
					СправочникБазаОбъект.ТипБазыДанных = Перечисления.Спец_ТипыБазыДанных.OracleDatabase;
				ИначеЕсли База.СУБД = "MySQL" Тогда
					СправочникБазаОбъект.ТипБазыДанных = Перечисления.Спец_ТипыБазыДанных.MySQL;
				Иначе
					СправочникБазаОбъект.ТипБазыДанных = Перечисления.Спец_ТипыБазыДанных.Неизвестный;
				КонецЕсли;
				
			КонецЕсли;
			
		#КонецЕсли
		// -- Спец_БСП.Версия1С_14_ВышеИлиРавно
		
	Иначе
		
		СправочникБазаОбъект.ПортКластераИБ = 0;
		СправочникБазаОбъект.ТипБазыДанных = Перечисления.Спец_ТипыБазыДанных.Файловая;
		
	КонецЕсли;
	
	ЗаписатьОбъект(СправочникБазаОбъект, , , , Кэш);
	
КонецПроцедуры

// ++ Спец_БСП.Спец_НочнойРасчет
// Возвращаемое значение:
//  ТаблицаЗначений:
//		* ИмяПроцедурыВыполнения - Строка
//		* ИмяМетаданныхРегламента - Строка
Функция ПолучитьТаблицуТекущихНастроекНочногоРасчета()
	
	Запрос = Новый Запрос();
	Запрос.Текст =
	
	"ВЫБРАТЬ
	|	НастройкаНочногоРасчета.ИмяПроцедурыВыполнения КАК ИмяПроцедурыВыполнения,
	|	НастройкаНочногоРасчета.ИмяМетаданныхРегламента КАК ИмяМетаданныхРегламента
	|ИЗ
	|	РегистрСведений.Спец_НастройкиНочногоРасчета КАК НастройкаНочногоРасчета
	|ГДЕ
	|	НЕ НастройкаНочногоРасчета.Ручной";

	ТаблицаРезультат = Запрос.Выполнить().Выгрузить();
	ТаблицаРезультат.Индексы.Добавить("ИмяМетаданныхРегламента");
	
	Возврат ТаблицаРезультат;
	
КонецФункции

// Возвращаемое значение:
//  ТаблицаЗначений:
//		* ИмяПроцедурыВыполнения - Строка
//		* ИмяМетаданныхРегламента - Строка
Функция ПолучитьТаблицуТекущихРучныхНастроекНочногоРасчета()
	
	Запрос = Новый Запрос();
	Запрос.Текст =
	
	"ВЫБРАТЬ
	|	НастройкаНочногоРасчета.*
	|ИЗ
	|	РегистрСведений.Спец_НастройкиНочногоРасчета КАК НастройкаНочногоРасчета
	|ГДЕ
	|	НастройкаНочногоРасчета.Ручной";

	ТаблицаРезультат = Запрос.Выполнить().Выгрузить();
	ТаблицаРезультат.Индексы.Добавить("ИмяПроцедурыВыполнения");
	
	Возврат ТаблицаРезультат;
	
КонецФункции
// -- Спец_БСП.Спец_НочнойРасчет

//@skip-check invocation-parameter-type-intersect
//@skip-check dynamic-access-method-not-found
#Область ПрограммныйПоискПоСсылкам

// Параметры:
//  МассивМетаданныхИлиИменДляПоиска - см. НайтиПоСсылкамПрограммно.МассивОбъектовМетаданныхИлиПолныхИмен
//  МассивМетаданныхИлиИменДляИсключения - см. НайтиПоСсылкамПрограммно.МассивМетаданныхИлиИменДляИсключения
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Массив из ОбъектМетаданных
Функция НайтиПоСсылкамПрограммно_СформироватьМассивМетаданныхДляПоиска(Знач МассивМетаданныхИлиИменДляПоиска, Знач МассивМетаданныхИлиИменДляИсключения, Знач Кэш)
	
	ЧистыйМассивМетаданныхДляПоиска = Новый Массив; // см. НайтиПоСсылкамПрограммно_СформироватьМассивМетаданныхДляПоиска
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивМетаданныхИлиИменДляПоиска);
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивМетаданныхИлиИменДляИсключения);
	
	ДляОбхода = ?(МассивМетаданныхИлиИменДляПоиска.Количество() = 0,
			Спец_ОбщегоНазначенияПовтИсп.ВсеИменаМетаданныхИзБазы(Истина),
			МассивМетаданныхИлиИменДляПоиска);
	
	Если МассивМетаданныхИлиИменДляИсключения.Количество() Тогда
		
		Для Каждого ОбъектМетаданныхИлиСтрока Из ДляОбхода Цикл
			
			
			Если ТипЗнч(ОбъектМетаданныхИлиСтрока) = Тип("Строка") Тогда
				
				СтруктураПоМетаданным = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ОбъектМетаданныхИлиСтрока, Кэш);
				Если МассивМетаданныхИлиИменДляИсключения.Найти(ОбъектМетаданныхИлиСтрока) = Неопределено
					И МассивМетаданныхИлиИменДляИсключения.Найти(СтруктураПоМетаданным.МетаданныеОбъекта) = Неопределено Тогда
					
					ЧистыйМассивМетаданныхДляПоиска.Добавить(СтруктураПоМетаданным.МетаданныеОбъекта);
					
				КонецЕсли;
				
			ИначеЕсли МассивМетаданныхИлиИменДляИсключения.Найти(ОбъектМетаданныхИлиСтрока) = Неопределено
				И МассивМетаданныхИлиИменДляИсключения.Найти(ОбъектМетаданныхИлиСтрока.ПолноеИмя()) = Неопределено Тогда
				
				ЧистыйМассивМетаданныхДляПоиска.Добавить(ОбъектМетаданныхИлиСтрока);
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		Для Каждого ОбъектМетаданныхИлиСтрока Из ДляОбхода Цикл
			
			Если ТипЗнч(ОбъектМетаданныхИлиСтрока) = Тип("Строка") Тогда
				
				СтруктураПоМетаданным = ПолучитьСтруктуруИмениТипаДанныхОбъекта(ОбъектМетаданныхИлиСтрока, Кэш);
				ЧистыйМассивМетаданныхДляПоиска.Добавить(СтруктураПоМетаданным.МетаданныеОбъекта);
				
			Иначе
				
				ЧистыйМассивМетаданныхДляПоиска.Добавить(ОбъектМетаданныхИлиСтрока);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ЧистыйМассивМетаданныхДляПоиска;
	
КонецФункции

// Параметры:
//  МассивОбъектовДляПоиска - см. НайтиПоСсылкамПрограммно.МассивОбъектовДляПоиска
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//		* Ключ - Тип
//		* Значение - см. НоваяСтруктураПараметраДляПоискаПоСсылкам
Функция НайтиПоСсылкамПрограммно_СформироватьСоответствиеПараметровЗапроса(Знач МассивОбъектовДляПоиска, Кэш)
	
	СоответствиеОбъектовПоТипам = Новый Соответствие;
	Для Каждого Объект Из МассивОбъектовДляПоиска Цикл
		
		ТипОбъекта = ТипЗнч(Объект);
		Если СоответствиеОбъектовПоТипам[ТипОбъекта] = Неопределено Тогда СоответствиеОбъектовПоТипам[ТипОбъекта] = Новый Массив; КонецЕсли;
		СоответствиеОбъектовПоТипам[ТипОбъекта].Добавить(Объект);
		
	КонецЦикла;
	
	СоответствиеПараметровЗапроса = Новый Соответствие;
	Для Каждого КлючЗначение Из СоответствиеОбъектовПоТипам Цикл
		
		СтруктураПоМетаданным = ПолучитьСтруктуруИмениТипаДанныхОбъекта(КлючЗначение.Ключ, Кэш);
		НужноПоРавенству      = КлючЗначение.Значение.Количество() = 1;
		СтруктураПараметра    = НоваяСтруктураПараметраДляПоискаПоСсылкам(
				НужноПоРавенству,
				?(НужноПоРавенству, КлючЗначение.Значение.Получить(0), КлючЗначение.Значение),
				"Параметр_" + Спец_СтроковыеФункцииКлиентСервер.ОчиститьИмяДляЗапроса(?(СтруктураПоМетаданным.МетаданныеОбъекта = Неопределено, СокрЛП(КлючЗначение.Ключ), СтруктураПоМетаданным.ПолноеИмяОбъекта)));
		
		СоответствиеПараметровЗапроса[КлючЗначение.Ключ] = СтруктураПараметра;
		
	КонецЦикла;
	
	Возврат СоответствиеПараметровЗапроса;
	
КонецФункции

// Параметры:
//  ОбъектМетаданных - см. ПолучитьСтруктуруИлиТаблицуОбъектаДоЗаписи.ОбъектМетаданных
//  ПолноеИмяОбъекта - Строка
//  СоответствиеПараметровЗапроса - см. НайтиПоСсылкамПрограммно_СформироватьСоответствиеПараметровЗапроса
//  ВозвращатьТолькоДанные - Булево
//  МассивРезультат - Массив из Строка
Процедура НайтиПоСсылкамПрограммно_СформироватьЗапросыДляКонстанты(Знач ОбъектМетаданных, Знач ПолноеИмяОбъекта, Знач СоответствиеПараметровЗапроса,
		Знач ВозвращатьТолькоДанные, Знач МассивРезультат)
	
	Для Каждого КлючЗначение Из СоответствиеПараметровЗапроса Цикл
		
		Если Не ОбъектМетаданных.Тип.СодержитТип(КлючЗначение.Ключ) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ВозвращатьТолькоДанные Тогда
			
			Если КлючЗначение.Значение.НужноРавенство Тогда
				
				МассивРезультат.Добавить(СтрШаблон(
						
						"ВЫБРАТЬ ПЕРВЫЕ 1
						|	""%1"" КАК Данные
						|ИЗ
						|	%1 КАК ТаблицаКонстанта
						|ГДЕ
						|	ТаблицаКонстанта.Значение = &%2",
						
						ПолноеИмяОбъекта,
						КлючЗначение.Значение.ИмяПараметра));
				
			Иначе
				
				МассивРезультат.Добавить(СтрШаблон(
						
						"ВЫБРАТЬ
						|	""%1"" КАК Данные
						|ИЗ
						|	%1 КАК ТаблицаКонстанта
						|ГДЕ
						|	ТаблицаКонстанта.Значение В (&%2)",
						
						ПолноеИмяОбъекта,
						КлючЗначение.Значение.ИмяПараметра));
				
			КонецЕсли;
			
		ИначеЕсли КлючЗначение.Значение.НужноРавенство Тогда
			
			МассивРезультат.Добавить(СтрШаблон(
					
					"ВЫБРАТЬ ПЕРВЫЕ 1
					|	ТаблицаКонстанта.Значение КАК ИсходныйОбъект,
					|	""%1"" КАК ПолноеИмяМетаданных,
					|	НЕОПРЕДЕЛЕНО КАК Данные
					|ИЗ
					|	%1 КАК ТаблицаКонстанта
					|ГДЕ
					|	ТаблицаКонстанта.Значение = &%2",
					
					ПолноеИмяОбъекта,
					КлючЗначение.Значение.ИмяПараметра));
			
		Иначе
			
			МассивРезультат.Добавить(СтрШаблон(
					
					"ВЫБРАТЬ
					|	ТаблицаКонстанта.Значение КАК ИсходныйОбъект,
					|	""%1"" КАК ПолноеИмяМетаданных,
					|	НЕОПРЕДЕЛЕНО КАК Данные
					|ИЗ
					|	%1 КАК ТаблицаКонстанта
					|ГДЕ
					|	ТаблицаКонстанта.Значение В (&%2)",
					
					ПолноеИмяОбъекта,
					КлючЗначение.Значение.ИмяПараметра));
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных
//  ПолноеИмяОбъекта - Строка
//  СоответствиеПараметровЗапроса - см. НайтиПоСсылкамПрограммно_СформироватьСоответствиеПараметровЗапроса
//  ТекстЗапросаОграничение - Строка
//  ВозвращатьТолькоДанные - Булево
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  МассивРезультат - Массив из Строка
Процедура НайтиПоСсылкамПрограммно_СформироватьЗапросыДляСсылочногоТипа(Знач ОбъектМетаданных, Знач ПолноеИмяОбъекта, Знач СоответствиеПараметровЗапроса,
		Знач ТекстЗапросаОграничение, Знач ВозвращатьТолькоДанные, Кэш, МассивРезультат)
	
	СтруктураРеквизитов = ПолучитьСтруктуруВсехРеквизитовОбъекта(ОбъектМетаданных, Ложь, Кэш);
	Для Каждого МетаданныеРеквизит Из СтруктураРеквизитов.МассивРеквизитов Цикл
		
		Если МетаданныеРеквизит.Имя = "Ссылка" Или МетаданныеРеквизит.Имя = "ИмяПредопределенныхДанных" Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого КлючЗначение Из СоответствиеПараметровЗапроса Цикл
			
			Если Не МетаданныеРеквизит.Тип.СодержитТип(КлючЗначение.Ключ)
				Или НайтиПоСсылкамПрограммно_ЭтоНеПодходящийРеквизитДляЗапроса(КлючЗначение.Ключ, МетаданныеРеквизит) Тогда
				
				Продолжить;
				
			КонецЕсли;
			
			Если ВозвращатьТолькоДанные Тогда
				
				Если КлючЗначение.Значение.НужноРавенство Тогда
					
					МассивРезультат.Добавить(СтрШаблон(
							
							"ВЫБРАТЬ %3
							|	Спец_ТаблицаОбъекта.Ссылка КАК Данные
							|ИЗ
							|	%1 КАК Спец_ТаблицаОбъекта
							|ГДЕ
							|	Спец_ТаблицаОбъекта.%2 = &%4",
							
							ПолноеИмяОбъекта,
							МетаданныеРеквизит.Имя,
							ТекстЗапросаОграничение,
							КлючЗначение.Значение.ИмяПараметра));
					
				Иначе
					
					МассивРезультат.Добавить(СтрШаблон(
							
							"ВЫБРАТЬ %3
							|	Спец_ТаблицаОбъекта.Ссылка КАК Данные
							|ИЗ
							|	%1 КАК Спец_ТаблицаОбъекта
							|ГДЕ
							|	Спец_ТаблицаОбъекта.%2 В (&%4)",
							
							ПолноеИмяОбъекта,
							МетаданныеРеквизит.Имя,
							ТекстЗапросаОграничение,
							КлючЗначение.Значение.ИмяПараметра));
					
				КонецЕсли;
				
			ИначеЕсли КлючЗначение.Значение.НужноРавенство Тогда
				
				МассивРезультат.Добавить(СтрШаблон(
						
						"ВЫБРАТЬ %3
						|	Спец_ТаблицаОбъекта.%2 КАК ИсходныйОбъект,
						|	""%1"" КАК ПолноеИмяМетаданных,
						|	Спец_ТаблицаОбъекта.Ссылка КАК Данные
						|ИЗ
						|	%1 КАК Спец_ТаблицаОбъекта
						|ГДЕ
						|	Спец_ТаблицаОбъекта.%2 = &%4",
						
						ПолноеИмяОбъекта,
						МетаданныеРеквизит.Имя,
						ТекстЗапросаОграничение,
						КлючЗначение.Значение.ИмяПараметра));
				
			Иначе
				
				МассивРезультат.Добавить(СтрШаблон(
						
						"ВЫБРАТЬ %3
						|	Спец_ТаблицаОбъекта.%2 КАК ИсходныйОбъект,
						|	""%1"" КАК ПолноеИмяМетаданных,
						|	Спец_ТаблицаОбъекта.Ссылка КАК Данные
						|ИЗ
						|	%1 КАК Спец_ТаблицаОбъекта
						|ГДЕ
						|	Спец_ТаблицаОбъекта.%2 В (&%4)",
						
						ПолноеИмяОбъекта,
						МетаданныеРеквизит.Имя,
						ТекстЗапросаОграничение,
						КлючЗначение.Значение.ИмяПараметра));
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Если Не СтруктураРеквизитов.Свойство("ТабличныеЧасти") Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого КлючЗначениеТабличнаяЧасть Из СтруктураРеквизитов.ТабличныеЧасти Цикл
		
		Для Каждого МетаданныеРеквизит Из КлючЗначениеТабличнаяЧасть.Значение Цикл
			
			Если МетаданныеРеквизит.Имя = "Ссылка" Или МетаданныеРеквизит.Имя = "НомерСтроки" Тогда
				Продолжить;
			КонецЕсли;
			
			Для Каждого КлючЗначение Из СоответствиеПараметровЗапроса Цикл
				
				Если Не МетаданныеРеквизит.Тип.СодержитТип(КлючЗначение.Ключ)
					Или НайтиПоСсылкамПрограммно_ЭтоНеПодходящийРеквизитДляЗапроса(КлючЗначение.Ключ, МетаданныеРеквизит) Тогда
					
					Продолжить;
					
				КонецЕсли;
				
				Если ВозвращатьТолькоДанные Тогда
					
					Если КлючЗначение.Значение.НужноРавенство Тогда
						
						МассивРезультат.Добавить(СтрШаблон(
								
								"ВЫБРАТЬ %3
								|	Спец_ТаблицаОбъекта.Ссылка КАК Данные
								|ИЗ
								|	%1.%5 КАК Спец_ТаблицаОбъекта
								|ГДЕ
								|	Спец_ТаблицаОбъекта.%2 = &%4",
								
								ПолноеИмяОбъекта,
								МетаданныеРеквизит.Имя,
								ТекстЗапросаОграничение,
								КлючЗначение.Значение.ИмяПараметра,
								КлючЗначениеТабличнаяЧасть.Ключ));
								
					Иначе
						
						МассивРезультат.Добавить(СтрШаблон(
								
								"ВЫБРАТЬ %3
								|	Спец_ТаблицаОбъекта.Ссылка КАК Данные
								|ИЗ
								|	%1.%5 КАК Спец_ТаблицаОбъекта
								|ГДЕ
								|	Спец_ТаблицаОбъекта.%2 В (&%4)",
								
								ПолноеИмяОбъекта,
								МетаданныеРеквизит.Имя,
								ТекстЗапросаОграничение,
								КлючЗначение.Значение.ИмяПараметра,
								КлючЗначениеТабличнаяЧасть.Ключ));
						
					КонецЕсли;
					
				ИначеЕсли КлючЗначение.Значение.НужноРавенство Тогда
					
					МассивРезультат.Добавить(СтрШаблон(
							
							"ВЫБРАТЬ %3
							|	Спец_ТаблицаОбъекта.%2 КАК ИсходныйОбъект,
							|	""%1"" КАК ПолноеИмяМетаданных,
							|	Спец_ТаблицаОбъекта.Ссылка КАК Данные
							|ИЗ
							|	%1.%5 КАК Спец_ТаблицаОбъекта
							|ГДЕ
							|	Спец_ТаблицаОбъекта.%2 = &%4",
							
							ПолноеИмяОбъекта,
							МетаданныеРеквизит.Имя,
							ТекстЗапросаОграничение,
							КлючЗначение.Значение.ИмяПараметра,
							КлючЗначениеТабличнаяЧасть.Ключ));
					
				Иначе
					
					МассивРезультат.Добавить(СтрШаблон(
							
							"ВЫБРАТЬ %3
							|	Спец_ТаблицаОбъекта.%2 КАК ИсходныйОбъект,
							|	""%1"" КАК ПолноеИмяМетаданных,
							|	Спец_ТаблицаОбъекта.Ссылка КАК Данные
							|ИЗ
							|	%1.%5 КАК Спец_ТаблицаОбъекта
							|ГДЕ
							|	Спец_ТаблицаОбъекта.%2 В (&%4)",
							
							ПолноеИмяОбъекта,
							МетаданныеРеквизит.Имя,
							ТекстЗапросаОграничение,
							КлючЗначение.Значение.ИмяПараметра,
							КлючЗначениеТабличнаяЧасть.Ключ));
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных
//  ПолноеИмяОбъекта - Строка
//  СоответствиеПараметровЗапроса - см. НайтиПоСсылкамПрограммно_СформироватьСоответствиеПараметровЗапроса
//  ТекстЗапросаОграничение - Строка
//  ВозвращатьТолькоДанные - Булево
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  МассивРезультат - Массив из Строка
Процедура НайтиПоСсылкамПрограммно_СформироватьЗапросыДляРегистра(Знач ОбъектМетаданных, Знач ПолноеИмяОбъекта, Знач СоответствиеПараметровЗапроса,
		Знач ТекстЗапросаОграничение, Знач ВозвращатьТолькоДанные, Знач Кэш, Знач МассивРезультат)
	
	СтруктураРеквизитов = ПолучитьСтруктуруВсехРеквизитовОбъекта(ОбъектМетаданных, Ложь, Кэш);
	
	МассивИзмеренийДляЗапроса = Новый Массив; // Массив из Строка
	Для Каждого КлючевоеИзмерение Из ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(ОбъектМетаданных, Кэш) Цикл
		МассивИзмеренийДляЗапроса.Добавить(СтрШаблон("Спец_ТаблицаОбъекта.%1 КАК %1", КлючевоеИзмерение));
	КонецЦикла;
	Если МассивИзмеренийДляЗапроса.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ТекстИзмеренийДляЗапроса = СтрСоединить(МассивИзмеренийДляЗапроса, "," + Символы.ПС + Символы.Таб);
	
	МассивГотовыйЗапрос = Новый Массив; // Массив из Строка
	Для Каждого МетаданныеРеквизит Из СтруктураРеквизитов.МассивРеквизитов Цикл
		
		Для Каждого КлючЗначение Из СоответствиеПараметровЗапроса Цикл
			
			Если Не МетаданныеРеквизит.Тип.СодержитТип(КлючЗначение.Ключ)
				Или НайтиПоСсылкамПрограммно_ЭтоНеПодходящийРеквизитДляЗапроса(КлючЗначение.Ключ, МетаданныеРеквизит) Тогда
				
				Продолжить;
				
			КонецЕсли;
			
			Если ВозвращатьТолькоДанные Тогда
				
				Если КлючЗначение.Значение.НужноРавенство Тогда
					
					МассивГотовыйЗапрос.Добавить(СтрШаблон(
							
							"ВЫБРАТЬ %3
							|	""%1"" КАК ПолноеИмяМетаданных,
							|	%5
							|ИЗ
							|	%1 КАК Спец_ТаблицаОбъекта
							|ГДЕ
							|	Спец_ТаблицаОбъекта.%2 = &%4",
							
							ПолноеИмяОбъекта,
							МетаданныеРеквизит.Имя,
							ТекстЗапросаОграничение,
							КлючЗначение.Значение.ИмяПараметра,
							ТекстИзмеренийДляЗапроса));
					
				Иначе
					
					МассивГотовыйЗапрос.Добавить(СтрШаблон(
							
							"ВЫБРАТЬ %3
							|	""%1"" КАК ПолноеИмяМетаданных,
							|	%5
							|ИЗ
							|	%1 КАК Спец_ТаблицаОбъекта
							|ГДЕ
							|	Спец_ТаблицаОбъекта.%2 В (&%4)",
							
							ПолноеИмяОбъекта,
							МетаданныеРеквизит.Имя,
							ТекстЗапросаОграничение,
							КлючЗначение.Значение.ИмяПараметра,
							ТекстИзмеренийДляЗапроса));
					
				КонецЕсли;
				
			ИначеЕсли КлючЗначение.Значение.НужноРавенство Тогда
				
				МассивГотовыйЗапрос.Добавить(СтрШаблон(
						
						"ВЫБРАТЬ %3
						|	Спец_ТаблицаОбъекта.%2 КАК ИсходныйОбъект,
						|	""%1"" КАК ПолноеИмяМетаданных,
						|	%5
						|ИЗ
						|	%1 КАК Спец_ТаблицаОбъекта
						|ГДЕ
						|	Спец_ТаблицаОбъекта.%2 = &%4",
						
						ПолноеИмяОбъекта,
						МетаданныеРеквизит.Имя,
						ТекстЗапросаОграничение,
						КлючЗначение.Значение.ИмяПараметра,
						ТекстИзмеренийДляЗапроса));
				
			Иначе
				
				МассивГотовыйЗапрос.Добавить(СтрШаблон(
						
						"ВЫБРАТЬ %3
						|	Спец_ТаблицаОбъекта.%2 КАК ИсходныйОбъект,
						|	""%1"" КАК ПолноеИмяМетаданных,
						|	%5
						|ИЗ
						|	%1 КАК Спец_ТаблицаОбъекта
						|ГДЕ
						|	Спец_ТаблицаОбъекта.%2 В (&%4)",
						
						ПолноеИмяОбъекта,
						МетаданныеРеквизит.Имя,
						ТекстЗапросаОграничение,
						КлючЗначение.Значение.ИмяПараметра,
						ТекстИзмеренийДляЗапроса));
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	КоличествоЗапросов = МассивГотовыйЗапрос.Количество();
	Если КоличествоЗапросов = 1 Тогда
		
		МассивРезультат.Добавить(МассивГотовыйЗапрос.Получить(0));
		
	ИначеЕсли КоличествоЗапросов > 1 Тогда
		
		Если ВозвращатьТолькоДанные Тогда
			
			МассивРезультат.Добавить(СтрШаблон(
					
					"ВЫБРАТЬ РАЗЛИЧНЫЕ %2
					|	Спец_ТаблицаОбъекта.ПолноеИмяМетаданных КАК ПолноеИмяМетаданных,
					|	%3
					|ИЗ
					|	(%1) КАК Спец_ТаблицаОбъекта",
					
					Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(СтрСоединить(МассивГотовыйЗапрос, Спец_КонстантыКлиентСервер.РазделительОбъединяющихЗапросов())),
					ТекстЗапросаОграничение,
					ТекстИзмеренийДляЗапроса));
			
		Иначе
			
			МассивРезультат.Добавить(СтрШаблон(
					
					"ВЫБРАТЬ РАЗЛИЧНЫЕ %2
					|	Спец_ТаблицаОбъекта.ИсходныйОбъект КАК ИсходныйОбъект,
					|	Спец_ТаблицаОбъекта.ПолноеИмяМетаданных КАК ПолноеИмяМетаданных,
					|	%3
					|ИЗ
					|	(%1) КАК Спец_ТаблицаОбъекта",
					
					Спец_СтроковыеФункцииКлиентСервер.СместитьВесьТекстНаРазделитель(СтрСоединить(МассивГотовыйЗапрос, Спец_КонстантыКлиентСервер.РазделительОбъединяющихЗапросов())),
					ТекстЗапросаОграничение,
					ТекстИзмеренийДляЗапроса));
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  ТипДляПроверки - Тип
//  МетаданныеРеквизит - ОбъектМетаданных
// 
// Возвращаемое значение:
//  Булево
Функция НайтиПоСсылкамПрограммно_ЭтоНеПодходящийРеквизитДляЗапроса(Знач ТипДляПроверки, Знач МетаданныеРеквизит)
	
	Возврат ТипДляПроверки = Тип("Строка") И МетаданныеРеквизит.Тип.СодержитТип(ТипДляПроверки) И МетаданныеРеквизит.Тип.КвалификаторыСтроки.Длина = 0;
	
КонецФункции

#КонецОбласти

//@skip-check property-return-type
//@skip-check invocation-parameter-type-intersect
//@skip-check variable-value-type
//@skip-check statement-type-change
#Область КонстантыИПараметрыСеанса

// Параметры:
//  ПВХ - ПланВидовХарактеристикСсылка.Спец_Константы
//  ЗначениеПоУмолчанию - см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//  НаДату - Дата
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//
Функция ПолучитьКонстантуСпецПоПВХ(Знач ПВХ, Знач ЗначениеПоУмолчанию, Знач НаДату, Знач Кэш)
	
	Если Не ЗначениеЗаполнено(ПВХ) Тогда Возврат ЗначениеПоУмолчанию; КонецЕсли;
	НаДату = ?(НаДату = Неопределено, ТекущаяДатаСеанса(), НаДату);
	
	Запрос = Новый Запрос;
	
	// ++ Спец_БСП.Версия1С_22_ВышеИлиРавно
	Запрос.Текст =
	
	"ВЫБРАТЬ
	|	ХранимыеЗначенияКонстант.ЗначениеКонстанты
	|ИЗ
	|	РегистрСведений.Спец_ХранимыеЗначенияКонстант.СрезПоследних(&НаДату, Константа = &ПВХ) КАК ХранимыеЗначенияКонстант";
	// -- Спец_БСП.Версия1С_22_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_22_Ниже
////	Запрос.Текст =
////	
////	"ВЫБРАТЬ ПЕРВЫЕ 1
////	|	ХранимыеЗначенияКонстант.ЗначениеКонстанты КАК ЗначениеКонстанты
////	|ИЗ
////	|	РегистрСведений.Спец_ХранимыеЗначенияКонстант КАК ХранимыеЗначенияКонстант
////	|ГДЕ
////	|	ХранимыеЗначенияКонстант.Константа = &ПВХ
////	|	И ХранимыеЗначенияКонстант.Период <= &НаДату
////	|
////	|УПОРЯДОЧИТЬ ПО
////	|	ХранимыеЗначенияКонстант.Период УБЫВ";
	// -- Спец_БСП.Версия1С_22_Ниже
	
	Запрос.УстановитьПараметр("НаДату", НаДату);
	Запрос.УстановитьПараметр("ПВХ", ПВХ);
	
	ВыборкаРезультат = Запрос.Выполнить().Выбрать();
	Возврат ?(ВыборкаРезультат.Следующий(),
			ПолучитьКонстантуСпецОбработатьЗначениеРезультат(ВыборкаРезультат.ЗначениеКонстанты, Кэш),
			ПолучитьКонстантуСпецЗаписатьЗначениеПоПВХ(ПВХ, ЗначениеПоУмолчанию, НаДату, ТипЗнч(ЗначениеПоУмолчанию), Кэш));
	
КонецФункции

// Параметры:
//  Код - Строка
//  ЗначениеПоУмолчанию - см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//  НаДату - Дата
//  ВернутьПВХ - Булево
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//
Функция ПолучитьКонстантуСпецПоКоду(Знач Код, Знач ЗначениеПоУмолчанию, Знач НаДату, Знач ВернутьПВХ, Знач Кэш)
	
	Если ПустаяСтрока(Код) Тогда Возврат ЗначениеПоУмолчанию; КонецЕсли;
	
	НормальныйКод = СтрЗаменить(Код, "\", "/");
	МассивКодов   = СтрРазделить(НормальныйКод, "/", Ложь);
	ВГраница      = МассивКодов.ВГраница();
	НаДату        = ?(НаДату = Неопределено, ТекущаяДатаСеанса(), НаДату);
	
	Возврат ?(ВГраница = 0,
			ПолучитьКонстантуСпецПоКодуБезРодителей(НормальныйКод, ЗначениеПоУмолчанию, НаДату, ВернутьПВХ, Кэш),
			ПолучитьКонстантуСпецПоКодуСРодителями(МассивКодов, ВГраница, ЗначениеПоУмолчанию, НаДату, ВернутьПВХ, Кэш));
	
КонецФункции

// Параметры:
//  Код - Строка
//  ЗначениеПоУмолчанию - см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//  НаДату - Дата
//  ВернутьПВХ - Булево
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//
Функция ПолучитьКонстантуСпецПоКодуБезРодителей(Знач Код, Знач ЗначениеПоУмолчанию, Знач НаДату, Знач ВернутьПВХ, Знач Кэш)
	
	Запрос = Новый Запрос();
	
	// ++ Спец_БСП.Версия1С_22_ВышеИлиРавно
	Запрос.Текст =
	
	"ВЫБРАТЬ
	|	ХранимыеЗначенияКонстант.Константа КАК Константа,
	|	ХранимыеЗначенияКонстант.ЗначениеКонстанты КАК ЗначениеКонстанты
	|ИЗ
	|	РегистрСведений.Спец_ХранимыеЗначенияКонстант.СрезПоследних(&НаДату, Константа В
	|		(ВЫБРАТЬ ПЕРВЫЕ 1
	|			Константы.Ссылка
	|		ИЗ
	|			ПланВидовХарактеристик.Спец_Константы КАК Константы
	|		ГДЕ
	|			Константы.Наименование = &Код
	|			И НЕ Константы.ПометкаУдаления)) КАК ХранимыеЗначенияКонстант";
	
	// -- Спец_БСП.Версия1С_22_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_22_Ниже
////	Запрос.Текст =
////
////	"ВЫБРАТЬ ПЕРВЫЕ 1
////	|	НужнаяКонстанта.Константа КАК Константа,
////	|	ХранимыеЗначенияКонстант.ЗначениеКонстанты КАК ЗначениеКонстанты
////	|ИЗ
////	|	(ВЫБРАТЬ ПЕРВЫЕ 1
////	|		Константы.Ссылка КАК Константа
////	|	ИЗ
////	|		ПланВидовХарактеристик.Спец_Константы КАК Константы
////	|	ГДЕ
////	|		Константы.Наименование = &Код
////	|		И НЕ Константы.ПометкаУдаления) КАК НужнаяКонстанта
////	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.Спец_ХранимыеЗначенияКонстант КАК ХранимыеЗначенияКонстант
////	|		ПО НужнаяКонстанта.Константа = ХранимыеЗначенияКонстант.Константа
////	|ГДЕ
////	|	ЕСТЬNULL(ХранимыеЗначенияКонстант.Период, ДАТАВРЕМЯ(2000, 1, 1)) <= &НаДату
////	|
////	|УПОРЯДОЧИТЬ ПО
////	|	ЕСТЬNULL(ХранимыеЗначенияКонстант.Период, ДАТАВРЕМЯ(2000, 1, 1)) УБЫВ";
	// -- Спец_БСП.Версия1С_22_Ниже
	
	Запрос.УстановитьПараметр("Код", Код);
	Запрос.УстановитьПараметр("НаДату", НаДату);
	
	ВыборкаРезультат = Запрос.Выполнить().Выбрать();
	Если ВыборкаРезультат.Следующий() Тогда
		
		Возврат ?(ВернутьПВХ,
				ВыборкаРезультат.Константа,
				ПолучитьКонстантуСпецОбработатьЗначениеРезультат(ВыборкаРезультат.ЗначениеКонстанты, Кэш));
		
	Иначе
		
		ТипЗначенияПоУмолчанию = ТипЗнч(ЗначениеПоУмолчанию);
		
		ПВХ = ПолучитьКонстантуСпецПерезаписатьЭлементПВХ(Неопределено, Код, ТипЗначенияПоУмолчанию, Неопределено, Кэш);
		Возврат ?(ВернутьПВХ,
				ПВХ,
				ПолучитьКонстантуСпецЗаписатьЗначениеПоПВХ(ПВХ, ЗначениеПоУмолчанию, НаДату, ТипЗначенияПоУмолчанию, Кэш));
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  МассивКодов - Массив из Строка
//  ВГраница - Число
//  ЗначениеПоУмолчанию - см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//  НаДату - Дата
//  ВернутьПВХ - Булево
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//
Функция ПолучитьКонстантуСпецПоКодуСРодителями(Знач МассивКодов, Знач ВГраница, Знач ЗначениеПоУмолчанию, Знач НаДату, Знач ВернутьПВХ, Знач Кэш)
	
	КоличествоРодителей = ВГраница - 1;
	
	// ++ Спец_БСП.Версия1С_22_ВышеИлиРавно
	ШаблонТекстаЗапроса =

	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	%1,
	|	ХранимыеЗначенияКонстант.ЗначениеКонстанты КАК ЗначениеКонстанты,
	|	ХранимыеЗначенияКонстант.ЗначениеКонстанты ЕСТЬ NULL КАК ЗначениеОтсутствует
	|ИЗ
	|	(ВЫБРАТЬ
	|		%2
	|	ИЗ
	|		ПланВидовХарактеристик.Спец_Константы КАК КонстантыРодитель0
	|			%3
	|	ГДЕ
	|		КонстантыРодитель0.Наименование = &Родитель0Код
	|		И КонстантыРодитель0.ЭтоГруппа) КАК ДанныеПоКонстантам
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.Спец_ХранимыеЗначенияКонстант.СрезПоследних(&НаДату, ) КАК ХранимыеЗначенияКонстант
	|		ПО ДанныеПоКонстантам.Константа = ХранимыеЗначенияКонстант.Константа";
	// -- Спец_БСП.Версия1С_22_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_22_Ниже
////	ШаблонТекстаЗапроса =
////
////	"ВЫБРАТЬ ПЕРВЫЕ 1
////	|	%1,
////	|	ХранимыеЗначенияКонстант.ЗначениеКонстанты КАК ЗначениеКонстанты,
////	|	ХранимыеЗначенияКонстант.ЗначениеКонстанты ЕСТЬ NULL КАК ЗначениеОтсутствует
////	|ИЗ
////	|	(ВЫБРАТЬ
////	|		%2
////	|	ИЗ
////	|		ПланВидовХарактеристик.Спец_Константы КАК КонстантыРодитель0
////	|			%3
////	|	ГДЕ
////	|		КонстантыРодитель0.Наименование = &Родитель0Код
////	|		И КонстантыРодитель0.ЭтоГруппа) КАК ДанныеПоКонстантам
////	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.Спец_ХранимыеЗначенияКонстант КАК ХранимыеЗначенияКонстант
////	|		ПО ДанныеПоКонстантам.Константа = ХранимыеЗначенияКонстант.Константа
////	|ГДЕ
////	|	ЕСТЬNULL(ХранимыеЗначенияКонстант.Период, ДАТАВРЕМЯ(2000, 1, 1)) <= &НаДату
////	|
////	|УПОРЯДОЧИТЬ ПО
////	|	ЕСТЬNULL(ХранимыеЗначенияКонстант.Период, ДАТАВРЕМЯ(2000, 1, 1)) УБЫВ";
	// -- Спец_БСП.Версия1С_22_Ниже
	
	МассивТекстСоединения             = Новый Массив(); // Массив из Строка
	МассивИменПолейИсходные           = Новый Массив(); // Массив из Строка
	МассивИменПолейДанныеПоКонстантам = Новый Массив(); // Массив из Строка
	
	МассивИменПолейИсходные.Добавить("КонстантыРодитель0.Ссылка КАК Родитель0");
	МассивИменПолейДанныеПоКонстантам.Добавить("ДанныеПоКонстантам.Родитель0");
	
	Для i = 1 По КоличествоРодителей Цикл
		
		ФорматЧисла = Формат(i, "ЧН=0; ЧГ=");
		
		МассивТекстСоединения.Добавить("ЛЕВОЕ СОЕДИНЕНИЕ ПланВидовХарактеристик.Спец_Константы КАК КонстантыРодитель" + ФорматЧисла);
		МассивИменПолейИсходные.Добавить(СтрШаблон("ЕСТЬNULL(КонстантыРодитель%1.Ссылка, ЗНАЧЕНИЕ(ПланВидовХарактеристик.Спец_Константы.ПустаяСсылка)) КАК Родитель%1", ФорматЧисла));
		МассивИменПолейДанныеПоКонстантам.Добавить(СтрШаблон("ДанныеПоКонстантам.Родитель%1 КАК Родитель%1", ФорматЧисла));
		
	КонецЦикла;
	
	МассивИменПолейИсходные.Добавить("ЕСТЬNULL(КонстантыЗначение.Ссылка, ЗНАЧЕНИЕ(ПланВидовХарактеристик.Спец_Константы.ПустаяСсылка)) КАК Константа");
	МассивИменПолейДанныеПоКонстантам.Добавить("ДанныеПоКонстантам.Константа КАК Константа");
	
	МассивТекстСоединения.Добавить(СтрШаблон("ЛЕВОЕ СОЕДИНЕНИЕ ПланВидовХарактеристик.Спец_Константы КАК КонстантыЗначение
			|	ПО КонстантыРодитель%1.Ссылка = КонстантыЗначение.Родитель
			|		И КонстантыЗначение.Наименование = &КодКонстанты
			|		И НЕ КонстантыЗначение.ЭтоГруппа", Формат(КоличествоРодителей, "ЧН=0; ЧГ=")));
	
	Для i = 0 По КоличествоРодителей - 1 Цикл
		
		МассивТекстСоединения.Добавить(СтрШаблон("	ПО КонстантыРодитель%1.Ссылка = КонстантыРодитель%2.Родитель
				|		И (КонстантыРодитель%2.Наименование = &Родитель%2Код)
				|		И (КонстантыРодитель%2.ЭтоГруппа)",
				Формат(КоличествоРодителей - 1 - i, "ЧН=0; ЧГ="),
				Формат(КоличествоРодителей - i, "ЧН=0; ЧГ=")));
		
	КонецЦикла;
	
	Запрос = Новый Запрос();
	Запрос.Текст = СтрШаблон(ШаблонТекстаЗапроса,
			СтрСоединить(МассивИменПолейДанныеПоКонстантам, ","),
			СтрСоединить(МассивИменПолейИсходные, ","),
			СтрСоединить(МассивТекстСоединения, " "));
	
	Для i = 0 По КоличествоРодителей Цикл
		Запрос.УстановитьПараметр(СтрШаблон("Родитель%1Код", Формат(i, "ЧН=0; ЧГ=")), МассивКодов.Получить(i));
	КонецЦикла;
	
	Запрос.УстановитьПараметр("НаДату", НаДату);
	Запрос.УстановитьПараметр("КодКонстанты", МассивКодов.Получить(ВГраница));
	
	ВыборкаРезультат = Запрос.Выполнить().Выбрать();
	Если ВыборкаРезультат.Следующий() Тогда
		
		ВсеРодителиЕсть = Истина;
		ИндексНачальногоРодителя = 0;
		
		Для i = 1 По КоличествоРодителей Цикл
			
			Если Не ЗначениеЗаполнено(ВыборкаРезультат["Родитель" + Формат(i, "ЧН=0; ЧГ=")]) Тогда
				
				ВсеРодителиЕсть = Ложь;
				ИндексНачальногоРодителя = i;
				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ВсеРодителиЕсть Тогда
			
			Если ЗначениеЗаполнено(ВыборкаРезультат.Константа) Тогда
				
				Если ВернутьПВХ Тогда
					Возврат ВыборкаРезультат.Константа;
				ИначеЕсли ВыборкаРезультат.ЗначениеОтсутствует Тогда
					Возврат ПолучитьКонстантуСпецЗаписатьЗначениеПоПВХ(ВыборкаРезультат.Константа, ЗначениеПоУмолчанию, НаДату, ТипЗнч(ЗначениеПоУмолчанию), Кэш);
				Иначе
					Возврат ПолучитьКонстантуСпецОбработатьЗначениеРезультат(ВыборкаРезультат.ЗначениеКонстанты, Кэш);
				КонецЕсли;
				
			Иначе
				
				Родитель = ВыборкаРезультат["Родитель" + Формат(КоличествоРодителей, "ЧН=0; ЧГ=")];
				ТипЗначенияПоУмолчанию = ТипЗнч(ЗначениеПоУмолчанию);
				
				ПВХ = ПолучитьКонстантуСпецПерезаписатьЭлементПВХ(Неопределено, МассивКодов.Получить(ВГраница), ТипЗначенияПоУмолчанию, Родитель, Кэш);
				Если ВернутьПВХ Тогда
					Возврат ПВХ;
				Иначе
					Возврат ПолучитьКонстантуСпецЗаписатьЗначениеПоПВХ(ПВХ, ЗначениеПоУмолчанию, НаДату, ТипЗначенияПоУмолчанию, Кэш);
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			Родитель = ВыборкаРезультат["Родитель" + Формат(ИндексНачальногоРодителя - 1, "ЧН=0; ЧГ=")];
			Для i = ИндексНачальногоРодителя По КоличествоРодителей Цикл
				Родитель = ПолучитьКонстантуСпецСоздатьРодителя(МассивКодов.Получить(i), Родитель, Кэш);
			КонецЦикла;
			
			ТипЗначенияПоУмолчанию = ТипЗнч(ЗначениеПоУмолчанию);
			
			ПВХ = ПолучитьКонстантуСпецПерезаписатьЭлементПВХ(Неопределено, МассивКодов.Получить(ВГраница), ТипЗначенияПоУмолчанию, Родитель, Кэш);
			Если ВернутьПВХ Тогда
				Возврат ПВХ;
			Иначе
				Возврат ПолучитьКонстантуСпецЗаписатьЗначениеПоПВХ(ПВХ, ЗначениеПоУмолчанию, НаДату, ТипЗначенияПоУмолчанию, Кэш);
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		
		Родитель = Неопределено;
		Для i = 0 По КоличествоРодителей Цикл Родитель = ПолучитьКонстантуСпецСоздатьРодителя(МассивКодов.Получить(i), Родитель, Кэш); КонецЦикла;
		
		ТипЗначенияПоУмолчанию = ТипЗнч(ЗначениеПоУмолчанию);
		
		ПВХ = ПолучитьКонстантуСпецПерезаписатьЭлементПВХ(Неопределено, МассивКодов.Получить(ВГраница), ТипЗначенияПоУмолчанию, Родитель, Кэш);
		Если ВернутьПВХ Тогда
			Возврат ПВХ;
		Иначе
			Возврат ПолучитьКонстантуСпецЗаписатьЗначениеПоПВХ(ПВХ, ЗначениеПоУмолчанию, НаДату, ТипЗначенияПоУмолчанию, Кэш);
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  Код - Строка
//  Родитель - Неопределено, ПланВидовХарактеристикСсылка.Спец_Константы -
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  ПланВидовХарактеристикСсылка.Спец_Константы
//
Функция ПолучитьКонстантуСпецСоздатьРодителя(Знач Код, Знач Родитель, Знач Кэш)
	
	ПВХОбъект = ПланыВидовХарактеристик.Спец_Константы.СоздатьГруппу();
	
	ПВХОбъект.Наименование = Код;
	ПВХОбъект.Родитель = Родитель;
	
	ЗаписатьОбъект(ПВХОбъект, , , , Кэш, 5, , Ложь);
	Возврат ПВХОбъект.Ссылка;
	
КонецФункции

// Параметры:
//  ПВХ - ПланВидовХарактеристикСсылка.Спец_Константы
//  Код - Строка
//  ТипЗначенияНовый - Тип
//  Родитель - Неопределено, ПланВидовХарактеристикСсылка.Спец_Константы -
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  ПланВидовХарактеристикСсылка.Спец_Константы
//
Функция ПолучитьКонстантуСпецПерезаписатьЭлементПВХ(Знач ПВХ, Знач Код, Знач ТипЗначенияНовый, Знач Родитель, Знач Кэш)
	
	// Дополнительная проверка, что ПВХ не существует
	Если Не ЗначениеЗаполнено(ПВХ) Тогда
		
		Запрос = Новый Запрос();
		Запрос.Текст =
		
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Константы.Ссылка КАК ПВХ
		|ИЗ
		|	ПланВидовХарактеристик.Спец_Константы КАК Константы
		|ГДЕ
		|	Константы.Наименование = &Код
		|	И Константы.Родитель = &Родитель
		|	И НЕ Константы.ПометкаУдаления";
		
		Запрос.УстановитьПараметр("Код", Код);
		Запрос.УстановитьПараметр("Родитель", Родитель);
		
		ПВХ = ПолучитьСтруктуруПервойВыборкиЗапроса(Запрос, "ПВХ"); // ПланВидовХарактеристикСсылка.Спец_Константы
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПВХ) Тогда
		
		ПВХОбъект = ПланыВидовХарактеристик.Спец_Константы.СоздатьЭлемент();
		ПВХОбъект.Наименование = Код;
		
		Если Родитель <> Неопределено Тогда
			ПВХОбъект.Родитель = Родитель;
		КонецЕсли;
		
	Иначе
		
		ПВХОбъект = ПолучитьОбъектСБлокированием(ПВХ, Кэш); // ПланВидовХарактеристикОбъект.Спец_Константы
		
	КонецЕсли;
	
	Спец_Проверить(ПВХОбъект <> Неопределено, "Не удалось получить объект ПВХ!");
	
	Если ПолучитьКонстантуСпецЭтоМассовоеЗначение(ТипЗначенияНовый, Кэш) Тогда
		ПВХОбъект.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.Спец_МассивЗначенийКонстант");
	Иначе
		ПВХОбъект.ТипЗначения = Новый ОписаниеТипов(Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(ТипЗначенияНовый));
	КонецЕсли;
	
	ЗаписатьОбъект(ПВХОбъект, , , , Кэш, 5);
	Возврат ПВХОбъект.Ссылка;
	
КонецФункции

// Параметры:
//  ПВХ - ПланВидовХарактеристикСсылка.Спец_Константы
//  Значение - см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//  НаДату - Дата
//  ТипЗначения - Тип
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  - ФиксированныйМассив из см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//	- см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//	- Неопределено
//
Функция ПолучитьКонстантуСпецЗаписатьЗначениеПоПВХ(Знач ПВХ, Знач Значение, Знач НаДату, Знач ТипЗначения, Знач Кэш)
	
	НаборЗаписей = РегистрыСведений.Спец_ХранимыеЗначенияКонстант.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Константа.Установить(ПВХ);
	
	НаборЗаписей.Прочитать();
	Если НаборЗаписей.Количество() Тогда
		
		Если НаДату = Дата(1, 1, 1) Тогда
			
			НаборЗаписей.Очистить();
			ЗаписьДляРедактирования = НаборЗаписей.Добавить();
			
		Иначе
			
			ПрошлаяЗапись = НаборЗаписей.Получить(НаборЗаписей.Количество() - 1);
			ЗаписьДляРедактирования = ?(ПрошлаяЗапись.Период = НаДату, ПрошлаяЗапись, НаборЗаписей.Добавить());
			
		КонецЕсли;
		
	Иначе
		
		ЗаписьДляРедактирования = НаборЗаписей.Добавить();
		
	КонецЕсли;
	
	ЗаписьДляРедактирования.Период = ?(НаДату = Дата(1, 1, 1), ТекущаяДатаСеанса(), НаДату);
	ЗаписьДляРедактирования.Константа = ПВХ;
	
	Если ПолучитьКонстантуСпецЭтоМассовоеЗначение(ТипЗначения, Кэш) Тогда
		
		СправочникМассивЗначенийКонстант = ПолучитьМассовоеЗначениеПоПВХ(ПВХ, Кэш);
		Если ЗначениеЗаполнено(СправочникМассивЗначенийКонстант) Тогда
			СправочникОбъект = ПолучитьОбъектСБлокированием(СправочникМассивЗначенийКонстант, Кэш);
		Иначе
			СправочникОбъект = Справочники.Спец_МассивЗначенийКонстант.СоздатьЭлемент();
		КонецЕсли;
		
		Спец_Проверить(СправочникОбъект <> Неопределено, "Не удалось заблокировать объект справочника");
		
		СправочникОбъект.Наименование = ЗначениеРеквизитаОбъекта(ПВХ, "Наименование", , Кэш); 
		СправочникОбъект.Владелец = ПВХ;
		
		СправочникОбъект.ЗначенияКонстанты.Очистить();
		Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(Значение, ТипЗначения) Тогда
			
			Для Каждого Элемент Из Значение Цикл СправочникОбъект.ЗначенияКонстанты.Добавить().Значение = Элемент; КонецЦикла;
			
		ИначеЕсли ТипЗначения = Тип("ТаблицаЗначений") Тогда
			
			//@skip-check dynamic-access-method-not-found
			Спец_Проверить(Значение.Колонки.Количество() > 0, "Невозможно прочитать значения из таблицы без колонок в константу!");
			
			//@skip-check dynamic-access-method-not-found
			НулеваяКолонка = Значение.Колонки.Получить(0).Имя;
			Для Каждого СтрокаТаблицы Из Значение Цикл СправочникОбъект.ЗначенияКонстанты.Добавить().Значение = СтрокаТаблицы[НулеваяКолонка]; КонецЦикла;
			
		ИначеЕсли ТипЗначения = Тип("СписокЗначений") Тогда
			
			Для Каждого Элемент Из Значение Цикл СправочникОбъект.ЗначенияКонстанты.Добавить().Значение = Элемент.Значение; КонецЦикла;
			
		КонецЕсли;
		
		ЗаписатьОбъект(СправочникОбъект, , , , Кэш, 5);
		
		ЗначениеДляВозврата = Новый ФиксированныйМассив(СправочникОбъект.ЗначенияКонстанты.ВыгрузитьКолонку("Значение"));
		ЗаписьДляРедактирования.ЗначениеКонстанты = СправочникОбъект.Ссылка;
		
	Иначе
		
		ЗаписьДляРедактирования.ЗначениеКонстанты = Значение;
		ЗначениеДляВозврата = Значение;
		
	КонецЕсли;
	
	Если ПВХ = ПланыВидовХарактеристик.Спец_Константы.ОтключитьИспользованиеКомпонент Тогда
		НаборЗаписей.ДополнительныеСвойства.Вставить("Спец_ПропуститьОбработки", Истина);
	КонецЕсли;
	
	ЗаписатьОбъект(НаборЗаписей, , , , Кэш, 5);
	
	Если ТипЗначения <> Тип("Неопределено") Тогда
		ПолучитьКонстантуСпецПерезаписатьЭлементПВХ(ПВХ, "", ТипЗначения, Неопределено, Кэш); // Перезаписываем тип ПВХ
	КонецЕсли;
	
	Возврат ЗначениеДляВозврата;
	
КонецФункции

// Параметры:
//  ТипЗначенияПоУмолчанию - Тип
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево
//
Функция ПолучитьКонстантуСпецЭтоМассовоеЗначение(Знач ТипЗначенияПоУмолчанию, Знач Кэш)
	
	Возврат Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ТипЗначенияПоУмолчанию, Тип("Тип"))
			Или ТипЗначенияПоУмолчанию = Тип("ТаблицаЗначений")
			Или ТипЗначенияПоУмолчанию = Тип("СписокЗначений");
	
КонецФункции

// Параметры:
//	ЗначениеРезультат - см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	- ФиксированныйМассив из см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//	- см. ПолучитьКонстантуСпец.ЗначениеПоУмолчанию
//
Функция ПолучитьКонстантуСпецОбработатьЗначениеРезультат(Знач ЗначениеРезультат, Знач Кэш) Экспорт
	
	Если ТипЗнч(ЗначениеРезультат) = Тип("СправочникСсылка.Спец_МассивЗначенийКонстант") Тогда
		
		Запрос = Новый Запрос("ВЫБРАТЬ
				|	МассивЗначенийКонстантЗначенияКонстанты.Значение КАК Значение
				|ИЗ
				|	Справочник.Спец_МассивЗначенийКонстант.ЗначенияКонстанты КАК МассивЗначенийКонстантЗначенияКонстанты
				|ГДЕ
				|	МассивЗначенийКонстантЗначенияКонстанты.Ссылка = &ЗначениеКонстанты
				|
				|УПОРЯДОЧИТЬ ПО
				|	МассивЗначенийКонстантЗначенияКонстанты.НомерСтроки");
		
		Запрос.УстановитьПараметр("ЗначениеКонстанты", ЗначениеРезультат);
		Возврат Новый ФиксированныйМассив(Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Значение"));
		
	Иначе
		
		Возврат ЗначениеРезультат;
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  МассивКонстантДляЗапроса - Массив из ПланВидовХарактеристикСсылка.Спец_Константы
// 
// Возвращаемое значение:
//  ТаблицаЗначений:
//		* Константа - ПланВидовХарактеристикСсылка.Спец_Константы
//		* ЗначениеКонстанты - Строка, Булево, Число, Неопределено -
//
Функция ПолучитьТаблицуЗначенийКонстантДляПараметровЗапуска(Знач МассивКонстантДляЗапроса)

	Запрос = Новый Запрос();
	Запрос.Текст =
	
	"ВЫБРАТЬ
	|	ХранимыеЗначенияКонстант.Константа КАК Константа,
	|	ХранимыеЗначенияКонстант.ЗначениеКонстанты КАК ЗначениеКонстанты
	|ИЗ
	|	РегистрСведений.Спец_ХранимыеЗначенияКонстант.СрезПоследних(, Константа В (&МассивКонстант)) КАК ХранимыеЗначенияКонстант";
	
	Запрос.УстановитьПараметр("МассивКонстант", МассивКонстантДляЗапроса);
	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции

// Возвращаемое значение:
//  СправочникСсылка.Спец_Пользователи
//
Функция НайтиСоздатьТекущегоПользователя()
	
	Возврат НайтиСоздатьПользователяПоИмени(Спец_ОбщегоНазначенияКлиентСервер.ТекущийПользователь1С());
	
КонецФункции

Процедура ВнешниеКомпонентыДляПереустановки(СоответствиеКомпонентДляПереустановки)
	
	ИмяКомпьютераКлиента = Спец_ПолучитьЗначениеПеременной("ИмяКомпьютераКлиент", Ложь);
	ИмяПользователяОС    = Спец_ПолучитьЗначениеПеременной("ИмяПользователяОСКлиент", Ложь);
	
	Запрос = Новый Запрос();
	
	#Область ТекстЗапроса
	
	Запрос.Текст =
	
	"ВЫБРАТЬ
	|	ИсходныеДанные.НаименованиеКомпоненты КАК НаименованиеКомпоненты,
	|	ИсходныеДанные.ВерсияКомпоненты КАК ВерсияКомпоненты,
	|	ИсходныеДанные.НаименованиеФункцииДляПодключения КАК НаименованиеФункцииДляПодключения
	|ПОМЕСТИТЬ втИсходныеДанные
	|ИЗ
	|	&ИсходныеДанные КАК ИсходныеДанные
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	втИсходныеДанные.НаименованиеКомпоненты КАК НаименованиеКомпоненты,
	|	втИсходныеДанные.ВерсияКомпоненты КАК ВерсияКомпоненты,
	|	втИсходныеДанные.НаименованиеФункцииДляПодключения КАК НаименованиеФункцииДляПодключения,
	|	МИНИМУМ(ЕСТЬNULL(ПользователиПараметрыРаботыСКомпонентами.КомпонентаНеРаботает, ИСТИНА)) КАК КомпонентаНеРаботает,
	|	МАКСИМУМ(ПользователиПараметрыРаботыСКомпонентами.Ссылка) ЕСТЬ NULL КАК ТребуетсяУстановка
	|ПОМЕСТИТЬ втТекущиеДанныеПоУстановленнымКомпонентам
	|ИЗ
	|	втИсходныеДанные КАК втИсходныеДанные
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Спец_Пользователи.ПараметрыРаботыСКомпонентами КАК ПользователиПараметрыРаботыСКомпонентами
	|		ПО (ПользователиПараметрыРаботыСКомпонентами.НаименованиеКомпоненты = втИсходныеДанные.НаименованиеКомпоненты)
	|			И (ПользователиПараметрыРаботыСКомпонентами.НомерПоследнейУстановленнойВерсии = втИсходныеДанные.ВерсияКомпоненты)
	|			И (ПользователиПараметрыРаботыСКомпонентами.ИмяКомпьютераКлиента = &ИмяКомпьютераКлиента)
	|			И (ПользователиПараметрыРаботыСКомпонентами.ИмяПользователяОС = &ИмяПользователяОС)
	|
	|СГРУППИРОВАТЬ ПО
	|	втИсходныеДанные.НаименованиеКомпоненты,
	|	втИсходныеДанные.ВерсияКомпоненты,
	|	втИсходныеДанные.НаименованиеФункцииДляПодключения
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПользователиТекущегоКомпьютера.Пользователь КАК Пользователь,
	|	&ИмяКомпьютераКлиента КАК ИмяКомпьютераКлиента,
	|	&ИмяПользователяОС КАК ИмяПользователяОС
	|ПОМЕСТИТЬ втПользователиТекущегоКомпьютера
	|ИЗ
	|	(ВЫБРАТЬ
	|		ПользователиПараметрыРаботыСКомпонентами.Ссылка КАК Пользователь
	|	ИЗ
	|		Справочник.Спец_Пользователи.ПараметрыРаботыСКомпонентами КАК ПользователиПараметрыРаботыСКомпонентами
	|	ГДЕ
	|		ПользователиПараметрыРаботыСКомпонентами.ИмяКомпьютераКлиента = &ИмяКомпьютераКлиента
	|		И ПользователиПараметрыРаботыСКомпонентами.ИмяПользователяОС = &ИмяПользователяОС
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		&ТекущийПользователь) КАК ПользователиТекущегоКомпьютера
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	втТекущиеДанныеПоУстановленнымКомпонентам.НаименованиеКомпоненты КАК НаименованиеКомпоненты,
	|	втТекущиеДанныеПоУстановленнымКомпонентам.ВерсияКомпоненты КАК ВерсияКомпоненты,
	|	втТекущиеДанныеПоУстановленнымКомпонентам.НаименованиеФункцииДляПодключения КАК НаименованиеФункцииДляПодключения,
	|	втТекущиеДанныеПоУстановленнымКомпонентам.КомпонентаНеРаботает КАК КомпонентаНеРаботает,
	|	втТекущиеДанныеПоУстановленнымКомпонентам.ТребуетсяУстановка КАК ТребуетсяУстановка
	|ИЗ
	|	втТекущиеДанныеПоУстановленнымКомпонентам КАК втТекущиеДанныеПоУстановленнымКомпонентам
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ЕСТЬNULL(ДанныеДолжныБыть.Пользователь, ТекущиеДанные.Пользователь) КАК Пользователь
	|ИЗ
	|	(ВЫБРАТЬ
	|		втПользователиТекущегоКомпьютера.Пользователь КАК Пользователь,
	|		втТекущиеДанныеПоУстановленнымКомпонентам.НаименованиеКомпоненты КАК НаименованиеКомпоненты,
	|		втТекущиеДанныеПоУстановленнымКомпонентам.ВерсияКомпоненты КАК ВерсияКомпоненты,
	|		втТекущиеДанныеПоУстановленнымКомпонентам.КомпонентаНеРаботает КАК КомпонентаНеРаботает
	|	ИЗ
	|		втПользователиТекущегоКомпьютера КАК втПользователиТекущегоКомпьютера
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ втТекущиеДанныеПоУстановленнымКомпонентам КАК втТекущиеДанныеПоУстановленнымКомпонентам
	|			ПО (ИСТИНА)) КАК ДанныеДолжныБыть
	|		ПОЛНОЕ СОЕДИНЕНИЕ (ВЫБРАТЬ
	|			втПользователиТекущегоКомпьютера.Пользователь КАК Пользователь,
	|			ПользователиПараметрыРаботыСКомпонентами.НаименованиеКомпоненты КАК НаименованиеКомпоненты,
	|			ПользователиПараметрыРаботыСКомпонентами.НомерПоследнейУстановленнойВерсии КАК НомерПоследнейУстановленнойВерсии,
	|			ПользователиПараметрыРаботыСКомпонентами.КомпонентаНеРаботает КАК КомпонентаНеРаботает
	|		ИЗ
	|			втПользователиТекущегоКомпьютера КАК втПользователиТекущегоКомпьютера
	|				ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Спец_Пользователи.ПараметрыРаботыСКомпонентами КАК ПользователиПараметрыРаботыСКомпонентами
	|				ПО втПользователиТекущегоКомпьютера.Пользователь = ПользователиПараметрыРаботыСКомпонентами.Ссылка
	|					И втПользователиТекущегоКомпьютера.ИмяКомпьютераКлиента = ПользователиПараметрыРаботыСКомпонентами.ИмяКомпьютераКлиента
	|					И втПользователиТекущегоКомпьютера.ИмяПользователяОС = ПользователиПараметрыРаботыСКомпонентами.ИмяПользователяОС) КАК ТекущиеДанные
	|		ПО ДанныеДолжныБыть.Пользователь = ТекущиеДанные.Пользователь
	|			И ДанныеДолжныБыть.НаименованиеКомпоненты = ТекущиеДанные.НаименованиеКомпоненты
	|ГДЕ
	|	(ЕСТЬNULL(ДанныеДолжныБыть.ВерсияКомпоненты, """") <> ЕСТЬNULL(ТекущиеДанные.НомерПоследнейУстановленнойВерсии, """")
	|			ИЛИ ЕСТЬNULL(ДанныеДолжныБыть.КомпонентаНеРаботает, ИСТИНА) <> ЕСТЬNULL(ТекущиеДанные.КомпонентаНеРаботает, ИСТИНА))";
	
	#КонецОбласти
	
	Запрос.УстановитьПараметр("ИсходныеДанные"       , НоваяТаблицаВерсийМоихКомпонент());
	Запрос.УстановитьПараметр("ИмяКомпьютераКлиента" , ИмяКомпьютераКлиента);
	Запрос.УстановитьПараметр("ИмяПользователяОС"    , ИмяПользователяОС);
	Запрос.УстановитьПараметр("ТекущийПользователь"  , ПараметрыСеанса.Спец_ТекущийПользователь);
	
	ПакетыЗапросов = Запрос.ВыполнитьПакет();
	ВГраница       = ПакетыЗапросов.ВГраница();
	
	// Корректируем данные, если отличаются
	ТаблицаДанныеПоУстановленнымКомпонентам = ПакетыЗапросов[ВГраница - 1].Выгрузить();
	
	ВыборкаПоНекорректнымДанным = ПакетыЗапросов[ВГраница].Выбрать();
	Пока ВыборкаПоНекорректнымДанным.Следующий() Цикл
		
		//@skip-check dynamic-access-method-not-found
		ПользовательОбъект = ВыборкаПоНекорректнымДанным.Пользователь.ПолучитьОбъект(); // СправочникОбъект.Спец_Пользователи
		
		Для Каждого СтрокаДляДобавления Из ТаблицаДанныеПоУстановленнымКомпонентам Цикл
			
			//@skip-check structure-consructor-value-type
			СтруктураОтбора = Новый Структура("НаименованиеКомпоненты, ИмяКомпьютераКлиента, ИмяПользователяОС",
					СтрокаДляДобавления.НаименованиеКомпоненты,
					ИмяКомпьютераКлиента,
					ИмяПользователяОС);
			
			МассивСтрок = ПользовательОбъект.ПараметрыРаботыСКомпонентами.НайтиСтроки(СтруктураОтбора);
			Чистим      = Истина;
			
			// Если установлена версия выше - пропускаем
			Для Каждого СтрокаКомпонента Из МассивСтрок Цикл
				
				ТекущаяВерсияЧислом = Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(Спец_СтроковыеФункцииКлиентСервер.ОставитьТолькоЦифрыВСтроке(СтрокаКомпонента.НомерПоследнейУстановленнойВерсии));
				НужнаяВерсияЧислом  = Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(Спец_СтроковыеФункцииКлиентСервер.ОставитьТолькоЦифрыВСтроке(СтрокаДляДобавления.ВерсияКомпоненты));
				
				Если ТекущаяВерсияЧислом >= НужнаяВерсияЧислом Тогда
					
					Чистим = Ложь;
					Прервать;
					
				КонецЕсли;
				
			КонецЦикла;
			
			Если Не Чистим Тогда
				Продолжить;
			КонецЕсли;
			
			Для Каждого СтрокаДляУдаления Из МассивСтрок Цикл
				ПользовательОбъект.ПараметрыРаботыСКомпонентами.Удалить(СтрокаДляУдаления);
			КонецЦикла;
			
			НоваяСтрокаПараметр = ПользовательОбъект.ПараметрыРаботыСКомпонентами.Добавить();
			
			НоваяСтрокаПараметр.НаименованиеКомпоненты            = СтрокаДляДобавления.НаименованиеКомпоненты;
			НоваяСтрокаПараметр.ИмяКомпьютераКлиента              = ИмяКомпьютераКлиента;
			НоваяСтрокаПараметр.ИмяПользователяОС                 = ИмяПользователяОС;
			НоваяСтрокаПараметр.КомпонентаНеРаботает              = СтрокаДляДобавления.КомпонентаНеРаботает;
			НоваяСтрокаПараметр.НомерПоследнейУстановленнойВерсии = СтрокаДляДобавления.ВерсияКомпоненты;
			
		КонецЦикла;
		
		ПользовательОбъект.Записать();
		
	КонецЦикла;
	
	// Формируем соответствие для переустановки
	Для Каждого СтрокаДляДобавления Из ТаблицаДанныеПоУстановленнымКомпонентам Цикл
		
		Если Не СтрокаДляДобавления.ТребуетсяУстановка Тогда
			Продолжить;
		КонецЕсли;
		
		СоответствиеКомпонентДляПереустановки[СтрокаДляДобавления.НаименованиеКомпоненты] = НоваяСтруктураРаботыСКомпонентами(
					СтрокаДляДобавления.НаименованиеФункцииДляПодключения,
					СтрокаДляДобавления.ВерсияКомпоненты);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

//@skip-check structure-consructor-too-many-keys
//@skip-check structure-consructor-value-type
//@skip-check constructor-function-return-section
//@skip-check statement-type-change
#Область Типизация

// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//		* Ключ - Строка
//		* Значение - Массив из Тип
Функция НовоеСоответствиеДляПреобразованияМассиваСтрокВТаблицуЗначений()
	
	Возврат Новый Соответствие();
	
КонецФункции

// Параметры:
//  МассивТипов - Массив из Тип
// 
// Возвращаемое значение:
//  ТаблицаЗначений:
// * Ссылка - ЛюбаяСсылка
Функция НоваяТаблицаСКолонкойСсылкаПоМассивуТипов(Знач МассивТипов)

	ТаблицаДляЗапроса = Новый ТаблицаЗначений();
	ТаблицаДляЗапроса.Колонки.Добавить("Ссылка", Новый ОписаниеТипов(МассивТипов));

	Возврат ТаблицаДляЗапроса;

КонецФункции

// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//		* Ключ - Тип
//		* Значение - Массив из см. ЗначенияРеквизитовОбъекта.СсылкаИлиОбъект
Функция НовоеСоответствиеТиповДляЗначенияРеквизитовОбъектов()
	
	Возврат Новый Соответствие();
	
КонецФункции

// Параметры:
//  НуженМассив - Булево
// 
// Возвращаемое значение:
//  см. НайтиПоСсылкамПрограммно
Функция НовыйОбъектДляВозвратаНайтиПоСсылкамПрограммно(Знач НуженМассив)
	
	Если НуженМассив Тогда
		
		ОбъектДляВозврата = Новый Массив;
		
	Иначе
		
		ОбъектДляВозврата = Новый ТаблицаЗначений;
		
		ОбъектДляВозврата.Колонки.Добавить("ИсходныйОбъект"      , Спец_ОбщегоНазначенияПовтИсп.ОписаниеТипаВсеСсылки());
		ОбъектДляВозврата.Колонки.Добавить("ПолноеИмяМетаданных" , Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(256));
		ОбъектДляВозврата.Колонки.Добавить("Данные"              , );
		
	КонецЕсли;
	
	Возврат ОбъектДляВозврата;
	
КонецФункции

// Параметры:
//  РезультатЗапроса - РезультатЗапроса
// 
// Возвращаемое значение:
//  ВыборкаИзРезультатаЗапроса:
//		* ИсходныйОбъект - ЛюбаяСсылка
// 		* ПолноеИмяМетаданных - Строка
// 		* Данные - ЛюбаяСсылка
Функция ПолучитьВыборкуПоОбъектам(Знач РезультатЗапроса)
	
	Возврат РезультатЗапроса.Выбрать();
	
КонецФункции

// Возвращаемое значение:
//  см. ПолучитьСтруктуруИмениТипаДанныхОбъекта
//
Функция НоваяСтруктураРезультатСтруктурыИмениТипа()
	
	Возврат Новый Структура(
			
			"ИмяОбъекта,
			|ПолноеИмяОбъекта,
			|ТипОбъектаЕдинственноеЧисло,
			|ТипОбъектаМножественноеЧисло,
			|МетаданныеОбъекта,
			|МенеджерОбъекта,
			|Тип",
			
			"",
			"",
			"",
			"",
			Неопределено,
			Неопределено,
			Тип("Неопределено"));
	
КонецФункции

// Возвращаемое значение:
//	см. ПолучитьСтруктуруВсехРеквизитовОбъекта
Функция НоваяСтруктураРезультатДляПолученияВсехРеквизитов()
	
	Возврат Новый Структура("МассивРеквизитов, ТабличныеЧасти", Новый Массив(), Новый Структура());
	
КонецФункции

// Параметры:
//  ПолноеИмяМетаданных - Строка
//  ТабличнаяЧасть - Строка
//  ИмяРеквизита - Строка
// 
// Возвращаемое значение:
//  Структура:
// * ПолноеИмяМетаданных - Строка
// * ТабличнаяЧасть - Строка
// * ИмяРеквизита - Строка
Функция НоваяСтруктураРеквизитаДляПолученияВсехРеквизитовГдеУчаствует(Знач ПолноеИмяМетаданных, Знач ТабличнаяЧасть, Знач ИмяРеквизита)

	Возврат Новый Структура("ПолноеИмяМетаданных, ТабличнаяЧасть, ИмяРеквизита",
			ПолноеИмяМетаданных,
			ТабличнаяЧасть,
			ИмяРеквизита);

КонецФункции

// Возвращаемое значение:
//  см. ПолучитьСтруктуруВходящегоПотокаHTTPСервисЗапроса
Функция НоваяСтруктураДанныхПоHTTPЗапросу()
	
	Возврат Новый Структура("Отправитель, База, УровеньБазы, РаботаетВБазеРайона, Поток",
			Неопределено,
			Неопределено,
			Перечисления.УровеньБазы.ГлавныйУзел,
			Ложь,
			Неопределено);
			
КонецФункции

// Параметры:
//  НужноРавенство - Булево
//  ЗначениеПараметра - Произвольный
//  ИмяПараметра - Строка
// 
// Возвращаемое значение:
//  Структура:
// * НужноРавенство - Булево
// * ЗначениеПараметра - Произвольный
// * ИмяПараметра - Строка
Функция НоваяСтруктураПараметраДляПоискаПоСсылкам(Знач НужноРавенство, Знач ЗначениеПараметра, Знач ИмяПараметра)
	
	Возврат Новый Структура("НужноРавенство, ЗначениеПараметра, ИмяПараметра",
			НужноРавенство,
			ЗначениеПараметра,
			ИмяПараметра);
	
КонецФункции

// Параметры:
//  ОписаниеТипов - ОписаниеТипов
// 
// Возвращаемое значение:
//  ТаблицаЗначений:
//		* Значение - Произвольный
Функция НоваяТаблицаДляРазностиОбъектов(Знач ОписаниеТипов)
	
	ТаблицаИсходная = Новый ТаблицаЗначений;
	ТаблицаИсходная.Колонки.Добавить("Значение", ОписаниеТипов);
	
	Возврат ТаблицаИсходная;
	
КонецФункции

// Возвращаемое значение:
//	см. ПолучитьСтруктуруПараметровДляЗапуска
//
Функция НоваяСтруктураПараметровДляЗапуска()

	Возврат Новый Структура(
			
			"ВключитьУведомленияПользователей,
			|ПодключатьОбработчикЗавершенияРаботыПользователей,
			|УстанавливатьЗаголовокБазы,
			|ПериодОбновленияНовыхУведомлений,
			|ЗаголовокДляУстановки,
			|СоответствиеКомпонентДляПереустановки",
			
			Ложь,
			Ложь,
			Ложь,
			30,
			"",
			НовоеСоответствиеДляРаботыСКомпонентами());
	
КонецФункции

// Возвращаемое значение:
//	Соответствие из КлючИЗначение:
//		* Ключ - Строка
//		* Значение - см. НоваяСтруктураРаботыСКомпонентами
//
Функция НовоеСоответствиеДляРаботыСКомпонентами()
	
	Возврат Новый Соответствие();
	
КонецФункции

// Параметры:
//  ИмяФункцииДляВызова - Строка
//	ТекущаяВерсия - Строка
// 
// Возвращаемое значение:
//	Структура:
//		* ИмяФункцииДляВызова - Строка
//		* ТекущаяВерсия - Строка
//
Функция НоваяСтруктураРаботыСКомпонентами(Знач ИмяФункцииДляВызова, Знач ТекущаяВерсия)
	
	Возврат Новый Структура("ИмяФункцииДляВызова, ТекущаяВерсия",
			ИмяФункцииДляВызова,
			ТекущаяВерсия);
	
КонецФункции

//@skip-check property-return-type
// Возвращаемое значение:
//  см. ПодготовитьНовуюТаблицуВерсийМоихКомпонент
//
Функция НоваяТаблицаВерсийМоихКомпонент()
	
	ТаблицаДляЗапроса = ПодготовитьНовуюТаблицуВерсийМоихКомпонент();
	Для Каждого КлючЗначение Из Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьСоответствиеВерсийМоихКомпонент() Цикл
		
		НоваяСтрока = ТаблицаДляЗапроса.Добавить();
		
		НоваяСтрока.НаименованиеКомпоненты            = КлючЗначение.Ключ;
		НоваяСтрока.ВерсияКомпоненты                  = КлючЗначение.Значение.НомерВерсии;
		НоваяСтрока.НаименованиеФункцииДляПодключения = КлючЗначение.Значение.НаименованиеФункцииДляПодключения;
		
	КонецЦикла;
	
	Возврат ТаблицаДляЗапроса;
	
КонецФункции

// Возвращаемое значение:
//  ТаблицаЗначений:
//  	* НаименованиеКомпоненты - Строка
//  	* ВерсияКомпоненты - Строка
//  	* НаименованиеФункцииДляПодключения - Строка
//
Функция ПодготовитьНовуюТаблицуВерсийМоихКомпонент()
	
	ТаблицаДляЗапроса = Новый ТаблицаЗначений();
	
	ТаблицаДляЗапроса.Колонки.Добавить("НаименованиеКомпоненты"            , Метаданные.Справочники.Спец_Пользователи.ТабличныеЧасти.ПараметрыРаботыСКомпонентами.Реквизиты.НаименованиеКомпоненты.Тип);
	ТаблицаДляЗапроса.Колонки.Добавить("ВерсияКомпоненты"                  , Метаданные.Справочники.Спец_Пользователи.ТабличныеЧасти.ПараметрыРаботыСКомпонентами.Реквизиты.НомерПоследнейУстановленнойВерсии.Тип);
	ТаблицаДляЗапроса.Колонки.Добавить("НаименованиеФункцииДляПодключения" , Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(256));
	
	Возврат ТаблицаДляЗапроса;
	
КонецФункции

#КонецОбласти

#КонецОбласти
