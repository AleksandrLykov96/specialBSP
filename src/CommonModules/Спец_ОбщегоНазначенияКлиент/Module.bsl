// @strict-types

//@skip-check method-too-many-params
//@skip-check function-should-return-value

#Область ПрограммныйИнтерфейс

// Формирует и выводит сообщение, которое может быть связано с элементом управления формы.
//
// См. Спец_ОбщегоНазначения.СообщитьПользователю
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле - Строка - наименование реквизита формы.
//  ПутьКДанным - Строка - путь к данным (путь к реквизиту формы).
//  Отказ - Булево - выходной параметр, всегда устанавливается в значение Истина.
//  ИдентификаторНазначения - Неопределено, УникальныйИдентификатор - Уникальный идентификатор назначения сообщения
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  Спец_ОбщегоНазначенияКлиент.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимого.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(Знач ТекстСообщенияПользователю, Знач КлючДанных = Неопределено, Знач Поле = "", Знач ПутьКДанным = "", Отказ = Ложь, Знач ИдентификаторНазначения = Неопределено) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле  = Поле;
	
	Если ИдентификаторНазначения <> Неопределено Тогда
		Сообщение.ИдентификаторНазначения = ИдентификаторНазначения;
	КонецЕсли;
	
	Сообщение.КлючДанных = КлючДанных;
	Если Не ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
	
	Сообщение.Сообщить();
	Отказ = Истина;
	
КонецПроцедуры

// Метод для открытия внешней обработки.
// 
// Параметры:
//  ИмяОбработкиИлиСсылка - см. Спец_ОбщегоНазначенияПовтИсп.ПодключитьВнешнююОбработку.ИмяОбработкиИлиСсылка
//  ИмяФормы - Строка - Наименование формы для открытия
//  ОткрытьМодально - Булево - Флаг того, что форму нужно открыть модально.
//  Параметры - Неопределено, Структура - Параметры открытия формы
//  Владелец - Неопределено, Форма, ФормаКлиентскогоПриложения - Владелец формы
//  Уникальность - Произвольный - Уникальность для открываемой формы
//  Окно - ОкноКлиентскогоПриложения - Окно приложения
//  НавигационнаяСсылка - Строка, Неопределено - Навигационная ссылка
//  ОписаниеОповещенияОЗакрытии - Неопределено, ОписаниеОповещения - Описание оповещения после закрытия формы
//  РежимОткрытияОкна - Неопределено, РежимОткрытияОкнаФормы - Режим открытия окна формы
// 
// Возвращаемое значение:
//  Булево, Произвольный - Результат открытия внешней обработки.
//
Функция ОткрытьВнешнююОбработку(Знач ИмяОбработкиИлиСсылка, Знач ИмяФормы = "Форма", Знач ОткрытьМодально = Ложь,
		Знач Параметры = Неопределено, Знач Владелец = Неопределено, Знач Уникальность = Неопределено, Знач Окно = Неопределено,
		Знач НавигационнаяСсылка = Неопределено, Знач ОписаниеОповещенияОЗакрытии = Неопределено, Знач РежимОткрытияОкна = Неопределено) Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		АдресОбработки = Спец_ОбщегоНазначенияПовтИсп.ПодключитьВнешнююОбработку(ИмяОбработкиИлиСсылка);
	#Иначе
		АдресОбработки = Спец_ОбщегоНазначенияВызовСервера.ПодключитьВнешнююОбработку(ИмяОбработкиИлиСсылка);
	#КонецЕсли
	
	Спец_Проверить(АдресОбработки, "Не удалось подключить внешнюю обработку " + ИмяОбработкиИлиСсылка);
	
	#Если Не ВебКлиент Тогда
		
		Если ОткрытьМодально Тогда
			
			Возврат ОткрытьФормуМодально("ВнешняяОбработка." + АдресОбработки + "." + ИмяФормы,
					Параметры,
					Владелец,
					НавигационнаяСсылка);
			
		КонецЕсли;
		
	#КонецЕсли
	
	//@skip-check invocation-parameter-type-intersect
	ОткрытьФорму("ВнешняяОбработка." + АдресОбработки + "." + ИмяФормы,
			Параметры,
			Владелец,
			Уникальность,
			Окно,
			НавигационнаяСсылка,
			ОписаниеОповещенияОЗакрытии,
			РежимОткрытияОкна);
	
	Возврат Истина;
	
КонецФункции

// Обработка внешнего события внешней компоненты.
// 
// Параметры:
//  Источник - Строка
//  Событие - Строка
//  Данные - Строка
// 
// Возвращаемое значение:
//  Булево - Флаг того, что событие обработано.
//
Функция ОбработкаВнешнегоСобытияКомпоненты(Знач Источник, Знач Событие, Знач Данные) Экспорт
	
	Если Источник = "PostgreSQLRequest" Тогда
		
		Спец_Проверить(СтрНайти(ВРег(Событие), ВРег("Ошибка в потоке")) = 0,
				СтрШаблон("Ошибка компоненты PostgreSQL <%1>:%2%3", Событие, Символы.ПС, Данные));
		
		СтруктураРезультат = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСоответствиеJSON(Данные, , Ложь);
		Если СтруктураРезультат = Неопределено Тогда
			Оповестить(Событие, Новый Структура("Успешно, ТекстОшибки", Ложь, Данные), "PostgreSQL");
		Иначе
			Оповестить(Событие, СтруктураРезультат, "PostgreSQL");
		КонецЕсли;
		
		Возврат Истина;
		
	ИначеЕсли Источник = "HTTPRequestsResult" Тогда
		
		Спец_Проверить(СтрНайти(ВРег(Событие), ВРег("Ошибка в потоке")) = 0,
				СтрШаблон("Ошибка компоненты 'HTTP client' <%1>:%2%3", Событие, Символы.ПС, Данные));
		
		СтруктураИлиМассивРезультатЗапроса = Спец_КомпонентаДополнительныеФункцииКлиентСервер.HTTPClientПреобразоватьJsonВРезультат(Данные);
		
		// ++ Спец_БСП.ОбменСДругимиБазами_ЧтоТоЕсть
		Если СтрНачинаетсяС(Событие, "Спец_ОбменСДругимиБазами_") Тогда
			
			Спец_ОбменСДругимиБазамиКлиент.ОтправитьHTTPЗапросыКНужнойБазеЧерезВнешнееСобытие_ОбработатьРезультат(СтруктураИлиМассивРезультатЗапроса);
			Возврат Истина;
			
		КонецЕсли;
		// -- Спец_БСП.ОбменСДругимиБазами_ЧтоТоЕсть
		
		Оповестить(Событие, СтруктураИлиМассивРезультатЗапроса, "HTTPClient");
		Возврат Истина;
		
	// ++ Спец_БСП.ПодключаемоеОборудование
	// ПодключаемоеОборудование
	Иначе
		
		МенеджерОборудованияКлиент.ОбработкаВнешнегоСобытия(Источник, Событие, Данные);
	
	// Конец ПодключаемоеОборудование
	// -- Спец_БСП.ПодключаемоеОборудование
		
	КонецЕсли;
	
	//@skip-check unreachable-statement
	Возврат Ложь;
	
КонецФункции

// Выводит состояние по-нормальному:
// 	- Для тонкого клиента обычный вызов "Состояние"
// 	- Для толстого клиента формирует сообщение по всем данным (с учётом прогресса выполнения) и вызывает "Состояние"
// 
// Параметры:
//  ТекстСообщения - Строка - Текст сообщения для вывода
//  Прогресс - Число - Прогресс выполнения (в процентах)
//  Пояснение - Неопределено, Строка - Пояснение
//  Картинка - Неопределено, Картинка - Картинка для вывода (только для тонкого клиента)
//  ВозможностьПрерывания - Булево - Возможность прерывания. Если ИСТИНА, то см. Спец_КомпонентаДополнительныеФункцииКлиент.ОбработкаПрерывания
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ВывестиСостояние(Знач ТекстСообщения, Знач Прогресс = 0, Знач Пояснение = "", Знач Картинка = Неопределено,
		Знач ВозможностьПрерывания = Ложь, Кэш = Неопределено) Экспорт
	
	Если ВозможностьПрерывания Тогда
		
		Спец_КомпонентаДополнительныеФункцииКлиент.ОбработкаПрерывания(Кэш);
		Спец_СтроковыеФункцииКлиентСервер.ДобавитьСтрокуВТекст("<Для прерывания удерживайте Ctrl + Break>", Пояснение, " ");
		
	КонецЕсли;
	
	НепосредственныйВыводСостояния(ТекстСообщения, Прогресс, Пояснение, Картинка);
	
КонецПроцедуры

// ++ Спец_БСП.Версия1С_18_ВышеИлиРавно

#Область АсинхронныеВызовы

// Метод для красивой, асинхронной загрузки файлов на сервер.
// Параметры:
//  ПараметрыДиалога - ПараметрыДиалогаПомещенияФайлов - Параметры диалога помещения файлов (см. НачатьПомещениеФайлаНаСервер)
//  ИдентификаторФормы - Неопределено, УникальныйИдентификатор - Уникальный идентификатор формы-родителя.
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Массив из ОписаниеПомещенногоФайла
//
Асинх Функция ЗагрузитьФайлыНаСерверАсинх(Знач ПараметрыДиалога, Знач ИдентификаторФормы = Неопределено, Кэш = Неопределено) Экспорт
	
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.BaseFunction_ПодключитьЕслиНеПодключали(Кэш);
	
	ДополнительныеПараметры = НоваяСтруктураДополнительныхПараметровЗагрузкиФайловНаСервер(Кэш);
	
	ОписаниеОповещенияПередНачалом = Новый ОписаниеОповещения("ПередНачаломЗагрузкиФайловНаСервер", Спец_ОбщегоНазначенияКлиент, ДополнительныеПараметры);
	Если ПараметрыДиалога.МножественныйВыбор Тогда
		
		Возврат Ждать ПоместитьФайлыНаСерверАсинх(
				Новый ОписаниеОповещения("ХодВыполненияЗагрузкиФайловНаСерверМассовый", Спец_ОбщегоНазначенияКлиент, ДополнительныеПараметры),
				ОписаниеОповещенияПередНачалом,
				ПараметрыДиалога,
				ИдентификаторФормы);
		
	Иначе
		
		ОписаниеПомещенногоФайла = Ждать ПоместитьФайлНаСерверАсинх(
				Новый ОписаниеОповещения("ХодВыполненияЗагрузкиФайловНаСерверОдиночный", Спец_ОбщегоНазначенияКлиент, ДополнительныеПараметры),
				ОписаниеОповещенияПередНачалом,
				,
				ПараметрыДиалога,
				ИдентификаторФормы);
		
		Возврат ?(ОписаниеПомещенногоФайла = Неопределено,
				Новый Массив(),
				Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(ОписаниеПомещенногоФайла));
		
	КонецЕсли;
	
КонецФункции

// Метод для красивой, асинхронной загрузки файлов с сервера.
// 
// Параметры:
//  ПараметрыДиалога - ПараметрыДиалогаПолученияФайлов - Параметры диалога получения файлов (см. НачатьПолучениеФайловССервера)
//  МассивПолучаемыхФайлов - ОписаниеПередаваемогоФайла, Массив из ОписаниеПередаваемогоФайла - Массив файлов для загрузки (или само описание файла)
//  ПараметрыПолученияАрхива - Неопределено, ПараметрыПолученияАрхиваФайлов - Параметры получения архива (см. НачатьПолучениеФайловССервера)
//
// Возвращаемое значение:
//  Массив из ОписаниеПереданногоФайла
//
Асинх Функция ЗагрузитьФайлыССервераАсинх(Знач ПараметрыДиалога, Знач МассивПолучаемыхФайлов, Знач ПараметрыПолученияАрхива = Неопределено) Экспорт
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивПолучаемыхФайлов);
	КоличествоПереданныхФайлов = МассивПолучаемыхФайлов.Количество();
	
	Если КоличествоПереданныхФайлов = 0 Тогда
		Возврат Новый Массив();
	КонецЕсли;
	
	Если КоличествоПереданныхФайлов = 1 Тогда
		
		НулевойФайл = МассивПолучаемыхФайлов.Получить(0);
		
		//@skip-check variable-value-type
		РезультатВыполнения = Ждать ПолучитьФайлССервераАсинх(НулевойФайл.Хранение, НулевойФайл.Имя, ПараметрыДиалога);
		Возврат ?(РезультатВыполнения = Неопределено,
				Новый Массив(),
				Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(РезультатВыполнения));
		
	Иначе
		
		Возврат Ждать ПолучитьФайлыССервераАсинх(МассивПолучаемыхФайлов,
				ПараметрыДиалога,
				ПараметрыПолученияАрхива);
		
	КонецЕсли;
	
Конецфункции

// Асинхронный вариант (см. Спец_ОбщегоНазначенияКлиентСервер.ПодключитьВнешнююКомпонентуДляРаботы)
// 
// Параметры:
//  МестоположениеКомпоненты - см. Спец_ОбщегоНазначенияКлиентСервер.ПодключитьВнешнююКомпонентуДляРаботы.МестоположениеКомпоненты
//  ИмяКомпоненты - см. Спец_ОбщегоНазначенияКлиентСервер.ПодключитьВнешнююКомпонентуДляРаботы.ИмяКомпоненты
//  ИдентификаторВКомпоненте - см. Спец_ОбщегоНазначенияКлиентСервер.ПодключитьВнешнююКомпонентуДляРаботы.ИдентификаторВКомпоненте
//  СтатическоеИмя - см. Спец_ОбщегоНазначенияКлиентСервер.ПодключитьВнешнююКомпонентуДляРаботы.СтатическоеИмя
//  Бесшумно - см. Спец_ОбщегоНазначенияКлиентСервер.ПодключитьВнешнююКомпонентуДляРаботы.Бесшумно
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначенияКлиентСервер.ПодключитьВнешнююКомпонентуДляРаботы
//
Асинх Функция ПодключитьВнешнююКомпонентуДляРаботыАсинх(Знач МестоположениеКомпоненты, Знач ИмяКомпоненты, Знач ИдентификаторВКомпоненте,
		Знач СтатическоеИмя = Истина, Знач Бесшумно = Ложь) Экспорт
	
	// На Wine ничего лучше не подключать через этот метод
	Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоWine() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПустаяСтрока(МестоположениеКомпоненты) Тогда
		
		ИмяДляПодключения = СтрШаблон("AddIn.%1.%2", ИмяКомпоненты, СтрЗаменить(ИмяКомпоненты, ".", "_"));
		
		Попытка
			
			Спец_Проверить(Ждать ПодключитьВнешнююКомпонентуАсинх(ИмяКомпоненты), "Внешний драйвер не найден: " + ИмяКомпоненты);
			Результат = Новый(ИмяДляПодключения); // ОбъектВнешнейКомпоненты
			
		Исключение
			
			Если Не Бесшумно Тогда
				
				СообщитьПользователю(
						СтрШаблон("Не удалось подключить компоненту ""%1""!%2%3",
								ИмяКомпоненты,
								Символы.ПС,
								Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб)));
				
			КонецЕсли;
			
		КонецПопытки;
		
		Возврат Результат;
		
	КонецЕсли;
	
	ИмяОбъекта = ИмяКомпоненты + "_"
			+ ?(СтатическоеИмя,
					Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ПодготовитьУникальноеИмяНаВремяРаботыРабочегоПроцесса(),
					Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ПодготовитьУникальноеИмяНаВремяСеанса());
	
	ТекстОшибки = "";
	Попытка
		Успешно = Ждать Спец_КомпонентаДополнительныеФункцииКлиент.ПодключитьКомпонентуАсинх(МестоположениеКомпоненты, ИмяОбъекта);
	Исключение
		ТекстОшибки = Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб);
	КонецПопытки;
	
	Если Успешно = Неопределено Тогда
		
		Если Не Бесшумно Тогда
			
			СообщитьПользователю(
					СтрШаблон("Не удалось подключить компоненту ""%1""!%2%3",
							МестоположениеКомпоненты,
							Символы.ПС,
							ТекстОшибки));
			
		КонецЕсли;
		
		Возврат Результат;
		
	КонецЕсли;
	
	// Если дошли сюда, то значит компонента либо подключилась, либо нет.
	ИмяДляПодключения = СтрШаблон("AddIn.%1.%2", ИмяОбъекта, ИдентификаторВКомпоненте);
	Если Успешно = Истина Тогда
		Возврат Новый(ИмяДляПодключения); // ОбъектВнешнейКомпоненты
	КонецЕсли;
	
	// Если веб-клиент - нет смысла устанавливать компоненту
	#Если ВебКлиент Тогда
		
		Если Не Бесшумно Тогда
			
			СообщитьПользователю(
					СтрШаблон("Не удалось подключить компоненту ""%1""!
							|Компонента не подключается. Проверьте, корректная ли компонента и соблюдены ли системные требования.",
							
							МестоположениеКомпоненты));
			
		КонецЕсли;
		
		Возврат Результат;
		
	#Иначе
		
		// Устанавливаем компоненту
		Попытка
			
			Ждать УстановитьВнешнююКомпонентуАсинх(МестоположениеКомпоненты);
			
		Исключение
			
			Если Не Бесшумно Тогда
				
				СообщитьПользователю(
						СтрШаблон("Не удалось подключить компоненту ""%1""!%2%3",
								МестоположениеКомпоненты,
								Символы.ПС,
								Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб)));
				
			КонецЕсли;
			
			Возврат Результат;
			
		КонецПопытки;
		
		// Подключаем ещё раз. Готовое имя компоненты уже сохранилось
		Попытка
			
			Спец_Проверить(Ждать Спец_КомпонентаДополнительныеФункцииКлиент.ПодключитьКомпонентуАсинх(МестоположениеКомпоненты, ИмяОбъекта),
					"Компонента не подключается. Проверьте, корректная ли компонента и соблюдены ли системные требования.");
			
			Результат = Новый(ИмяДляПодключения); // ОбъектВнешнейКомпоненты
			
		Исключение
			
			Если Не Бесшумно Тогда
				
				СообщитьПользователю(
						СтрШаблон("Не удалось подключить компоненту ""%1""!%2%3",
								МестоположениеКомпоненты,
								Символы.ПС,
								Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб)));
				
			КонецЕсли;
			
		КонецПопытки;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

// Асинхронный вариант (см. Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьФайловыйПотокСИменемФайла)
// 
// Параметры:
//  ФорматФайла - см. Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьФайловыйПотокСИменемФайла.ФорматФайла
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьФайловыйПотокСИменемФайла
//
Асинх Функция ПодготовитьФайловыйПотокСИменемФайлаАсинх(Знач ФорматФайла = "json") Экспорт
	
	#Если Не ВебКлиент Тогда
		
		РазмерБуфера = Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков"), 16384); // Число
		
		//@skip-check missing-temporary-file-deletion
		ИмяФайла = ПолучитьИмяВременногоФайла(ФорматФайла);
		
		Возврат Ждать ФайловыеПотоки.ОткрытьДляЗаписиАсинх(ИмяФайла, РазмерБуфера);
		
	#Иначе
		
		Возврат Неопределено;
		
	#КонецЕсли
	
КонецФункции

// Асинхронный вариант (см. Спец_ОбщегоНазначенияКлиентСервер.ЗакрытьПотокНеМешаяРаботе)
// 
// Параметры:
//  ПотокДляЗакрытия - см. Спец_ОбщегоНазначенияКлиентСервер.ЗакрытьПотокНеМешаяРаботе.ПотокДляЗакрытия
//  ЗакрытьДляРаботыСФайлом - см. Спец_ОбщегоНазначенияКлиентСервер.ЗакрытьПотокНеМешаяРаботе.ЗакрытьДляРаботыСФайлом
//  УдалятьФайлФайловогоПотока - см. Спец_ОбщегоНазначенияКлиентСервер.ЗакрытьПотокНеМешаяРаботе.УдалятьФайлФайловогоПотока
//
// Возвращаемое значение:
//  Неопределено
//
Асинх Функция ЗакрытьПотокНеМешаяРаботеАсинх(ПотокДляЗакрытия, Знач ЗакрытьДляРаботыСФайлом = Ложь, Знач УдалятьФайлФайловогоПотока = Истина) Экспорт
	
	Если ЗакрытьДляРаботыСФайлом Тогда
		
		Ждать ПотокДляЗакрытия.СброситьБуферыАсинх();
		Ждать ПотокДляЗакрытия.ЗакрытьАсинх();
		
	Иначе
		
		ПотокДляЗакрытия.ЗакрытьАсинх();
		
		Если УдалятьФайлФайловогоПотока И ТипЗнч(ПотокДляЗакрытия) = Тип("ФайловыйПоток") Тогда
			УдалитьФайлыНеМешаяРаботеАсинх(ПотокДляЗакрытия.ИмяФайла);
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

// Асинхронный вариант (см. Спец_ОбщегоНазначенияКлиентСервер.УдалитьФайлыНеМешаяРаботе)
// 
// Параметры:
//  МассивФайловИлиИмяФайла - см. Спец_ОбщегоНазначенияКлиентСервер.УдалитьФайлыНеМешаяРаботе.МассивФайловИлиИмяФайла
//
// Возвращаемое значение:
//  Неопределено
//
Асинх Функция УдалитьФайлыНеМешаяРаботеАсинх(Знач МассивФайловИлиИмяФайла) Экспорт
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивФайловИлиИмяФайла);
	Для Каждого ИмяФайла Из МассивФайловИлиИмяФайла Цикл
		
		Если Не ПустаяСтрока(ИмяФайла) Тогда
			УдалитьФайлыАсинх(ИмяФайла);
		КонецЕсли;
		
	КонецЦикла;
	
КонецФункции

// Асинхронный вариант (см. Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы)
// 
// Параметры:
//  СтрокаКоманды - см. Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы.СтрокаКоманды
//  ДождатьсяЗавершения - см. Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы.ДождатьсяЗавершения
//  ВозвращатьРезультат - см. Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы.ВозвращатьРезультат
//  ТипОСКэш - см. Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы.ТипОСКэш
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы
//
Асинх Функция ВыполнитьКомандуСистемыАсинх(Знач СтрокаКоманды, Знач ДождатьсяЗавершения = Истина, Знач ВозвращатьРезультат = Истина, Знач ТипОСКэш = Неопределено) Экспорт
	
	Если ВозвращатьРезультат Тогда
		ДождатьсяЗавершения = Истина;
	КонецЕсли;
	
	Если ТипОСКэш <> Неопределено Тогда
		
		Если ТипОСКэш = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows") Тогда
			Возврат ВыполнитьКомандуСистемыАсинх_Windows(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат);
		ИначеЕсли ТипОСКэш = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine") Тогда
			Возврат ВыполнитьКомандуСистемыАсинх_Wine(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат);
		Иначе
			Возврат ВыполнитьКомандуСистемыАсинх_Other(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат);
		КонецЕсли;
		
	ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоWindows() Тогда
		
		Возврат ВыполнитьКомандуСистемыАсинх_Windows(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат);
		
	ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоWine() Тогда
		
		Возврат ВыполнитьКомандуСистемыАсинх_Wine(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат);
		
	Иначе
		
		Возврат ВыполнитьКомандуСистемыАсинх_Other(СтрокаКоманды, ДождатьсяЗавершения, ВозвращатьРезультат);
		
	КонецЕсли;
		
КонецФункции

// Асинхронный вариант (см. ВывестиСостояние)
// 
// Параметры:
//  ТекстСообщения - см. ВывестиСостояние.ТекстСообщения
//  Прогресс - см. ВывестиСостояние.Прогресс
//  Пояснение - см. ВывестиСостояние.Пояснение
//  Картинка - см. ВывестиСостояние.Картинка
//  ВозможностьПрерывания - см. ВывестиСостояние.ВозможностьПрерывания
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Неопределено
//
Асинх Функция ВывестиСостояниеАсинх(Знач ТекстСообщения, Знач Прогресс = 0, Знач Пояснение = "", Знач Картинка = Неопределено,
		Знач ВозможностьПрерывания = Ложь, Кэш = Неопределено) Экспорт
	
	Если ВозможностьПрерывания Тогда
		
		ОбещаниеОбработкиПрерывания = Спец_КомпонентаДополнительныеФункцииКлиент.ОбработкаПрерыванияАсинх(Кэш);
		Спец_СтроковыеФункцииКлиентСервер.ДобавитьСтрокуВТекст("<Для прерывания удерживайте Ctrl + Break>", Пояснение, " ");
		Ждать ОбещаниеОбработкиПрерывания;
		
	КонецЕсли;
	
	НепосредственныйВыводСостояния(ТекстСообщения, Прогресс, Пояснение, Картинка);
	
КонецФункции

// ПолучитьИмяВременногоФайла (по-нормальному)
// 
// Параметры:
//  Расширение - Строка
// 
// Возвращаемое значение:
//  Строка
//
Асинх Функция ПолучитьИмяВременногоФайлаПоНормальномуАсинх(Знач Расширение = "") Экспорт

	#Если ВебКлиент Тогда
		
		Возврат Ждать КаталогВременныхФайловАсинх()
				+ Спец_СтроковыеФункцииКлиентСервер.ОчиститьИмяДляЗапроса(Строка(Новый УникальныйИдентификатор()))
				+ ?(Не ПустаяСтрока(Расширение), "." + Расширение, ".tmp");
	
	#Иначе
		
		Возврат ПолучитьИмяВременногоФайла(Расширение);
		
	#КонецЕсли 

КонецФункции

#Область HTTPЗапросы

// Асинхронный вариант (см. Спец_ОбщегоНазначенияКлиентСервер.ОтправитьHTTPЗапросы)
// 
// Параметры:
//  МассивИлиСтруктураЗапросов - см. Спец_ОбщегоНазначенияКлиентСервер.ОтправитьHTTPЗапросы.МассивИлиСтруктураЗапросов
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначенияКлиентСервер.ОтправитьHTTPЗапросы
//
Асинх Функция ОтправитьHTTPЗапросыАсинх(Знач МассивИлиСтруктураЗапросов, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда
		Кэш = Спец_ПолучитьКэш();
	КонецЕсли;
	
	ТипВходныхДанных        = ТипЗнч(МассивИлиСтруктураЗапросов);
	ВозвращатьОдинРезультат = Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(МассивИлиСтруктураЗапросов, ТипВходныхДанных);
	МассивРезультат         = Новый Массив; // Массив из см. Спец_ОбщегоНазначенияКлиентСервер.НоваяСтруктураРезультатаHTTPЗапроса
	ТаймаутЗапросов         = ?(Кэш.Свойство("ТекущийТаймАутHTTPЗапросов"), 30, Кэш.ТекущийТаймАутHTTPЗапросов);
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивИлиСтруктураЗапросов, ТипВходныхДанных);
	Если МассивИлиСтруктураЗапросов.Количество() = 0 Тогда
		Возврат МассивРезультат;
	КонецЕсли;
	
	Для Каждого СтруктураЗапроса Из МассивИлиСтруктураЗапросов Цикл
		
		СтруктураURIЗапроса = Спец_ОбщегоНазначенияКлиентСервер.СтруктураURI(СтруктураЗапроса.URL);
		
		// С кэшированным соединением происходит какая-то чертовщина (в базах аптеки (8.3.12) при выполнении запроса всегда возвращает последний отправленный запрос).
		// Убираем.
		
		// ++ Спец_БСП.Версия1С_20_ВышеИлиРавно
		HTTPСоединение = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.КэшированноеHTTPСоединение(СтруктураURIЗапроса.Хост,
				СтруктураURIЗапроса.Порт,
				СтруктураURIЗапроса.Логин,
				СтруктураURIЗапроса.Пароль,
				ТаймаутЗапросов,
				СтруктураURIЗапроса.Схема = "https");
		// -- Спец_БСП.Версия1С_20_ВышеИлиРавно
		
		// ++ Спец_БСП.Версия1С_20_Ниже
		////HTTPСоединение = Новый HTTPСоединение(СтруктураURIЗапроса.Хост,
		////		СтруктураURIЗапроса.Порт,
		////		СтруктураURIЗапроса.Логин,
		////		СтруктураURIЗапроса.Пароль,
		////		,
		////		ТаймаутЗапросов,
		////		?(СтруктураURIЗапроса.Схема = "https", Новый ЗащищенноеСоединениеOpenSSL(), Неопределено));
		// -- Спец_БСП.Версия1С_20_Ниже
		
		HTTPЗапрос = Новый HTTPЗапрос(СтруктураURIЗапроса.ПутьНаСервере, СтруктураЗапроса.Заголовки);
		ОбещаниеЗаполнитьТелоЗапроса = Неопределено;
		
		Если Не ПустаяСтрока(СтруктураЗапроса.ИмяФайлаЧтения) Тогда
			HTTPЗапрос.УстановитьИмяФайлаТела(СтруктураЗапроса.ИмяФайлаЧтения);
		Иначе
			ОбещаниеЗаполнитьТелоЗапроса = ЗаполнитьТелоHTTPЗапросаАсинх(HTTPЗапрос, СтруктураЗапроса.ТелоЗапроса);
		КонецЕсли;
		
		СтруктураРезультат = Спец_ОбщегоНазначенияКлиентСервер.НоваяСтруктураРезультатаHTTPЗапроса(СтруктураЗапроса.ИдентификаторЗапроса, СтруктураЗапроса.URL, СтруктураЗапроса.МетодЗапроса);
		HTTPОтвет = Неопределено;
		
		Если ОбещаниеЗаполнитьТелоЗапроса <> Неопределено Тогда
			Ждать ОбещаниеЗаполнитьТелоЗапроса;
		КонецЕсли;
		
		Ждать Спец_КомпонентаДополнительныеФункцииКлиент.НачатьЗамерАсинх("HTTPЗапрос", Кэш);
		Попытка
			
			HTTPОтвет = Ждать HTTPСоединение.ВызватьHTTPМетодАсинх(СтруктураЗапроса.МетодЗапроса, HTTPЗапрос, СтруктураЗапроса.ИмяФайлаРезультат);
			СтруктураРезультат.UnixTimestampОтвета = Ждать Спец_КомпонентаДополнительныеФункцииКлиент.ТекущийUnixTimestampАсинх(Кэш);
			
		Исключение
			
			ТекстОшибки = "";
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(
					Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке()),
					"Спец_ОбщегоНазначенияКлиентСервер.ОтправитьHTTPЗапрос(...)",
					ТекстОшибки);
			
			Если Не ПустаяСтрока(СтруктураЗапроса.ИмяФайлаРезультат) Тогда
				
				#Если Не ВебКлиент Тогда
					
					ЗаписьТекста = Новый ЗаписьТекста(СтруктураЗапроса.ИмяФайлаРезультат, "UTF-8");
					ЗаписьТекста.Записать(ТекстОшибки);
					ЗаписьТекста.Закрыть();
					
					СтруктураРезультат.Вставить("ФайлРезультат", СтруктураЗапроса.ИмяФайлаРезультат);
					
				#КонецЕсли
				
			Иначе
				
				СтруктураРезультат.Вставить("ТелоРезультат", ТекстОшибки);
				
			КонецЕсли;
			
		КонецПопытки;
		СтруктураРезультат.ВремяОтвета = Ждать Спец_КомпонентаДополнительныеФункцииКлиент.ЗавершитьЗамерАсинх("HTTPЗапрос", Кэш);
		
		Если HTTPОтвет <> Неопределено Тогда
			
			СтруктураРезультат.КодОтвета = HTTPОтвет.КодСостояния;
			СтруктураРезультат.Успешно   = HTTPОтвет.КодСостояния >= 200 И HTTPОтвет.КодСостояния < 300;
			
			Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьОбъект(HTTPОтвет.Заголовки, СтруктураРезультат.ЗаголовкиРезультат);
			
			ИмяФайлаРезультат = HTTPОтвет.ПолучитьИмяФайлаТела();
			Если Не ПустаяСтрока(ИмяФайлаРезультат) Тогда
				СтруктураРезультат.Вставить("ФайлРезультат", ИмяФайлаРезультат);
			Иначе
				СтруктураРезультат.Вставить("ТелоРезультат", HTTPОтвет.ПолучитьТелоКакСтроку("UTF-8"));
			КонецЕсли;
			
		КонецЕсли;
		
		МассивРезультат.Добавить(СтруктураРезультат);
		
	КонецЦикла;
	
	Возврат ?(ВозвращатьОдинРезультат, МассивРезультат.Получить(0), МассивРезультат);
	
КонецФункции

// Асинхронный вариант (см. Спец_ОбщегоНазначенияКлиентСервер.ЗаполнитьТелоHTTPЗапроса)
// 
// Параметры:
//  HTTPЗапрос - см. Спец_ОбщегоНазначенияКлиентСервер.ЗаполнитьТелоHTTPЗапроса.HTTPЗапрос
//  ДанныеДляЗапроса - см. Спец_ОбщегоНазначенияКлиентСервер.ЗаполнитьТелоHTTPЗапроса.ДанныеДляЗапроса
//  ИсходныйЗапрос - см. Спец_ОбщегоНазначенияКлиентСервер.ЗаполнитьТелоHTTPЗапроса.ИсходныйЗапрос
//
// Возвращаемое значение:
//  Неопределено
//
Асинх Функция ЗаполнитьТелоHTTPЗапросаАсинх(HTTPЗапрос, Знач ДанныеДляЗапроса, Знач ИсходныйЗапрос = Неопределено) Экспорт
	
	Если ДанныеДляЗапроса = Неопределено Или ДанныеДляЗапроса = "" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	УстанавливатьТипДанных = HTTPЗапрос.Заголовки["Content-Type"] = Неопределено;
	
	ТипДанных = ТипЗнч(ДанныеДляЗапроса);
	Если ТипДанных = Тип("ДвоичныеДанные") Тогда
		
		HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДанныеДляЗапроса);
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ДанныеДляЗапроса, ТипДанных)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ДанныеДляЗапроса, ТипДанных)
		Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(ДанныеДляЗапроса, ТипДанных) Тогда
		
		ТекстДляВозврата = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуПоJSON(ДанныеДляЗапроса, Ложь);
		Если ПустаяСтрока(ТекстДляВозврата) Тогда
			
			HTTPЗапрос.УстановитьТелоИзСтроки(СокрЛП(ДанныеДляЗапроса));
			
			Если УстанавливатьТипДанных Тогда
				HTTPЗапрос.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
			КонецЕсли;
			
		Иначе
			
			HTTPЗапрос.УстановитьТелоИзСтроки(ТекстДляВозврата);
			
			Если УстанавливатьТипДанных Тогда
				HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
			КонецЕсли;
			
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ФайловыйПоток") Тогда
		
		HTTPЗапрос.УстановитьИмяФайлаТела(ДанныеДляЗапроса.ИмяФайла);
		ОбещаниеЗакрытияПотока = ДанныеДляЗапроса.ЗакрытьАсинх();
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
		Ждать ОбещаниеЗакрытияПотока;
		
	ИначеЕсли ТипДанных = Тип("Файл") Тогда
		
		HTTPЗапрос.УстановитьИмяФайлаТела(ДанныеДляЗапроса.ПолноеИмя);
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ПотокВПамяти") Тогда
		
		ДанныеДляЗапроса.Перейти(0, ПозицияВПотоке.Начало);
		HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДанныеДляЗапроса.ЗакрытьИПолучитьДвоичныеДанные());
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ЗаписьJSON") Тогда
		
		HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеДляЗапроса.Закрыть(), "UTF-8");
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ЗаписьXML") Тогда
		
		HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеДляЗапроса.Закрыть(), "UTF-8");
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/xml;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("Строка") Тогда
		
		HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеДляЗапроса, "UTF-8");
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных = Тип("ИнформацияОбОшибке") Тогда
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ДанныеДляЗапроса, "HTTP запрос", ТекстДляВозврата);
		
		Если ИсходныйЗапрос <> Неопределено Тогда
			
			Спец_СтроковыеФункцииКлиентСервер.ДобавитьСтрокуВТекст(Спец_СтроковыеФункцииКлиентСервер.СформироватьТекстовоеПредставлениеОбъекта(ИсходныйЗапрос, Символы.Таб),
					ТекстДляВозврата,
					Символы.ПС + Символы.ПС);
			
		КонецЕсли;
		
		HTTPЗапрос.УстановитьТелоИзСтроки(ТекстДляВозврата, "UTF-8");
		
		Если УстанавливатьТипДанных Тогда
			HTTPЗапрос.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
		КонецЕсли;
		
	ИначеЕсли ТипДанных <> Тип("Неопределено") Тогда
		
		ДляПередачи = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(ДанныеДляЗапроса);
		Если ПустаяСтрока(ДляПередачи) Тогда
			ДляПередачи = Строка(ДанныеДляЗапроса);
		КонецЕсли;
		
		Если Не ПустаяСтрока(ДляПередачи) Тогда
			
			HTTPЗапрос.УстановитьТелоИзСтроки(ДляПередачи, "UTF-8");
			Если УстанавливатьТипДанных Тогда
				HTTPЗапрос.Заголовки.Вставить("Content-Type", "text/plain;charset=utf-8");
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#КонецОбласти

// -- Спец_БСП.Версия1С_18_ВышеИлиРавно

#Область ОбработчикиСобытий

// Выполнить стандартные действия перед началом работы пользователя с областью данных, либо в локальном режиме работы.
// Предназначена для вызова из обработчика ПередНачаломРаботыСистемы модулей управляемого и обычного приложения.
//
// Параметры:
//  Отказ - Булево - Флаг отказа начала работы.
Процедура ПередНачаломРаботыСистемы(Отказ = Ложь) Экспорт
	
	// Режим запуска
	#Если ТонкийКлиент Или ВебКлиент Тогда
		
		РежимЗапуска = Спец_ОбщегоНазначенияВызовСервера.ПолучитьРежимЗапускаТекущегоПользователя();
		Если РежимЗапуска = ПредопределенноеЗначение("Перечисление.Спец_РежимыОсновногоОкна.ВстроенноеРабочееМесто") Тогда
			
			// ++ Спец_БСП.Версия1С_16_ВышеИлиРавно
			КлиентскоеПриложение.УстановитьРежимОсновногоОкна(РежимОсновногоОкнаКлиентскогоПриложения.ВстроенноеРабочееМесто);
			// -- Спец_БСП.Версия1С_16_ВышеИлиРавно
			
		ИначеЕсли РежимЗапуска = ПредопределенноеЗначение("Перечисление.Спец_РежимыОсновногоОкна.Киоск") Тогда
			
			КлиентскоеПриложение.УстановитьРежимОсновногоОкна(РежимОсновногоОкнаКлиентскогоПриложения.Киоск);
			
		ИначеЕсли РежимЗапуска = ПредопределенноеЗначение("Перечисление.Спец_РежимыОсновногоОкна.ПолноэкранноеРабочееМесто") Тогда
			
			КлиентскоеПриложение.УстановитьРежимОсновногоОкна(РежимОсновногоОкнаКлиентскогоПриложения.ПолноэкранноеРабочееМесто);
			
		ИначеЕсли РежимЗапуска = ПредопределенноеЗначение("Перечисление.Спец_РежимыОсновногоОкна.РабочееМесто") Тогда
			
			КлиентскоеПриложение.УстановитьРежимОсновногоОкна(РежимОсновногоОкнаКлиентскогоПриложения.РабочееМесто);
			
		КонецЕсли;
		
	#КонецЕсли
	
КонецПроцедуры

// Выполнить стандартные действия при начале работы пользователя с областью данных, либо в локальном режиме работы.
// Предназначена для вызова из обработчика ПриНачалеРаботыСистемы модулей управляемого и обычного приложения.
Процедура ПриНачалеРаботыСистемы() Экспорт
	
	// ++ Спец_БСП.ПодключаемоеОборудование
	// ПодключаемоеОборудование
	МенеджерОборудованияКлиент.ПриНачалеРаботыСистемы();
	// Конец ПодключаемоеОборудование
	// -- Спец_БСП.ПодключаемоеОборудование
	
	// ++ Спец_БСП.Версия1С_18_ВышеИлиРавно
	ПриНачалеРаботыСистемыАсинх();
	// -- Спец_БСП.Версия1С_18_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_18_Ниже
	////ПриНачалеРаботыСистемыСинх();
	// -- Спец_БСП.Версия1С_18_Ниже
	
КонецПроцедуры

// Выполнить стандартные действия при завершением работы пользователя с областью данных, либо в локальном режиме работы.
// Предназначена для вызова из обработчика ПриЗавершенииРаботыСистемы модулей управляемого и обычного приложения.
Процедура ПриЗавершенииРаботыСистемы() Экспорт
	// Придумать как записать лог завершение сеанса
	
КонецПроцедуры

// ++ Спец_БСП.Версия1С_17_ВышеИлиРавно

// Выполнить стандартные действия при обработке отображения ошибки с областью данных, либо в локальном режиме работы.
// Предназначена для вызова из обработчика ОбработкаОтображенияОшибки модуля управляемого приложения.
// 
// Параметры:
//  ИнформацияОбОшибке - ИнформацияОбОшибке
//  ТребуетсяЗавершениеСеанса - Булево
//  СтандартнаяОбработка - Булево
//
Процедура ОбработкаОтображенияОшибки(Знач ИнформацияОбОшибке, Знач ТребуетсяЗавершениеСеанса, СтандартнаяОбработка) Экспорт
	
	СтандартнаяОбработка = Ложь;
	
	МассивДополнительнаяИнформация = Новый Массив; // Массив из Строка
	МассивДополнительнаяИнформация.Добавить(Символы.ПС + "Ошибка зарегистрирована в общий регистр ошибок.");
	
	Если ТребуетсяЗавершениеСеанса Тогда
		МассивДополнительнаяИнформация.Добавить(Символы.ПС + "Сеанс будет завершён!");
	КонецЕсли;
	
	ОбработкаОшибок.ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке,
			ОбработкаОшибок.СообщениеОбОшибкеДляПользователя(ИнформацияОбОшибке),
			Новый ФорматированнаяСтрока(МассивДополнительнаяИнформация, Спец_ОбщегоНазначенияКлиентПовтИсп.ПолучитьШрифтСтиля("Спец_ШрифтВыделениеЖирным")),
			Ложь);
	
	// ++ Спец_БСП.Версия1С_18_ВышеИлиРавно
	ЗаписатьОшибкуВРегистрАсинх(ИнформацияОбОшибке, СтандартнаяОбработка);
	// -- Спец_БСП.Версия1С_18_ВышеИлиРавно
	
	// ++ Спец_БСП.Версия1С_18_Ниже
	////ЗаписатьОшибкуВРегистр(ИнформацияОбОшибке, СтандартнаяОбработка);
	// -- Спец_БСП.Версия1С_18_Ниже
	
КонецПроцедуры

// -- Спец_БСП.Версия1С_17_ВышеИлиРавно

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Возвращаемое значение:
//  см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
Функция ПолучитьКэш() Экспорт
	
	Возврат Спец_КэшКлиент;
	
КонецФункции

//@skip-check missing-temporary-file-deletion
// Удаление файлов происходит внутри скрипта (самоуничтожение)
// 
// Параметры:
//  СтруктураУведомления - см. Спец_ОбщегоНазначения.ПолучитьСтруктуруУведомленияДляОтправкиТекущемуПользователю
//
Процедура ОтправитьУведомлениеПользователю(Знач СтруктураУведомления) Экспорт
	
	ТекстЗаголовка = СтрШаблон(НСтр("ru = 'Сообщение от %1 (%2)'"), СтруктураУведомления.Отправитель, Формат(СтруктураУведомления.Период, "ДЛФ=DDT"));
	
	#Если ВебКлиент Тогда
		
		Если СтруктураУведомления.ТипУведомления = ПредопределенноеЗначение("Перечисление.Спец_ТипыУведомленийПользователя.Оповещение1С") Тогда
			
			ПоказатьОповещениеПользователя(СтруктураУведомления.ТекстСообщения,
					СтруктураУведомления.ДействиеПриНажатииДляОповещения1С,
					ТекстЗаголовка,
					БиблиотекаКартинок.Спец_НижегородскаяАптечнаяСеть,
					СтатусОповещенияПользователя.Важное);
					
		Иначе
			
			ШаблонДляОтправки = НСтр("ru = '%1%2%2%3'");
			ТекстДляОтправки = СтрШаблон(ШаблонДляОтправки, ТекстЗаголовка, Символы.ПС, СтруктураУведомления.ТекстСообщения);
			
			СообщитьПользователю(ТекстДляОтправки);
			
		КонецЕсли;
		
	#Иначе
		
		Если СтруктураУведомления.ТипУведомления = ПредопределенноеЗначение("Перечисление.Спец_ТипыУведомленийПользователя.Оповещение1С") Тогда
		
			ПоказатьОповещениеПользователя(СтруктураУведомления.ТекстСообщения,
					СтруктураУведомления.ДействиеПриНажатииДляОповещения1С,
					ТекстЗаголовка,
					БиблиотекаКартинок.Спец_НижегородскаяАптечнаяСеть,
					СтатусОповещенияПользователя.Важное);
			
		ИначеЕсли СтруктураУведомления.ТипУведомления = ПредопределенноеЗначение("Перечисление.Спец_ТипыУведомленийПользователя.ОшибкаОС") Тогда
			
			Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоWindows() Тогда
				
				ИмяФайла = ПолучитьИмяВременногоФайла("ps1");
				ШаблонСкрипта =
				
				"Add-Type -AssemblyName System.Windows.Forms
				|[System.Windows.Forms.MessageBox]::Show('%1', '%2', 'OK', 'Error', 'Button1')
				|Remove-Item ""%3""";
				
				ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, КодировкаТекста.ANSI, Символы.ПС, , Символы.ПС);
				ЗаписьТекста.Записать(СтрШаблон(ШаблонСкрипта, СтруктураУведомления.ТекстСообщения, ТекстЗаголовка, ИмяФайла));
				ЗаписьТекста.Закрыть();
				
				Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы(СтрШаблон("powershell -executionpolicy RemoteSigned -file ""%1""", ИмяФайла), Ложь, Ложь);
				
			ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоLinux() Тогда
				
				ИмяФайла = ПолучитьИмяВременногоФайла("sh");
				ШаблонСкрипта =
				
				"zenity --error --text '%1' --title '%2'
				|rm '%3'";
				
				ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, "CESU-8", Символы.ПС, , Символы.ПС);
				ЗаписьТекста.ЗаписатьСтроку("");
				ЗаписьТекста.ЗаписатьСтроку(СтрШаблон(ШаблонСкрипта, СтруктураУведомления.ТекстСообщения, ТекстЗаголовка, ИмяФайла));
				ЗаписьТекста.Закрыть();
				
				Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы(СтрШаблон("sh '%1'", ИмяФайла), Ложь, Ложь);
				
			КонецЕсли;
			
		ИначеЕсли СтруктураУведомления.ТипУведомления = ПредопределенноеЗначение("Перечисление.Спец_ТипыУведомленийПользователя.Сообщение1С") Тогда
			
			ШаблонДляОтправки = НСтр("ru = '%1%2%2%3'");
			ТекстДляОтправки = СтрШаблон(ШаблонДляОтправки, ТекстЗаголовка, Символы.ПС, СтруктураУведомления.ТекстСообщения);
			
			СообщитьПользователю(ТекстДляОтправки);
			
		ИначеЕсли СтруктураУведомления.ТипУведомления = ПредопределенноеЗначение("Перечисление.Спец_ТипыУведомленийПользователя.СообщениеОС") Тогда
			
			Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоWindows() Тогда
				
				ИмяФайла = ПолучитьИмяВременногоФайла("ps1");
				ШаблонСкрипта =
					
				"Add-Type -AssemblyName System.Windows.Forms
				|[System.Windows.Forms.MessageBox]::Show('%1', '%2', 'OK', 'Warning', 'Button1')
				|Remove-Item ""%3""";
				
				ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, КодировкаТекста.ANSI);
				ЗаписьТекста.Записать(СтрШаблон(ШаблонСкрипта, СтруктураУведомления.ТекстСообщения, ТекстЗаголовка, ИмяФайла));
				ЗаписьТекста.Закрыть();
				
				Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы(СтрШаблон("powershell -executionpolicy RemoteSigned -file ""%1""", ИмяФайла), Ложь, Ложь);
				
			ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоLinux() Тогда
				
				ИмяФайла = ПолучитьИмяВременногоФайла("sh");
				ШаблонСкрипта =
					
				"zenity --info --text '%1' --title '%2'
				|rm '%3'";
				
				ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, "CESU-8", Символы.ПС, , Символы.ПС);
				ЗаписьТекста.ЗаписатьСтроку("");
				ЗаписьТекста.ЗаписатьСтроку(СтрШаблон(ШаблонСкрипта, СтруктураУведомления.ТекстСообщения, ТекстЗаголовка, ИмяФайла));
				ЗаписьТекста.Закрыть();
				
				Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы(СтрШаблон("sh '%1'", ИмяФайла), Ложь, Ложь);
				
			КонецЕсли;
			
		ИначеЕсли СтруктураУведомления.ТипУведомления = ПредопределенноеЗначение("Перечисление.Спец_ТипыУведомленийПользователя.УведомлениеОС") Тогда
			
			Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоWindows() Тогда
				
				ИмяФайла = ПолучитьИмяВременногоФайла("ps1");
				ШаблонСкрипта =
					
				"$Title  = '%1'
				|$Text   = '%2'
				|$Sender = '%3'
				|
				|[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null
				|$ToastTemplate = [Windows.UI.Notifications.ToastTemplateType]::ToastText02 
				|$toastXml = [xml] $([Windows.UI.Notifications.ToastNotificationManager]::GetTemplateContent($ToastTemplate)).GetXml()
				|
				|$toastXml.GetElementsByTagName(“text”)[0].AppendChild($toastXml.CreateTextNode($Title)) | Out-Null
				|$toastXml.GetElementsByTagName(“text”)[1].AppendChild($toastXml.CreateTextNode($Text)) | Out-Null
				|
				|$xml = New-Object Windows.Data.Xml.Dom.XmlDocument
				|$xml.LoadXml($toastXml.OuterXml)
				|
				|$toast = [Windows.UI.Notifications.ToastNotification]::new($xml)
				|$toast.Tag = $Sender
				|$toast.Group = $Sender
				|$toast.ExpirationTime = [DateTimeOffset]::Now.AddMinutes(5)
				|
				|$notifier = [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier($Sender)
				|$notifier.Show($toast);
				|
				|Remove-Item ""%4""";
				
				ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, КодировкаТекста.ANSI);
				
				#Если ТолстыйКлиентОбычноеПриложение Тогда
				
					ЗаписьТекста.Записать(СтрШаблон(ШаблонСкрипта,
							ТекстЗаголовка,
							СтруктураУведомления.ТекстСообщения,
							Спец_ОбщегоНазначенияПовтИсп.СтруктураПараметровБазы().НаименованиеБазы,
							ИмяФайла));
							
				#Иначе
					
					ЗаписьТекста.Записать(СтрШаблон(ШаблонСкрипта,
							ТекстЗаголовка,
							СтруктураУведомления.ТекстСообщения,
							Спец_ОбщегоНазначенияВызовСервера.СтруктураПараметровБазы().НаименованиеБазы,
							ИмяФайла));
					
				#КонецЕсли
				
				ЗаписьТекста.Закрыть();
				Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы(СтрШаблон("powershell -executionpolicy RemoteSigned -file ""%1""", ИмяФайла), Ложь, Ложь);
				
			ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоLinux() Тогда
				
				ИмяФайла = ПолучитьИмяВременногоФайла("sh");
				ШаблонСкрипта =
					
					"notify-send --urgency normal '%1' '%2'
					|rm '%3'";
				
				ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, "CESU-8", Символы.ПС, , Символы.ПС);
				ЗаписьТекста.ЗаписатьСтроку("");
				ЗаписьТекста.ЗаписатьСтроку(СтрШаблон(ШаблонСкрипта, ТекстЗаголовка, СтруктураУведомления.ТекстСообщения, ИмяФайла));
				ЗаписьТекста.Закрыть();
				
				Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы(СтрШаблон("sh '%1'", ИмяФайла), Ложь, Ложь);
				
			КонецЕсли;
			
		КонецЕсли;
		
	#КонецЕсли
	
КонецПроцедуры

// @skip-check module-empty-method
// 
// Параметры:
//  Параметр1 - Произвольный
Процедура ОписаниеОповещенияЗаглушкаСОднимПараметром(Знач Параметр1 = Неопределено) Экспорт
	
КонецПроцедуры

//@skip-check module-empty-method
// 
// Параметры:
//  Параметр1 - Произвольный
//  Параметр2 - Произвольный
Процедура ОписаниеОповещенияЗаглушкаСДвумяПараметрами(Знач Параметр1 = Неопределено, Знач Параметр2 = Неопределено) Экспорт
	
КонецПроцедуры

// Параметры:
//  ОписаниеОповещенияПослеПоказа - ОписаниеОповещения
Процедура ПоказатьВопросДляДолгойОбработкиСБлокировкой(Знач ОписаниеОповещенияПослеПоказа) Экспорт
	
	//@skip-check invocation-parameter-type-intersect
	ПоказатьВопрос(ОписаниеОповещенияПослеПоказа,
			ТекстСообщенияДолгаяОбработкаСБлокировкой(),
			РежимДиалогаВопрос.ДаНет,
			30,
			КодВозвратаДиалога.Нет,
			"ВНИМАНИЕ",
			КодВозвратаДиалога.Нет);
	
КонецПроцедуры

#Область ВыполнениеКомандыСистемы

// Параметры:
//  СтрокаКоманды - Строка
//  ДождатьсяЗавершения - Булево
//  ВозвращатьРезультат - Булево
//  ОписаниеОповещенияРезультат - ОписаниеОповещения
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом
Функция ВыполнитьКомандуСистемы_Windows(Знач СтрокаКоманды, Знач ДождатьсяЗавершения, Знач ВозвращатьРезультат, Знач ОписаниеОповещенияРезультат) Экспорт
	
	Если ВозвращатьРезультат Тогда
		
		// Маздай не умеет в UTF-8 при выводе в файл
		ДополнительныеПараметры = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКоманды("cp866", ОписаниеОповещенияРезультат);
		
		СтрокаКоманды = СтрШаблон("cmd /d /U /C ""%1 > ""%2"" 2>&1""", СтрокаКоманды, ДополнительныеПараметры.ВременныйФайл);
		Если ОписаниеОповещенияРезультат = Неопределено Тогда // Пытаемся через Wscript (чтобы без отображения консоли)
			
			Попытка
				
				WShell = Новый COMОбъект("Wscript.Shell");
				WShell.Run(СтрокаКоманды, 0, ДождатьсяЗавершения);
				
				ДополнительныеПараметры.КодировкаДляЧтения = КодировкаТекста.UTF16;
				Возврат Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом(0, ДополнительныеПараметры);
				
			Исключение
				
				Спец_ЗаписатьЛог("ВыполнитьКомандуСистемы Windows (через Wscript)",
						ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
						ИнформацияОбОшибке());
				
			КонецПопытки;
			
		КонецЕсли;
		
		Если ОписаниеОповещенияРезультат <> Неопределено Тогда
			
			ОписаниеОповещенияПослеВыполнения = Новый ОписаниеОповещения("ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом", Спец_ОбщегоНазначенияКлиентСервер, ДополнительныеПараметры);
			//@skip-check invocation-parameter-type-intersect
			НачатьЗапускПриложения(ОписаниеОповещенияПослеВыполнения, СтрокаКоманды, , ДождатьсяЗавершения);
			
			Возврат Истина;
			
		Иначе
			
			Попытка
				
				ЗапуститьПриложение(СтрокаКоманды, , ДождатьсяЗавершения);
				
			Исключение
				
				ТекстОшибки = "";
				Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(),
						"Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Windows(...)",
						ТекстОшибки);
				
				#Если Не ВебКлиент Тогда
					
					ЗаписьТекста = Новый ЗаписьТекста(ДополнительныеПараметры.ВременныйФайл, ДополнительныеПараметры.КодировкаДляЧтения, Символы.ПС);
					ЗаписьТекста.Записать(ТекстОшибки);
					ЗаписьТекста.Закрыть();
					
				#Иначе
					
					ВызватьИсключение ТекстОшибки;
					
				#КонецЕсли
				
			КонецПопытки;
			
			Возврат Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом(0, ДополнительныеПараметры);
			
		КонецЕсли;
		
	Иначе
		
		СтрокаКоманды = СтрШаблон("cmd /d /C ""%1""", СтрокаКоманды);
		Если ОписаниеОповещенияРезультат = Неопределено Тогда // Пытаемся через Wscript (чтобы без отображения консоли)
			
			Попытка
				
				WShell = Новый COMОбъект("Wscript.Shell");
				WShell.Run(СтрокаКоманды, 0, ДождатьсяЗавершения);
				
				Возврат Истина;
				
			Исключение
				
				Спец_ЗаписатьЛог("ВыполнитьКомандуСистемы Windows (через Wscript)",
						ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
						ИнформацияОбОшибке());
				
			КонецПопытки;
			
		КонецЕсли;
		
		Если ОписаниеОповещенияРезультат <> Неопределено Тогда
			
			//@skip-check invocation-parameter-type-intersect
			НачатьЗапускПриложения(ОписаниеОповещенияРезультат, СтрокаКоманды, , ДождатьсяЗавершения);
			
		Иначе
			
			ЗапуститьПриложение(СтрокаКоманды, , ДождатьсяЗавершения);
			
		КонецЕсли;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  СтрокаКоманды - Строка
//  ДождатьсяЗавершения - Булево
//  ВозвращатьРезультат - Булево
//  ОписаниеОповещенияРезультат - ОписаниеОповещения
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом
Функция ВыполнитьКомандуСистемы_Wine(Знач СтрокаКоманды, Знач ДождатьсяЗавершения, Знач ВозвращатьРезультат, Знач ОписаниеОповещенияРезультат) Экспорт
	
	Если ВозвращатьРезультат Тогда
		
		ДополнительныеПараметры = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКоманды(, ОписаниеОповещенияРезультат);
		
		СтрокаКоманды = СтрШаблон("wineconsole cmd /d /U /C ""%1 > ""%2"" 2>&1""", СтрокаКоманды, ДополнительныеПараметры.ВременныйФайл);
		Если ОписаниеОповещенияРезультат <> Неопределено Тогда
			
			ОписаниеОповещенияПослеВыполнения = Новый ОписаниеОповещения("ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом", Спец_ОбщегоНазначенияКлиентСервер, ДополнительныеПараметры);
			//@skip-check invocation-parameter-type-intersect
			НачатьЗапускПриложения(ОписаниеОповещенияПослеВыполнения, СтрокаКоманды, , ДождатьсяЗавершения);
			
			Возврат Истина;
			
		Иначе
			
			Попытка
				
				ЗапуститьПриложение(СтрокаКоманды, , ДождатьсяЗавершения);
				
			Исключение
				
				ТекстОшибки = "";
				Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(),
						"Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Wine(...)",
						ТекстОшибки);
				
				#Если Не ВебКлиент Тогда
					
					ЗаписьТекста = Новый ЗаписьТекста(ДополнительныеПараметры.ВременныйФайл, ДополнительныеПараметры.КодировкаДляЧтения, Символы.ПС);
					ЗаписьТекста.Записать(ТекстОшибки);
					ЗаписьТекста.Закрыть();
					
				#Иначе
					
					ВызватьИсключение ТекстОшибки;
					
				#КонецЕсли
				
			КонецПопытки;
			
			Возврат Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом(0, ДополнительныеПараметры);
			
		КонецЕсли;
		
	Иначе
		
		СтрокаКоманды = СтрШаблон("wineconsole cmd /d /C ""%1""", СтрокаКоманды);
		Если ОписаниеОповещенияРезультат <> Неопределено Тогда
			
			//@skip-check invocation-parameter-type-intersect
			НачатьЗапускПриложения(ОписаниеОповещенияРезультат, СтрокаКоманды, , ДождатьсяЗавершения);
			
		Иначе
			
			ЗапуститьПриложение(СтрокаКоманды, , ДождатьсяЗавершения);
			
		КонецЕсли;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  СтрокаКоманды - Строка
//  ДождатьсяЗавершения - Булево
//  ВозвращатьРезультат - Булево
//  ОписаниеОповещенияРезультат - ОписаниеОповещения
// 
// Возвращаемое значение:
//  см. Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом
Функция ВыполнитьКомандуСистемы_Other(Знач СтрокаКоманды, Знач ДождатьсяЗавершения, Знач ВозвращатьРезультат, Знач ОписаниеОповещенияРезультат) Экспорт
	
	Если ВозвращатьРезультат Тогда
		
		ДополнительныеПараметры = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКоманды(, ОписаниеОповещенияРезультат);
		
		// Выполняем cmd с параметрами
		СтрокаКоманды = СтрШаблон("%1 > '%2' 2>&1", СтрокаКоманды, ДополнительныеПараметры.ВременныйФайл);
		Если ОписаниеОповещенияРезультат <> Неопределено Тогда
			
			ОписаниеОповещенияПослеВыполнения = Новый ОписаниеОповещения("ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом", Спец_ОбщегоНазначенияКлиентСервер, ДополнительныеПараметры);
			//@skip-check invocation-parameter-type-intersect
			НачатьЗапускПриложения(ОписаниеОповещенияПослеВыполнения, СтрокаКоманды, , ДождатьсяЗавершения);
			
			Возврат Истина;
			
		Иначе
			
			Попытка
				
				ЗапуститьПриложение(СтрокаКоманды, , ДождатьсяЗавершения);
				
			Исключение
				
				ТекстОшибки = "";
				Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(),
						"Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Other(...)",
						ТекстОшибки);
				
				#Если Не ВебКлиент Тогда
					
					ЗаписьТекста = Новый ЗаписьТекста(ДополнительныеПараметры.ВременныйФайл, ДополнительныеПараметры.КодировкаДляЧтения, Символы.ПС);
					ЗаписьТекста.Записать(ТекстОшибки);
					ЗаписьТекста.Закрыть();
					
				#Иначе
					
					ВызватьИсключение ТекстОшибки;
					
				#КонецЕсли
				
			КонецПопытки;
			
			Возврат Спец_ОбщегоНазначенияКлиентСервер.ВыполнитьКомандуСистемы_ПослеВыполненияСРезультатом(0, ДополнительныеПараметры);
			
		КонецЕсли;
		
	ИначеЕсли ОписаниеОповещенияРезультат <> Неопределено Тогда
		
		//@skip-check invocation-parameter-type-intersect
		НачатьЗапускПриложения(ОписаниеОповещенияРезультат, СтрокаКоманды, , ДождатьсяЗавершения);
		
		Возврат Истина;
		
	Иначе
		
		ЗапуститьПриложение(СтрокаКоманды, , ДождатьсяЗавершения);
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура УстановитьЗначенияПеременныхПоСоответствию(Знач СоответствиеДляУстановки)
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Спец_ОбщегоНазначения.УстановитьМассивЗначенийПеременных(СоответствиеДляУстановки);
	#Иначе
		Спец_ОбщегоНазначенияВызовСервера.УстановитьМассивЗначенийПеременных(СоответствиеДляУстановки);
	#КонецЕсли
	
КонецПроцедуры

// Возвращаемое значение:
//  ФорматированнаяСтрока
Функция ТекстСообщенияДолгаяОбработкаСБлокировкой()
	
	МассивФорматированнаяСтрока = Новый Массив; // Массив из Строка
	МассивФорматированнаяСтрока.Добавить("Обработка займет приличное количество времени (от 5-10 минут, в зависимости от размера базы)");
	МассивФорматированнаяСтрока.Добавить(Символы.ПС);
	МассивФорматированнаяСтрока.Добавить(Новый ФорматированнаяСтрока("ЖЕЛАТЕЛЬНО УСТАНОВИТЬ БЛОКИРОВКУ ВХОДА В БАЗУ", , WebЦвета.Красный));
	МассивФорматированнаяСтрока.Добавить(", так как ВСЕ таблицы будут поочерёдно заблокированы (реиндексация, кластеризация, и т.п.)");
	МассивФорматированнаяСтрока.Добавить(Символы.ПС);
	МассивФорматированнаяСтрока.Добавить("Вы уверены, что хотите продолжить?");
	
	Возврат Новый ФорматированнаяСтрока(МассивФорматированнаяСтрока);
	
КонецФункции

Процедура НепосредственныйВыводСостояния(Знач ТекстСообщения, Знач Прогресс, Знач Пояснение, Знач Картинка)
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		
		МассивТекстСостояния = Новый Массив; // Массив из Строка
		Если Прогресс Тогда
			МассивТекстСостояния.Добавить(Формат(Прогресс, "ЧЦ=5; ЧДЦ=2; ЧН=0; ЧГ=; ЧФ='Ч% - '"));
		КонецЕсли;
		
		МассивТекстСостояния.Добавить(ТекстСообщения);
		Если Не ПустаяСтрока(Пояснение) Тогда
			МассивТекстСостояния.Добавить(СтрШаблон(" (%1)", Пояснение));
		КонецЕсли;
		
		Состояние(СтрСоединить(МассивТекстСостояния, ""));
		
	#Иначе
		
		Состояние(ТекстСообщения, Прогресс, Пояснение, Картинка);
		
	#КонецЕсли
	
КонецПроцедуры

#Область ОбработчикиСобытий

// ++ Спец_БСП.Версия1С_18_Ниже
////Процедура ПриНачалеРаботыСистемыСинх()
////	
////	// Ставим важные клиентские параметры.
////	СоответствиеДляУстановки = Новый Соответствие;
////	СоответствиеДляУстановки["ЭтоНачалоРаботы1С"] = Истина; // На случай переполнения стека
////	СоответствиеДляУстановки["ОперационнаяСистемаКлиент"] = Спец_ОбщегоНазначенияКлиентСервер.РассчитатьТипОС();
////	
////	#Если Не ВебКлиент Тогда
////		СоответствиеДляУстановки["ИмяКомпьютераКлиент"] = ИмяКомпьютера();
////	#Иначе
////		СоответствиеДляУстановки["ИмяКомпьютераКлиент"] = "WEB-client";
////	#КонецЕсли
////	
////	СоответствиеДляУстановки["ИмяПользователяОСКлиент"] = Спец_ОбщегоНазначенияКлиентСервер.ВычислитьТекущегоПользователяСистемы(СоответствиеДляУстановки["ОперационнаяСистемаКлиент"]);
////	
////	#Если ТолстыйКлиентОбычноеПриложение Тогда
////		СтруктураПараметров = Спец_ОбщегоНазначения.ПолучитьСтруктуруПараметровДляЗапуска(СоответствиеДляУстановки);
////	#Иначе
////		СтруктураПараметров = Спец_ОбщегоНазначенияВызовСервера.ПолучитьСтруктуруПараметровДляЗапуска(СоответствиеДляУстановки);
////	#КонецЕсли
////	
////	// Уведомления пользователям
////	Если СтруктураПараметров.ВключитьУведомленияПользователей Тогда
////		ПодключитьОбработчикОжидания("Спец_ОбработчикОжиданияОтправкаУведомлений", СтруктураПараметров.ПериодОбновленияНовыхУведомлений);
////	КонецЕсли;
////	
////	// А не пора ли заканчивать
////	Если СтруктураПараметров.ПодключатьОбработчикЗавершенияРаботыПользователей Тогда
////		ПодключитьОбработчикОжидания("Спец_АНеПораЛиЗаканчивать", Спец_КонстантыКлиентСервер.СекундВМинуте());
////	КонецЕсли;
////	
////	// Заголовок базы
////	Если СтруктураПараметров.УстанавливатьЗаголовокБазы Тогда
////		КлиентскоеПриложение.УстановитьЗаголовок(СтруктураПараметров.ЗаголовокДляУстановки);
////	КонецЕсли;
////	
////	Спец_КомпонентаДополнительныеФункцииКлиент.ОбработатьПереустановкуКомпонент(СтруктураПараметров.СоответствиеКомпонентДляПереустановки);
////	
////	СоответствиеДляУстановки = Новый Соответствие;
////	СоответствиеДляУстановки["ЭтоНачалоРаботы1С"] = Ложь;
////	
////	УстановитьЗначенияПеременныхПоСоответствию(СоответствиеДляУстановки);
////	ОбновитьПовторноИспользуемыеЗначения();
////	
////	Если СтруктураПараметров.СоответствиеКомпонентДляПереустановки["ОбщийМакет.Спец_КомпонентаLykovPostgreSQL"] = Неопределено Тогда
////		Спец_ЗаписатьЛог("Начало сеанса", ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"), "Начало сеанса");
////	КонецЕсли;
////	
////КонецПроцедуры
////
////// Параметры:
//////  ИнформацияОбОшибке - ИнформацияОбОшибке
//////  СтандартнаяОбработка - Булево
//////
////Процедура ЗаписатьОшибкуВРегистр(Знач ИнформацияОбОшибке, СтандартнаяОбработка)
////	// Так как может быть ошибка при завершении сеанса, то всё через попытку (серверные вызовы запрещены).
////	
////	Кэш = Спец_ПолучитьКэш();
////	Попытка
////		
////		Скриншот = Неопределено; // ДвоичныеДанные
////		
////		//@skip-check unknown-method-property
////		Попытка
////			
////			Скриншот = Спец_КомпонентаДополнительныеФункцииКлиент.ПолучитьСкриншотЭкрана(, Кэш);
////			
////		Исключение
////			
////			Спец_ЗаписатьЛог("Запись ошибки в регистр",
////					ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Ошибка"),
////					ИнформацияОбОшибке(),
////					Кэш);
////			
////		КонецПопытки;
////		
////		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
////			Спец_ОбщегоНазначенияВызовСервера.ЗаписатьОшибки("Пользовательская ошибка: " + Спец_ОбщегоНазначенияКлиентСервер.ТекущийПользователь1СПолноеИмя(), ИнформацияОбОшибке, , , Истина, Скриншот);
////		#Иначе
////			Спец_ОбщегоНазначения.ЗаписатьОшибки("Пользовательская ошибка: " + Спец_ОбщегоНазначенияКлиентСервер.ТекущийПользователь1СПолноеИмя(), ИнформацияОбОшибке, , , , Скриншот);
////		#КонецЕсли
////		
////	Исключение
////		
////		СтандартнаяОбработка = Истина;
////		
////		// Для отладки
////		//@skip-check module-unused-local-variable
////		ОшибкаПриВыводеОшибок = Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке);
////		
////	КонецПопытки;
////	
////КонецПроцедуры
// -- Спец_БСП.Версия1С_18_Ниже

// ++ Спец_БСП.Версия1С_18_ВышеИлиРавно
#Область АсинхронныеАналоги

Асинх Процедура ПриНачалеРаботыСистемыАсинх()
	
	ОбещаниеРассчетТипОС = РассчитатьТипОСАсинх();
	
	// Ставим важные клиентские параметры.
	СоответствиеДляУстановки = Новый Соответствие;
	
	#Если Не ВебКлиент Тогда
		
		СоответствиеДляУстановки["ИмяКомпьютераКлиент"] = ИмяКомпьютера();
		
	#Иначе
		
		СоответствиеДляУстановки["ИмяКомпьютераКлиент"] = "WEB-client";
		
		УспешноУстановлено = Ждать ПодключитьРасширениеРаботыСФайламиАсинх();
		Если Не УспешноУстановлено Тогда
			
			Ждать УстановитьРасширениеРаботыСФайламиАсинх();
			УспешноУстановлено = Ждать ПодключитьРасширениеРаботыСФайламиАсинх();
			
		КонецЕсли;
		
		Если Не УспешноУстановлено Тогда
			СообщитьПользователю("Не удалось подключить расширение для работы с файлами в веб-клиенте!");
		КонецЕсли;
		
	#КонецЕсли
	
	СоответствиеДляУстановки["ЭтоНачалоРаботы1С"]         = Истина; // На случай переполнения стека
	СоответствиеДляУстановки["ОперационнаяСистемаКлиент"] = Ждать ОбещаниеРассчетТипОС;
	СоответствиеДляУстановки["ИмяПользователяОСКлиент"]   = Ждать ВычислитьТекущегоПользователяСистемыАсинх(СоответствиеДляУстановки["ОперационнаяСистемаКлиент"]);
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		СтруктураПараметров = Спец_ОбщегоНазначения.ПолучитьСтруктуруПараметровДляЗапуска(СоответствиеДляУстановки);
	#Иначе
		СтруктураПараметров = Спец_ОбщегоНазначенияВызовСервера.ПолучитьСтруктуруПараметровДляЗапуска(СоответствиеДляУстановки);
	#КонецЕсли
	
	// Уведомления пользователям
	Если СтруктураПараметров.ВключитьУведомленияПользователей Тогда
		ПодключитьОбработчикОжидания("Спец_ОбработчикОжиданияОтправкаУведомлений", СтруктураПараметров.ПериодОбновленияНовыхУведомлений);
	КонецЕсли;
	
	// А не пора ли заканчивать
	Если СтруктураПараметров.ПодключатьОбработчикЗавершенияРаботыПользователей Тогда
		ПодключитьОбработчикОжидания("Спец_АНеПораЛиЗаканчивать", Спец_КонстантыКлиентСервер.СекундВМинуте());
	КонецЕсли;
	
	// Заголовок базы
	Если СтруктураПараметров.УстанавливатьЗаголовокБазы Тогда
		КлиентскоеПриложение.УстановитьЗаголовок(СтруктураПараметров.ЗаголовокДляУстановки);
	КонецЕсли;
	
	Спец_КомпонентаДополнительныеФункцииКлиент.ОбработатьПереустановкуКомпонентАсинх(СтруктураПараметров.СоответствиеКомпонентДляПереустановки);
	
	СоответствиеДляУстановки = Новый Соответствие;
	СоответствиеДляУстановки["ЭтоНачалоРаботы1С"] = Ложь;
	
	УстановитьЗначенияПеременныхПоСоответствию(СоответствиеДляУстановки);
	ОбновитьПовторноИспользуемыеЗначения();
	
	Если СтруктураПараметров.СоответствиеКомпонентДляПереустановки["ОбщийМакет.Спец_КомпонентаLykovPostgreSQL"] = Неопределено Тогда
		Спец_ЗаписатьЛог("Начало сеанса", ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"), "Начало сеанса");
	КонецЕсли;
	
КонецПроцедуры

Асинх Функция РассчитатьТипОСАсинх()
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	Если СистемнаяИнфо.ТипПлатформы = ТипПлатформы.Windows_x86 Или СистемнаяИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
		
		#Если ВебКлиент Тогда
			
			Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows");
			
		#Иначе
			
			МассивФайлов = Ждать НайтиФайлыАсинх("\etc", "sysctl.conf", Ложь);
			Если МассивФайлов.Количество() Тогда
				Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine");
			Иначе
				Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows");
			КонецЕсли;
			
		#КонецЕсли
		
	ИначеЕсли СистемнаяИнфо.ТипПлатформы = ТипПлатформы.Linux_x86 Или СистемнаяИнфо.ТипПлатформы = ТипПлатформы.Linux_x86_64 Тогда
		
		Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.UNIX");
		
	Иначе
		
		Возврат ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.ПустаяСсылка");
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  ТипОС - ПеречислениеСсылка.Спец_ОперационныеСистемы, Неопределено -
// 
// Возвращаемое значение:
//  Строка
//
Асинх Функция ВычислитьТекущегоПользователяСистемыАсинх(Знач ТипОС)
	
	Если ТипОС = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Windows")
		Или ТипОС = ПредопределенноеЗначение("Перечисление.Спец_ОперационныеСистемы.Wine") Тогда
		
		ИмяПользователяОС = Ждать ВыполнитьКомандуСистемыАсинх("echo %username%", , , ТипОС); // Строка
		
	Иначе
		
		ИмяПользователяОС = Ждать ВыполнитьКомандуСистемыАсинх("whoami", , , ТипОС); // Строка
		
	КонецЕсли;
	
	Возврат СокрЛП(ИмяПользователяОС);
	
КонецФункции

// Параметры:
//  ИнформацияОбОшибке - ИнформацияОбОшибке
//  СтандартнаяОбработка - Булево
//
Асинх Процедура ЗаписатьОшибкуВРегистрАсинх(Знач ИнформацияОбОшибке, СтандартнаяОбработка)
	// Так как может быть ошибка при завершении сеанса, то всё через попытку (серверные вызовы запрещены).
	
	Кэш = Спец_ПолучитьКэш();
	Попытка
		
		Скриншот = Неопределено; // ДвоичныеДанные
		
		//@skip-check unknown-method-property
		Попытка
			
			Скриншот = Ждать Спец_КомпонентаДополнительныеФункцииКлиент.ПолучитьСкриншотЭкранаАсинх(, Кэш);
			
		Исключение
			
			Спец_ЗаписатьЛог("Запись ошибки в регистр",
					ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Ошибка"),
					ИнформацияОбОшибке(),
					Кэш);
			
		КонецПопытки;
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			Спец_ОбщегоНазначенияВызовСервера.ЗаписатьОшибки("Пользовательская ошибка: " + Спец_ОбщегоНазначенияКлиентСервер.ТекущийПользователь1СПолноеИмя(), ИнформацияОбОшибке, , , Истина, Скриншот);
		#Иначе
			Спец_ОбщегоНазначения.ЗаписатьОшибки("Пользовательская ошибка: " + Спец_ОбщегоНазначенияКлиентСервер.ТекущийПользователь1СПолноеИмя(), ИнформацияОбОшибке, , , , Скриншот);
		#КонецЕсли
		
	Исключение
		
		СтандартнаяОбработка = Истина;
		
		// Для отладки
		//@skip-check module-unused-local-variable
		ОшибкаПриВыводеОшибок = Спец_ОбщегоНазначенияКлиентСервер.КраткоеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке);

	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти
// -- Спец_БСП.Версия1С_18_ВышеИлиРавно

#КонецОбласти

// ++ Спец_БСП.Версия1С_18_ВышеИлиРавно
#Область ВыполнениеКомандыСистемы

// Параметры:
//  СтрокаКоманды - Строка
//  ДождатьсяЗавершения - Булево
//  ВозвращатьРезультат - Булево
// 
// Возвращаемое значение:
//  см. ВыполнитьКомандуСистемыАсинх_ОбработатьРезультат
//
Асинх Функция ВыполнитьКомандуСистемыАсинх_Windows(Знач СтрокаКоманды, Знач ДождатьсяЗавершения, Знач ВозвращатьРезультат)
	
	Если ВозвращатьРезультат Тогда
		
		// Маздай не умеет в UTF-8 при выводе в файл
		ДополнительныеПараметры = Ждать ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКомандыАсинх("cp866");
		
		СтрокаКоманды = СтрШаблон("cmd /d /U /C ""%1 > ""%2"" 2>&1""", СтрокаКоманды, ДополнительныеПараметры.ВременныйФайл);
		
		// Пытаемся через Wscript (чтобы без отображения консоли)
		Попытка
			
			WShell = Новый COMОбъект("Wscript.Shell");
			WShell.Run(СтрокаКоманды, 0, ДождатьсяЗавершения);
			
			ДополнительныеПараметры.КодировкаДляЧтения = КодировкаТекста.UTF16;
			Возврат Ждать ВыполнитьКомандуСистемыАсинх_ОбработатьРезультат(ДополнительныеПараметры);
			
		Исключение
			
			Спец_ЗаписатьЛог("ВыполнитьКомандуСистемы Windows (через Wscript)",
					ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
					ИнформацияОбОшибке());
			
		КонецПопытки;
		
		Попытка
			
			Ждать ЗапуститьПриложениеАсинх(СтрокаКоманды, , ДождатьсяЗавершения);
			
		Исключение
			
			ТекстОшибки = "";
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(),
					"Спец_ОбщегоНазначенияКлиент.ВыполнитьКомандуСистемы_Windows(...)",
					ТекстОшибки);
			
			#Если Не ВебКлиент Тогда
				
				ЗаписьТекста = Новый ЗаписьТекста(ДополнительныеПараметры.ВременныйФайл, ДополнительныеПараметры.КодировкаДляЧтения, Символы.ПС);
				ЗаписьТекста.Записать(ТекстОшибки);
				ЗаписьТекста.Закрыть();
				
			#Иначе
				
				ВызватьИсключение ТекстОшибки;
				
			#КонецЕсли
			
		КонецПопытки;
		
		Возврат Ждать ВыполнитьКомандуСистемыАсинх_ОбработатьРезультат(ДополнительныеПараметры);
		
	Иначе
		
		СтрокаКоманды = СтрШаблон("cmd /d /C ""%1""", СтрокаКоманды);
		Попытка
			
			WShell = Новый COMОбъект("Wscript.Shell");
			WShell.Run(СтрокаКоманды, 0, ДождатьсяЗавершения);
			
			Возврат Истина;
			
		Исключение
			
			Спец_ЗаписатьЛог("ВыполнитьКомандуСистемы Windows (через Wscript)",
					ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
					ИнформацияОбОшибке());
			
		КонецПопытки;
		
		Ждать ЗапуститьПриложениеАсинх(СтрокаКоманды, , ДождатьсяЗавершения);
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  СтрокаКоманды - Строка
//  ДождатьсяЗавершения - Булево
//  ВозвращатьРезультат - Булево
// 
// Возвращаемое значение:
//  см. ВыполнитьКомандуСистемыАсинх_ОбработатьРезультат
//
Асинх Функция ВыполнитьКомандуСистемыАсинх_Wine(Знач СтрокаКоманды, Знач ДождатьсяЗавершения, Знач ВозвращатьРезультат)
	
	Если ВозвращатьРезультат Тогда
		
		ДополнительныеПараметры = Ждать ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКомандыАсинх();
		СтрокаКоманды = СтрШаблон("wineconsole cmd /d /U /C ""%1 > ""%2"" 2>&1""", СтрокаКоманды, ДополнительныеПараметры.ВременныйФайл);
		
		Ждать ЗапуститьПриложениеАсинх(СтрокаКоманды, , ДождатьсяЗавершения);
		Возврат Ждать ВыполнитьКомандуСистемыАсинх_ОбработатьРезультат(ДополнительныеПараметры);
		
	Иначе
		
		Ждать ЗапуститьПриложениеАсинх(СтрШаблон("wineconsole cmd /d /C ""%1""", СтрокаКоманды), , ДождатьсяЗавершения);
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  СтрокаКоманды - Строка
//  ДождатьсяЗавершения - Булево
//  ВозвращатьРезультат - Булево
// 
// Возвращаемое значение:
//  см. ВыполнитьКомандуСистемыАсинх_ОбработатьРезультат
//
Асинх Функция ВыполнитьКомандуСистемыАсинх_Other(Знач СтрокаКоманды, Знач ДождатьсяЗавершения, Знач ВозвращатьРезультат)
	
	Если ВозвращатьРезультат Тогда
		
		ДополнительныеПараметры = Ждать ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКомандыАсинх();
		
		// Выполняем cmd с параметрами
		СтрокаКоманды = СтрШаблон("%1 > '%2' 2>&1", СтрокаКоманды, ДополнительныеПараметры.ВременныйФайл);
		
		Ждать ЗапуститьПриложениеАсинх(СтрокаКоманды, , ДождатьсяЗавершения);
		Возврат Ждать ВыполнитьКомандуСистемыАсинх_ОбработатьРезультат(ДополнительныеПараметры);
		
	Иначе
		
		Ждать ЗапуститьПриложениеАсинх(СтрокаКоманды, , ДождатьсяЗавершения);
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  ДополнительныеПараметры - см. ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКомандыАсинх
// 
// Возвращаемое значение:
//  Булево, Строка - Выполнить команду системы после выполнения с результатом
//
Асинх Функция ВыполнитьКомандуСистемыАсинх_ОбработатьРезультат(Знач ДополнительныеПараметры) Экспорт
	
	СтрокаРезультат = Спец_ОбщегоНазначенияКлиентСервер.ПрочитатьЧтениеТекста(ДополнительныеПараметры.ВременныйФайл, ДополнительныеПараметры.КодировкаДляЧтения);
	СтрокаРезультат = Спец_СтроковыеФункцииКлиентСервер.УдалитьНедопустимыеСимволыXMLПрограммно(СтрокаРезультат); // На всякий случай
	
	УдалитьФайлыАсинх(ДополнительныеПараметры.ВременныйФайл);
	Возврат СтрокаРезультат;
	
КонецФункции

#КонецОбласти
// -- Спец_БСП.Версия1С_18_ВышеИлиРавно

#Область РаботаСФайламиКрасивая

// ++ Спец_БСП.Версия1С_18_ВышеИлиРавно

// Параметры:
//  МассивФайлов - Массив из СсылкаНаФайл
//  ОтказОтПомещенияФайла - Булево
//  ДополнительныеПараметры - см. НоваяСтруктураДополнительныхПараметровЗагрузкиФайловНаСервер
//
Процедура ПередНачаломЗагрузкиФайловНаСервер(Знач МассивФайлов, ОтказОтПомещенияФайла, Знач ДополнительныеПараметры) Экспорт
	
	ТекстСообщения = "Начинается передача файлов...";
	Если ДополнительныеПараметры.ВозможностьПрерывания Тогда
		
		//@skip-check dynamic-access-method-not-found
		Если ДополнительныеПараметры.Кэш.КомпонентаBaseFunction.ОбработкаПрерывания() Тогда
			
			ОтказОтПомещенияФайла = Истина;
			Возврат;
			
		КонецЕсли;
		
		ВывестиСостояние(ТекстСообщения,
				1,
				"<Для прерывания удерживайте Ctrl + Break>",
				БиблиотекаКартинок.Спец_ДлительнаяОперация);
		
	Иначе
		
		ВывестиСостояние(ТекстСообщения,
				1,
				,
				БиблиотекаКартинок.Спец_ДлительнаяОперация);
		
	КонецЕсли;
	
	
	ВывестиСостояние("Начинается передача файлов...", 1, , БиблиотекаКартинок.Спец_ДлительнаяОперация);
	
КонецПроцедуры

// Параметры:
//  ПомещаемыйФайл - СсылкаНаФайл
//  Помещено - Число
//  ОтказОтПомещенияФайла - Булево
//  ДополнительныеПараметры - см. НоваяСтруктураДополнительныхПараметровЗагрузкиФайловНаСервер
//
Процедура ХодВыполненияЗагрузкиФайловНаСерверОдиночный(Знач ПомещаемыйФайл, Знач Помещено, ОтказОтПомещенияФайла, Знач ДополнительныеПараметры) Экспорт
	
	ТекстСообщения = СтрШаблон("Передача файла ""%1""...", ПомещаемыйФайл.Имя);
	Если ДополнительныеПараметры.ВозможностьПрерывания Тогда
		
		//@skip-check dynamic-access-method-not-found
		Если ДополнительныеПараметры.Кэш.КомпонентаBaseFunction.ОбработкаПрерывания() Тогда
			
			ОтказОтПомещенияФайла = Истина;
			Возврат;
			
		КонецЕсли;
		
		ВывестиСостояние(ТекстСообщения,
				Помещено,
				"<Для прерывания удерживайте Ctrl + Break>",
				БиблиотекаКартинок.Спец_ДлительнаяОперация);
		
	Иначе
		
		ВывестиСостояние(ТекстСообщения,
				Помещено,
				,
				БиблиотекаКартинок.Спец_ДлительнаяОперация);
		
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  ПомещаемыйФайл - СсылкаНаФайл
//  Помещено - Число
//  ОтказОтПомещенияФайла - Булево
//  ПомещеноВсего - Число
//  ОтказОтПомещенияВсехФайлов - Булево
//  ДополнительныеПараметры - см. НоваяСтруктураДополнительныхПараметровЗагрузкиФайловНаСервер
//
Процедура ХодВыполненияЗагрузкиФайловНаСерверМассовый(Знач ПомещаемыйФайл, Знач Помещено, Знач ОтказОтПомещенияФайла,
		Знач ПомещеноВсего, ОтказОтПомещенияВсехФайлов, Знач ДополнительныеПараметры) Экспорт
	
	ТекстСообщения = СтрШаблон("Передача файла ""%1""...", ПомещаемыйФайл.Имя);
	Если ДополнительныеПараметры.ВозможностьПрерывания Тогда
		
		//@skip-check dynamic-access-method-not-found
		Если ДополнительныеПараметры.Кэш.КомпонентаBaseFunction.ОбработкаПрерывания() Тогда
			
			ОтказОтПомещенияВсехФайлов = Истина;
			Возврат;
			
		КонецЕсли;
		
		ВывестиСостояние(ТекстСообщения,
				ПомещеноВсего,
				"<Для прерывания удерживайте Ctrl + Break>",
				БиблиотекаКартинок.Спец_ДлительнаяОперация);
		
	Иначе
		
		ВывестиСостояние(ТекстСообщения,
				ПомещеноВсего,
				,
				БиблиотекаКартинок.Спец_ДлительнаяОперация);
		
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  НужнаяКодировка - Строка, КодировкаТекста - Кодировка для чтения результата
// 
// Возвращаемое значение:
//  Структура:
// * ВременныйФайл - Строка
// * КодировкаДляЧтения - Строка, КодировкаТекста -
//
Асинх Функция ПолучитьСтруктуруДополнительныхПараметровДляВыполненияКомандыАсинх(Знач НужнаяКодировка = "UTF-8")
	
	Возврат Новый Структура("ВременныйФайл, КодировкаДляЧтения",
			Ждать ПолучитьИмяВременногоФайлаПоНормальномуАсинх("txt"),
			НужнаяКодировка);
	
КонецФункции

// -- Спец_БСП.Версия1С_18_ВышеИлиРавно

#КонецОбласти

#Область Типизация

//@skip-check constructor-function-return-section
//
// Параметры:
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Структура - Новая структура дополнительных параметров загрузки файлов на сервер:
//		* ВозможностьПрерывания - Булево
//		* Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Функция НоваяСтруктураДополнительныхПараметровЗагрузкиФайловНаСервер(Знач Кэш)
	
	Возврат Новый Структура("ВозможностьПрерывания, Кэш",
			Спец_ОбщегоНазначенияКлиентСервер.ЭтоWindows() И Кэш.КомпонентаBaseFunction <> Неопределено,
			Кэш);
	
КонецФункции

#КонецОбласти

#КонецОбласти
