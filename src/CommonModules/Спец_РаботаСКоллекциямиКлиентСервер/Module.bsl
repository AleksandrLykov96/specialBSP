// @strict-types

//@skip-check typed-value-adding-to-untyped-collection

#Область ПрограммныйИнтерфейс

#Область ПроверкиНаТипДанных

// Возвращает флаг того, что проверяемое значение - массив (или фиксированный массив)
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоМассив(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
	Возврат ?(ТипРеквизита = Тип("Тип"),
			ПроверяемоеЗначение = Тип("Массив") Или ПроверяемоеЗначение = Тип("ФиксированныйМассив"),
			ТипРеквизита = Тип("Массив") Или ТипРеквизита = Тип("ФиксированныйМассив"));
	
КонецФункции

// Возвращает флаг того, что проверяемое значение - структура (или фиксированная структура)
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоСтруктура(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
	Возврат ?(ТипРеквизита = Тип("Тип"),
			ПроверяемоеЗначение = Тип("Структура") Или ПроверяемоеЗначение = Тип("ФиксированнаяСтруктура"),
			ТипРеквизита = Тип("Структура") Или ТипРеквизита = Тип("ФиксированнаяСтруктура"));
	
КонецФункции

// Возвращает флаг того, что проверяемое значение - соответствие (или фиксированное соответствие)
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоСоответствие(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
	Возврат ?(ТипРеквизита = Тип("Тип"),
			ПроверяемоеЗначение = Тип("Соответствие") Или ПроверяемоеЗначение = Тип("ФиксированноеСоответствие"),
			ТипРеквизита = Тип("Соответствие") Или ТипРеквизита = Тип("ФиксированноеСоответствие"));
	
КонецФункции

// Возвращает флаг того, что проверяемое значение - любой из потоков (ПотокВПамяти, ФайловыйПоток, Поток)
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоПоток(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
	Возврат ?(ТипРеквизита = Тип("Тип"),
			ПроверяемоеЗначение = Тип("ПотокВПамяти") Или ПроверяемоеЗначение = Тип("ФайловыйПоток") Или ПроверяемоеЗначение = Тип("Поток"),
			ТипРеквизита = Тип("ПотокВПамяти") Или ТипРеквизита = Тип("ФайловыйПоток") Или ТипРеквизита = Тип("Поток"));
	
КонецФункции

// Возвращает флаг того, что проверяемое значение - примитивный тип (строка, дата, число, булево)
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоПримитивныйТип(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
	Возврат ?(ТипРеквизита = Тип("Тип"),
			ПроверяемоеЗначение = Тип("Строка") Или ПроверяемоеЗначение = Тип("Дата") Или ПроверяемоеЗначение = Тип("Число") Или ПроверяемоеЗначение = Тип("Булево"),
			ТипРеквизита = Тип("Строка") Или ТипРеквизита = Тип("Дата") Или ТипРеквизита = Тип("Число") Или ТипРеквизита = Тип("Булево"));
	
КонецФункции

// Возвращает флаг того, что проверяемое значение - тип, связанный с HTTP (HTTPЗапрос, HTTPСервисЗапрос, HTTPОтвет, HTTPСервисОтвет)
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоHTTPТип(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
	Возврат ЭтоHTTPЗапросТип(ПроверяемоеЗначение, ТипРеквизита) Или ЭтоHTTPОтветТип(ПроверяемоеЗначение, ТипРеквизита);
	
КонецФункции

// Возвращает флаг того, что проверяемое значение - тип, связанный с HTTP запросами (HTTPЗапрос, HTTPСервисЗапрос)
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоHTTPЗапросТип(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
	
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
		
		Возврат ?(ТипРеквизита = Тип("Тип"),
				ПроверяемоеЗначение = Тип("HTTPЗапрос") Или ПроверяемоеЗначение = Тип("HTTPСервисЗапрос"),
				ТипРеквизита = Тип("HTTPЗапрос") Или ТипРеквизита = Тип("HTTPСервисЗапрос"));
		
	#Иначе
		
		Возврат ?(ТипРеквизита = Тип("Тип"),
				ПроверяемоеЗначение = Тип("HTTPЗапрос"),
				ТипРеквизита = Тип("HTTPЗапрос"));
		
	#КонецЕсли
	
КонецФункции

// Возвращает флаг того, что проверяемое значение - тип, связанный с HTTP ответами (HTTPОтвет, HTTPСервисОтвет)
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоHTTPОтветТип(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
	
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
		
		Возврат ?(ТипРеквизита = Тип("Тип"),
				ПроверяемоеЗначение = Тип("HTTPОтвет") Или ПроверяемоеЗначение = Тип("HTTPСервисОтвет"),
				ТипРеквизита = Тип("HTTPОтвет") Или ТипРеквизита = Тип("HTTPСервисОтвет"));
		
	#Иначе
		
		Возврат ?(ТипРеквизита = Тип("Тип"),
				ПроверяемоеЗначение = Тип("HTTPОтвет"),
				ТипРеквизита = Тип("HTTPОтвет"));
		
	#КонецЕсли
	
КонецФункции

// Возвращает флаг того, что проверяемое значение - таблица значений.
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоТаблицаЗначений(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		
		Возврат Ложь;
		
	#Иначе

		Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
		Возврат ?(ТипРеквизита = Тип("Тип"), ПроверяемоеЗначение = Тип("ТаблицаЗначений"), ТипРеквизита = Тип("ТаблицаЗначений"));
		
	#КонецЕсли
	
КонецФункции

// Возвращает флаг того, что проверяемое значение - хранилище значения
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//  ТипРеквизита - Неопределено, Тип -
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоХранилищеЗначения(Знач ПроверяемоеЗначение, Знач ТипРеквизита = Неопределено) Экспорт
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		
		Возврат Ложь;
		
	#Иначе
		
		Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ПроверяемоеЗначение); КонецЕсли;
		Возврат ?(ТипРеквизита = Тип("Тип"), ПроверяемоеЗначение = Тип("ХранилищеЗначения"), ТипРеквизита = Тип("ХранилищеЗначения"));
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти

#Область КопированиеДанных

// Создает полную копию структуры, соответствия, массива, списка или таблицы значений, рекурсивно,
// с учетом типов дочерних элементов. При этом содержимое значений объектных типов
// (СправочникОбъект, ДокументОбъект и т.п.) не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  Источник - Произвольный - объект, который необходимо скопировать
//  		 - ТаблицаЗначений
//  		 - Структура
//  		 - ФиксированнаяСтруктура
//  		 - Соответствие из Произвольный
//  		 - ФиксированноеСоответствие из Произвольный
//  		 - Массив из Произвольный
//  		 - ФиксированныйМассив из Произвольный
//  		 - СписокЗначений из Произвольный
//  ФиксироватьДанные - Булево, Неопределено - если Истина - фиксировать, если Ложь - снять фиксацию, если Неопределено - не изменять.
//  ТипИсточника - Тип, Неопределено - Тип источника
//
// Возвращаемое значение:
//  Произвольный - копия объекта, переданного в параметре Источник.
//
Функция СкопироватьРекурсивно(Знач Источник, Знач ФиксироватьДанные = Неопределено, Знач ТипИсточника = Неопределено) Экспорт
	
	Если ТипИсточника = Неопределено Тогда ТипИсточника = ТипЗнч(Источник); КонецЕсли;
	Если ЭтоТаблицаЗначений(Источник, ТипИсточника) Тогда
		Возврат Источник.Скопировать();
	ИначеЕсли ЭтоСтруктура(Источник, ТипИсточника) Тогда
		Возврат СкопироватьСтруктуру(Источник, ФиксироватьДанные);
	ИначеЕсли ЭтоСоответствие(Источник, ТипИсточника) Тогда
		Возврат СкопироватьСоответствие(Источник, ФиксироватьДанные);
	ИначеЕсли ЭтоМассив(Источник, ТипИсточника) Тогда
		Возврат СкопироватьМассив(Источник, ФиксироватьДанные);
	ИначеЕсли ТипИсточника = Тип("СписокЗначений") Тогда
		Возврат СкопироватьСписокЗначений(Источник, ФиксироватьДанные);
	Иначе
		Возврат Источник;
	КонецЕсли;
	
КонецФункции

// Метод для копирования структуры (см. СкопироватьРекурсивно)
// 
// Параметры:
//  СтруктураИсточник - Структура, ФиксированнаяСтруктура - Структура источник
//  ФиксироватьДанные - см. СкопироватьРекурсивно.ФиксироватьДанные
// 
// Возвращаемое значение:
//  Структура, ФиксированнаяСтруктура - копия объекта, переданного в параметре Источник.
//
Функция СкопироватьСтруктуру(Знач СтруктураИсточник, Знач ФиксироватьДанные = Неопределено) Экспорт
	
	СтруктураРезультат = Новый Структура;
	Для Каждого КлючЗначение Из СтруктураИсточник Цикл СтруктураРезультат.Вставить(КлючЗначение.Ключ, СкопироватьРекурсивно(КлючЗначение.Значение, ФиксироватьДанные)); КонецЦикла;
	
	Возврат ?(ФиксироватьДанные = Истина Или ФиксироватьДанные = Неопределено И ТипЗнч(СтруктураИсточник) = Тип("ФиксированнаяСтруктура"),
			Новый ФиксированнаяСтруктура(СтруктураРезультат),
			СтруктураРезультат);
	
КонецФункции

// Метод для копирования соответствия (см. СкопироватьРекурсивно)
// 
// Параметры:
//  СоответствиеИсточник - Соответствие из КлючИЗначение
//  					 - ФиксированноеСоответствие из КлючИЗначение
//  ФиксироватьДанные - см. СкопироватьРекурсивно.ФиксироватьДанные
// 
// Возвращаемое значение:
//  - Соответствие из КлючИЗначение
//	- ФиксированноеСоответствие из КлючИЗначение
//
Функция СкопироватьСоответствие(Знач СоответствиеИсточник, Знач ФиксироватьДанные = Неопределено) Экспорт
	
	СоответствиеРезультат = Новый Соответствие;
	Для Каждого КлючЗначение Из СоответствиеИсточник Цикл СоответствиеРезультат.Вставить(КлючЗначение.Ключ, СкопироватьРекурсивно(КлючЗначение.Значение, ФиксироватьДанные)); КонецЦикла;
	
	Возврат ?(ФиксироватьДанные = Истина Или ФиксироватьДанные = Неопределено И ТипЗнч(СоответствиеИсточник) = Тип("ФиксированноеСоответствие"),
			Новый ФиксированноеСоответствие(СоответствиеРезультат),
			СоответствиеРезультат);
	
КонецФункции

// Метод для копирования массива (см. СкопироватьРекурсивно)
// 
// Параметры:
//  МассивИсточник - Массив из Произвольный
//  			   - ФиксированныйМассив из Произвольный
//  ФиксироватьДанные - см. СкопироватьРекурсивно.ФиксироватьДанные
// 
// Возвращаемое значение:
//  - Массив из Произвольный
//  - ФиксированныйМассив из Произвольный
//
Функция СкопироватьМассив(Знач МассивИсточник, Знач ФиксироватьДанные = Неопределено) Экспорт
	
	МассивРезультат = Новый Массив();
	
	
	Для Каждого Элемент Из МассивИсточник Цикл МассивРезультат.Добавить(СкопироватьРекурсивно(Элемент, ФиксироватьДанные)); КонецЦикла;
	Возврат ?(ФиксироватьДанные = Истина Или ФиксироватьДанные = Неопределено И ТипЗнч(МассивИсточник) = Тип("ФиксированныйМассив"),
			Новый ФиксированныйМассив(МассивРезультат),
			МассивРезультат);
	
КонецФункции

// Метод для копирования списка значений (см. СкопироватьРекурсивно)
// 
// Параметры:
//  СписокИсточник - СписокЗначений из Произвольный - Список источник
//  ФиксироватьДанные - см. СкопироватьРекурсивно.ФиксироватьДанные
// 
// Возвращаемое значение:
//  СписокЗначений из Произвольный
//
Функция СкопироватьСписокЗначений(Знач СписокИсточник, Знач ФиксироватьДанные = Неопределено) Экспорт
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка Из СписокИсточник Цикл СписокРезультат.Добавить(СкопироватьРекурсивно(ЭлементСписка.Значение, ФиксироватьДанные), ЭлементСписка.Представление, ЭлементСписка.Пометка, ЭлементСписка.Картинка); КонецЦикла;
	Возврат СписокРезультат;
	
КонецФункции

#КонецОбласти

#Область РаботаСКоллекциямиЗначений

// Выгружает массив значений из коллекции (для которой доступен обход посредством оператора Для каждого ... Из ...)
// 
// Параметры:
//  КоллекцияЗначений - ТаблицаЗначений
//  				  - ДеревоЗначений
//  				  - СписокЗначений из Произвольный
//  				  - ТабличнаяЧасть
//  				  - ДанныеФормыКоллекция
//  				  - Соответствие из КлючИЗначение
//  				  - ФиксированноеСоответствие из КлючИЗначение,
//  				  - Структура
//  				  - ФиксированнаяСтруктура
//  				  - Массив из Структура
//  				  - Массив из ФиксированнаяСтруктура
//  				  - ФиксированныйМассив из Структура
//  				  - ФиксированныйМассив из ФиксированнаяСтруктура
//  ИмяКолонки - Строка - Наименование колонки для выгрузки
//  ТолькоУникальныеЗначения - Булево - Флаг того, что нужно выгрузить только различающиеся значения
//  ИсключаяПустые - Булево - Флаг того, что пустые значения выгружать не нужно
//  СтруктураОтбораДляВыгрузки - Неопределено, Структура, ФиксированнаяСтруктура - Структура для выгрузки, где ключ - имя колонки для отбора, значение - значение для отбора.
// 
// Возвращаемое значение:
//  Массив из Произвольный
//
Функция ВыгрузитьМассивЗначений(Знач КоллекцияЗначений, Знач ИмяКолонки, Знач ТолькоУникальныеЗначения = Ложь,
		Знач ИсключаяПустые = Ложь, Знач СтруктураОтбораДляВыгрузки = Неопределено) Экспорт
	
	ТипКоллекции = ТипЗнч(КоллекцияЗначений);
	Если ЭтоТаблицаЗначений(КоллекцияЗначений, ТипКоллекции) Тогда
		
		Возврат ВыгрузитьМассивЗначенийИзТаблицыЗначений(КоллекцияЗначений, ИмяКолонки, ТолькоУникальныеЗначения, ИсключаяПустые, СтруктураОтбораДляВыгрузки);
		
	ИначеЕсли ТипКоллекции = Тип("ДанныеФормыКоллекция") Тогда
		
		Возврат ВыгрузитьМассивЗначенийИзДанныхФормыКоллекции(КоллекцияЗначений, ИмяКолонки, ТолькоУникальныеЗначения, ИсключаяПустые, СтруктураОтбораДляВыгрузки);
		
	ИначеЕсли ТипКоллекции = Тип("СписокЗначений")
		И ИмяКолонки = "Значение"
		И Не ИсключаяПустые
		И СтруктураОтбораДляВыгрузки = Неопределено Тогда // Список значений без всяких условий
		
		Возврат ?(ТолькоУникальныеЗначения,
				СвернутьМассив(КоллекцияЗначений.ВыгрузитьЗначения()),
				КоллекцияЗначений.ВыгрузитьЗначения());
		
	ИначеЕсли ТолькоУникальныеЗначения Тогда
		
		Возврат ВыгрузитьМассивЗначений_ТолькоУникальные(КоллекцияЗначений, ИмяКолонки, ИсключаяПустые, СтруктураОтбораДляВыгрузки);
		
	Иначе
		
		Возврат ВыгрузитьМассивЗначений_Все(КоллекцияЗначений, ИмяКолонки, ИсключаяПустые, СтруктураОтбораДляВыгрузки);
		
	КонецЕсли;
	
КонецФункции

// Метод для поиска элементов по структуре отбора в любой коллекции (для которой доступен обход посредством оператора Для каждого ... Из ...).
// 
//@skip-check unreachable-statement
//@skip-check use-goto-operator
// 
// Параметры:
//  СтруктураОтбора - Структура, ФиксированнаяСтруктура - Структура отбора (ключ - имя отбора, значение - значение отбора)
//  КоллекцияЗначений - см. ВыгрузитьМассивЗначений.КоллекцияЗначений
//  ТолькоПервоеЗначение - Булево - Возвращать только первое значение
// 
// Возвращаемое значение:
// 	- Неопределено - Если ТолькоПервоеЗначение = Истина и строка не найдена
// 	- СтрокаТаблицыЗначений, СтрокаДереваЗначений, ЭлементСпискаЗначений, СтрокаТабличнойЧасти, КлючИЗначение - Если ТолькоПервоеЗначение = Истина и строка найдена, то возвращает найденный элемент коллекции 
// 	- Массив из СтрокаТаблицыЗначений, СтрокаДереваЗначений, ЭлементСпискаЗначений, СтрокаТабличнойЧасти, КлючИЗначение - Если ТолькоПервоеЗначение = Ложь
//
Функция НайтиСтрокиВКоллекцииСтрок(Знач СтруктураОтбора, Знач КоллекцияЗначений, Знач ТолькоПервоеЗначение = Ложь) Экспорт
	
	Если ТолькоПервоеЗначение Тогда
		
		Для Каждого СтрокаДляПоиска Из КоллекцияЗначений Цикл Для Каждого КлючЗначение Из СтруктураОтбора Цикл Если СтрокаДляПоиска[КлючЗначение.Ключ] <> КлючЗначение.Значение Тогда Перейти ~ВыходИзЦикла_ТолькоПервоеЗначение; КонецЕсли; КонецЦикла; Возврат СтрокаДляПоиска; ~ВыходИзЦикла_ТолькоПервоеЗначение: КонецЦикла;
		Возврат Неопределено;
		
	Иначе
		
		МассивСтрокРезультат = Новый Массив();
		
		Для Каждого СтрокаДляПоиска Из КоллекцияЗначений Цикл Для Каждого КлючЗначение Из СтруктураОтбора Цикл Если СтрокаДляПоиска[КлючЗначение.Ключ] <> КлючЗначение.Значение Тогда Перейти ~ВыходИзЦикла_МассивСтрок; КонецЕсли; КонецЦикла; МассивСтрокРезультат.Добавить(СтрокаДляПоиска); ~ВыходИзЦикла_МассивСтрок: КонецЦикла;
		Возврат МассивСтрокРезультат;
		
	КонецЕсли;
	
КонецФункции

// Метод для поиска элементов по структуре отбора с вызовом ДанныеСовпадают для каждого элемента в любой коллекции
// (для которой доступен обход посредством оператора Для каждого ... Из ...).
// 
//@skip-check use-goto-operator
// 
// Параметры:
//  СтруктураОтбора - Структура, ФиксированнаяСтруктура - Структура отбора (ключ - имя отбора, значение - значение отбора)
//  КоллекцияЗначений - см. ВыгрузитьМассивЗначений.КоллекцияЗначений
//  ТолькоПервоеЗначение - Булево - Возвращать только первое значение
// 
// Возвращаемое значение:
// 	- Неопределено - Если ТолькоПервоеЗначение = Истина и строка не найдена
// 	- СтрокаТаблицыЗначений, СтрокаДереваЗначений, ЭлементСпискаЗначений, СтрокаТабличнойЧасти, КлючИЗначение - Если ТолькоПервоеЗначение = Истина и строка найдена, то возвращает найденный элемент коллекции 
// 	- Массив из СтрокаТаблицыЗначений, СтрокаДереваЗначений, ЭлементСпискаЗначений, СтрокаТабличнойЧасти, КлючИЗначение - Если ТолькоПервоеЗначение = Ложь
//
Функция НайтиСтрокиВКоллекцииСтрокСВызовомДанныеСовпадают(Знач СтруктураОтбора, Знач КоллекцияЗначений, Знач ТолькоПервоеЗначение = Ложь) Экспорт
	
	Если ТолькоПервоеЗначение Тогда
		
		//@skip-check unreachable-statement
		Для Каждого СтрокаДляПоиска Из КоллекцияЗначений Цикл Для Каждого КлючЗначение Из СтруктураОтбора Цикл Если Не ДанныеСовпадают(СтрокаДляПоиска[КлючЗначение.Ключ], КлючЗначение.Значение) Тогда Перейти ~ВыходИзЦикла_ТолькоПервоеЗначение; КонецЕсли; КонецЦикла; Возврат СтрокаДляПоиска; ~ВыходИзЦикла_ТолькоПервоеЗначение: КонецЦикла;
		Возврат Неопределено;
		
	Иначе
		
		МассивСтрокРезультат = Новый Массив;
		Для Каждого СтрокаДляПоиска Из КоллекцияЗначений Цикл Для Каждого КлючЗначение Из СтруктураОтбора Цикл Если Не ДанныеСовпадают(СтрокаДляПоиска[КлючЗначение.Ключ], КлючЗначение.Значение) Тогда Перейти ~ВыходИзЦикла_МассивСтрок; КонецЕсли; КонецЦикла; МассивСтрокРезультат.Добавить(СтрокаДляПоиска); ~ВыходИзЦикла_МассивСтрок: КонецЦикла;
		Возврат МассивСтрокРезультат;
		
	КонецЕсли;
	
КонецФункции

// Удаляет все значения из массива источника в массиве приемнике.
// 
// Параметры:
//  МассивДляОчистки - Массив из Произвольный
//  МассивЗначенийДляУдаления - Массив из Произвольный
//
Процедура УдалитьВсеЭлементыМассиваПоМассиву(Знач МассивДляОчистки, Знач МассивЗначенийДляУдаления) Экспорт
	
	Для Каждого ЗначениеДляУдаления Из МассивЗначенийДляУдаления Цикл УдалитьЗначениеИзМассива(МассивДляОчистки, ЗначениеДляУдаления); КонецЦикла;
	
КонецПроцедуры

// Удаляет одно значение из массива.
// 
// Параметры:
//  ВходнойМассив - Массив из Произвольный
//  ЗначениеДляУдаления - Произвольный
//
Процедура УдалитьЗначениеИзМассива(Знач ВходнойМассив, Знач ЗначениеДляУдаления) Экспорт
	
	Индекс = ВходнойМассив.Найти(ЗначениеДляУдаления);
	Если Индекс <> Неопределено Тогда ВходнойМассив.Удалить(Индекс); КонецЕсли;
	
КонецПроцедуры

// Удаляет значения из массива структур, у которых по ключу значение совпадает со значением для удаления.
// 
// Параметры:
//  МассивДляУдаления - Массив из Структура
//  КлючСтруктуры - Строка - Ключ структуры для удаления
//  ЗначениеДляУдаления - Произвольный - Значение для удаления по ключу
//
Процедура УдалитьЗначенияИзМассиваСтруктур(Знач МассивДляУдаления, Знач КлючСтруктуры, Знач ЗначениеДляУдаления) Экспорт
	
	ВГраницаМассива = МассивДляУдаления.ВГраница();
	Для i = 0 По ВГраницаМассива Цикл
		
		ТекущийИндекс = ВГраницаМассива - i;
		Если МассивДляУдаления.Получить(ТекущийИндекс)[КлючСтруктуры] = ЗначениеДляУдаления Тогда
			МассивДляУдаления.Удалить(ТекущийИндекс);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Разбиваем входную коллекцию (для которой доступен обход посредством оператора Для каждого ... Из ...) по пакетам с указанными количествами.
// Можно указать:
// 	- КоличествоВПакете - ВходящаяКоллекция разбивается по количеству элементов, указанному в данном параметре.
// 	- КоличествоПакетов - ВходящаяКоллекция разбивается строго на количество пакетов, указанном в данном параметре.
// 
// Если количество элементов в коллекции меньше, чем итоговое количество в пакете, то она возвращается, вложенная в массив.
// В противном случае возвращается массив из массивов, состоящих из элементов входной коллекции.
// 
// Параметры:
//  ВходящаяКоллекция - см. ВыгрузитьМассивЗначений.КоллекцияЗначений
//  КоличествоВПакете - Число - Количество элементов в пакете
//  КоличествоПакетов - Число - Количество пакетов
// 
// Возвращаемое значение:
//	Массив из Произвольный
//
Функция РазбитьКоллекциюПоПакетам(Знач ВходящаяКоллекция, Знач КоличествоВПакете = 0, Знач КоличествоПакетов = 0) Экспорт
	
	КоличествоВПакете = Цел(КоличествоВПакете);
	КоличествоПакетов = Цел(КоличествоПакетов);
	КоличествоПришло  = ВходящаяКоллекция.Количество();
	
	Если КоличествоПришло = 0 Или (КоличествоВПакете > 0 И КоличествоВПакете >= КоличествоПришло) Или (КоличествоВПакете <= 0 И КоличествоПакетов <= 0) Тогда Возврат ЗначениеВМассиве(ВходящаяКоллекция); КонецЕсли;
	
	МассивРезультат = Новый Массив; // Массив из Массив
	Если КоличествоВПакете > 0 Тогда
		
		Коэффициент = КоличествоПришло / КоличествоВПакете;
		КоличествоПакетов = ?(Коэффициент = Цел(Коэффициент), Коэффициент, Цел(Коэффициент) + 1);
		
	КонецЕсли;
	
	Для i = 0 По КоличествоПакетов - 1 Цикл МассивРезультат.Добавить(Новый Массив()); КонецЦикла;
	Если КоличествоВПакете <= 0 Тогда
		
		i = 0;
		Для Каждого ЭлементКоллекции Из ВходящаяКоллекция Цикл МассивРезультат[i].Добавить(ЭлементКоллекции); i = ?(i >= КоличествоПакетов - 1, 0, i + 1); КонецЦикла;
		
	Иначе
		
		Для i = 0 По КоличествоПакетов - 1 Цикл Для j = 0 По КоличествоВПакете - 1 Цикл Если i * КоличествоВПакете + j < КоличествоПришло Тогда МассивРезультат[i].Добавить(ВходящаяКоллекция.Получить(i * КоличествоВПакете + j)); Иначе Возврат МассивРезультат; КонецЕсли; КонецЦикла; КонецЦикла;
		
	КонецЕсли;
	
	Возврат МассивРезультат;
	
КонецФункции

#Область ДополнениеКоллекции

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивИсточник - Массив из Произвольный - массив значений для заполнения.
//  МассивПриемник - Массив из Произвольный - массив, в который необходимо добавить значения.
//  ТолькоУникальныеЗначения - Булево - если ИСТИНА, то в массив будут включены только уникальные значения.
//
Процедура ДополнитьМассив(Знач МассивИсточник, Знач МассивПриемник, Знач ТолькоУникальныеЗначения = Ложь) Экспорт
	
	Если Не ТолькоУникальныеЗначения Тогда
		
		Для Каждого Значение Из МассивИсточник Цикл МассивПриемник.Добавить(Значение); КонецЦикла;
		
	Иначе
		
		УникальныеЗначения = Новый Соответствие;
		
		Для Каждого Значение Из МассивПриемник Цикл УникальныеЗначения.Вставить(Значение, Истина); КонецЦикла;
		Для Каждого Значение Из МассивИсточник Цикл Если УникальныеЗначения[Значение] = Неопределено Тогда МассивПриемник.Добавить(Значение); УникальныеЗначения.Вставить(Значение, Истина); КонецЕсли; КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Дополняет таблицу-приемник (у которых метод Добавить()) данными из коллекции-источника
// (для которой доступен обход посредством оператора Для каждого ... Из ...)
// 
// Параметры:
//  КоллекцияИсточник - см. ВыгрузитьМассивЗначений.КоллекцияЗначений
//  ТаблицаПриемник - ТаблицаЗначений
//                  - ДеревоЗначений
//                  - ТабличнаяЧасть
//                  - ДанныеФормыКоллекция
//
Процедура ДополнитьТаблицу(Знач КоллекцияИсточник, Знач ТаблицаПриемник) Экспорт
	
	Для Каждого СтрокаТаблицы Из КоллекцияИсточник Цикл ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицы); КонецЦикла;
	
КонецПроцедуры

// Дополняет объект-источник элементами из объекта-приемника.
// Типы значений объектов должны совпадать!
// 
// Параметры:
//  ОбъектИсточник - см. ВыгрузитьМассивЗначений.КоллекцияЗначений
//  ОбъектПриемник - см. ВыгрузитьМассивЗначений.КоллекцияЗначений
//  Заменять - Булево - Если ИСТИНА, то заменять значения приемника
//  ТипОбъекта - Неопределено, Тип - Тип объекта
//
Процедура ДополнитьОбъект(Знач ОбъектИсточник, Знач ОбъектПриемник, Знач Заменять = Ложь, Знач ТипОбъекта = Неопределено) Экспорт
	
	Если ТипОбъекта = Неопределено Тогда ТипОбъекта = ТипЗнч(ОбъектПриемник); КонецЕсли;
	Если ЭтоМассив(ОбъектПриемник, ТипОбъекта) Тогда
		
		ДополнитьМассив(ОбъектИсточник, ОбъектПриемник);
		
	ИначеЕсли ЭтоСтруктура(ОбъектПриемник, ТипОбъекта) Тогда
		
		//@skip-check invocation-parameter-type-intersect
		Для Каждого КлючЗначение Из ОбъектИсточник Цикл Если Заменять Или Не ОбъектПриемник.Свойство(КлючЗначение.Ключ) Тогда ОбъектПриемник.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение); КонецЕсли; КонецЦикла;
		
	ИначеЕсли ЭтоСоответствие(ОбъектПриемник, ТипОбъекта) Тогда
		
		//@skip-check invocation-parameter-type-intersect
		Для Каждого КлючЗначение Из ОбъектИсточник Цикл Если Заменять Или ОбъектПриемник.Получить(КлючЗначение.Ключ) = Неопределено Тогда ОбъектПриемник.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение); КонецЕсли; КонецЦикла;
		
	ИначеЕсли ЭтоТаблицаЗначений(ОбъектПриемник, ТипОбъекта) Тогда
		
		ДополнитьТаблицу(ОбъектИсточник, ОбъектПриемник);
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

// Возвращает копию исходного массива с уникальными значениями.
//
// Параметры:
//  МассивДляСворачивания - Массив из Произвольный - массив произвольных значений.
//
// Возвращаемое значение:
//  Массив из Произвольный
//
Функция СвернутьМассив(Знач МассивДляСворачивания) Экспорт
	
	Результат = Новый Массив;
	ДополнитьМассив(МассивДляСворачивания, Результат, Истина);
	Возврат Результат;
	
КонецФункции

// Возвращает копию отсортированного массива.
// 
// Параметры:
//  ИсходныйМассив - Массив из Произвольный - массив произвольных значений.
//  НаправлениеДляСортировки - Неопределено, НаправлениеСортировки - Направление для сортировки
//  Свернуть - Булево - Если ИСТИНА, то массив будет только из уникальных значений
// 
// Возвращаемое значение:
//  Массив из Произвольный - отсортированный массив
//
Функция СортироватьМассив(Знач ИсходныйМассив, Знач НаправлениеДляСортировки = Неопределено, Знач Свернуть = Ложь) Экспорт
	
	МассивДляРаботы = ?(Свернуть, СвернутьМассив(ИсходныйМассив), ИсходныйМассив);
	Если Не ЗначениеЗаполнено(НаправлениеДляСортировки) Тогда НаправлениеДляСортировки = НаправлениеСортировки.Возр; КонецЕсли;
	
	СписокЗначений = Новый СписокЗначений;
	СписокЗначений.ЗагрузитьЗначения(МассивДляРаботы);
	СписокЗначений.СортироватьПоЗначению(НаправлениеДляСортировки);
	
	Возврат СписокЗначений.ВыгрузитьЗначения();
	
КонецФункции

// Сортирует переданный массив структур по нужнуму ключу (алгоритм быстрой сортировки)
// 
// Параметры:
//  ИсходныйМассив - Массив из Структура
//  			   - Массив из ФиксированнаяСтруктура
//  			   - Массив из СтрокаТаблицыЗначений
//  КлючСтруктуры - Строка - Наименование ключа элемента массива, по которому нужно отсортировать массив
//  НаправлениеДляСортировки - Неопределено, НаправлениеСортировки - Направление для сортировки
//
Процедура СортироватьМассивСтруктурПоКлючу(Знач ИсходныйМассив, Знач КлючСтруктуры, Знач НаправлениеДляСортировки = Неопределено) Экспорт
	
	КоличествоЭлементов = ИсходныйМассив.Количество();
	Если КоличествоЭлементов > 0 Тогда
		
		Если НаправлениеДляСортировки = НаправлениеСортировки.Убыв Тогда
			СортироватьМассивСтруктурПоКлючу_Рекурсия_ПоУбыванию(ИсходныйМассив, КлючСтруктуры, 0, КоличествоЭлементов - 1);
		Иначе
			СортироватьМассивСтруктурПоКлючу_Рекурсия_ПоВозрастанию(ИсходныйМассив, КлючСтруктуры, 0, КоличествоЭлементов - 1);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Преобразует исходное значение в массив, содержащий элемент исходного значения.
// Если передан массив (или таблица значений), то значение не преобразуется.
// Если исходное значение пустое, то возвращается пустой массив.
// 
// Параметры:
//  Значение - Произвольный
//  ТипЗначения - Неопределено, Тип - Тип значения
//  
Процедура ЗначениеВМассив(Значение, Знач ТипЗначения = Неопределено) Экспорт
	
	Если ТипЗначения = Неопределено Тогда ТипЗначения = ТипЗнч(Значение); КонецЕсли;
	Если Не ЭтоМассив(Значение, ТипЗначения) И Не ЭтоТаблицаЗначений(Значение, ТипЗначения) Тогда
		
		ВременныйМассив = Новый Массив;
		
		Попытка
			Если ЗначениеЗаполнено(Значение) Тогда ВременныйМассив.Добавить(Значение); КонецЕсли;
		Исключение
			ВременныйМассив.Добавить(Значение);
		КонецПопытки;
		
		Значение = ВременныйМассив;
		
	КонецЕсли;
	
КонецПроцедуры

// Создает массив и помещает в него переданное значение.
//
// Параметры:
//  Значение - Произвольный - любое значение.
//
// Возвращаемое значение:
//  Массив из Произвольный - массив из одного элемента.
//
Функция ЗначениеВМассиве(Знач Значение) Экспорт
	
	МассивРезультат = Новый Массив();
	МассивРезультат.Добавить(Значение);
	
	Возврат МассивРезультат;
	
КонецФункции

// Возвращает флаг того, что массив состоит из произвольных элементов одного типа.
// 
// Параметры:
//  МассивДляПроверки - Массив из Произвольный
// 
// Возвращаемое значение:
//  Булево
//
Функция МассивСостоитИзОдногоТипа(Знач МассивДляПроверки) Экспорт
	
	Если МассивДляПроверки.Количество() = 0 Тогда Возврат Истина; КонецЕсли;
	
	НулевойТип = ТипЗнч(МассивДляПроверки.Получить(0));
	Для Каждого ЗначениеМассива Из МассивДляПроверки Цикл Если ТипЗнч(ЗначениеМассива) <> НулевойТип Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
	Возврат Истина;
	
КонецФункции

#КонецОбласти

// Возвращает разность коллекций. Разностью двух коллекций является коллекция, содержащая все элементы первой коллекции, не существующие во второй коллекции.
// Если количество элементов достаточно большое, то разность высчитывается через запрос (так быстрее).
// В данном случае необходимо передать ОписаниеТипов (иначе будет использован составной тип, состоящий из всех типов).
// Ограничения по типам данных (если не передавать ОписаниеТипов):
//   - ЛюбаяСсылка, Строка, Дата, Число, Булево
// 
// Параметры:
//  ОбъектУменьшаемое - Массив из Произвольный
//  				  - ФиксированныйМассив из Произвольный
//  				  - Структура
//  				  - ФиксированнаяСтруктура
//  				  - Соответствие из КлючИЗначение
//  				  - ФиксированноеСоответствие из КлючИЗначение
//  				  - СписокЗначений из Произвольный
//  ОбъектВычитаемое - Массив из Произвольный
//  				 - ФиксированныйМассив из Произвольный
//  				 - Структура
//  				 - ФиксированнаяСтруктура
//  				 - Соответствие из КлючИЗначение
//  				 - ФиксированноеСоответствие из КлючИЗначение
//  				 - СписокЗначений из Произвольный
//  ОписаниеТипов - Неопределено, ОписаниеТипов - Описание типов для передачи в запрос
//  ПринудительноЧерезКод - Булево - Если ИСТИНА, то разность будет высчитана принудительно через код
// 
// Возвращаемое значение:
//  - Массив из Произвольный
//  - ФиксированныйМассив из Произвольный
//  - Структура
//  - ФиксированнаяСтруктура
//  - Соответствие из КлючИЗначение
//  - ФиксированноеСоответствие из КлючИЗначение
//  - СписокЗначений из Произвольный
//
Функция РазностьОбъектов(Знач ОбъектУменьшаемое, Знач ОбъектВычитаемое, Знач ОписаниеТипов = Неопределено, Знач ПринудительноЧерезКод = Ложь) Экспорт
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		
		Возврат ?(ПринудительноЧерезКод Или ОбъектУменьшаемое.Количество() < 7000, // Сериализация долгая
				РазностьОбъектов_Стандартная(ОбъектУменьшаемое, ОбъектВычитаемое),
				Спец_ОбщегоНазначенияВызовСервера.РазностьОбъектов_ЧерезЗапрос(ОбъектУменьшаемое, ОбъектВычитаемое, ОписаниеТипов));
		
	#Иначе
		
		Возврат ?(ПринудительноЧерезКод Или ОбъектУменьшаемое.Количество() < 1500,
			РазностьОбъектов_Стандартная(ОбъектУменьшаемое, ОбъектВычитаемое),
			Спец_ОбщегоНазначения.РазностьОбъектов_ЧерезЗапрос(ОбъектУменьшаемое, ОбъектВычитаемое, ОписаниеТипов));
		
	#КонецЕсли
	
КонецФункции

// Возвращает значение свойства структуры.
//
// Параметры:
//   Структура - Структура
//   		   - ДанныеФормыСтруктура
//             - ФиксированнаяСтруктура - объект, из которого необходимо прочитать значение ключа.
//   Ключ - Строка - имя свойства структуры, для которого необходимо прочитать значение.
//   ЗначениеПоУмолчанию - Произвольный - возвращается когда в структуре нет значения по указанному ключу.
//       Для скорости рекомендуется передавать только быстро вычисляемые значения (например примитивные типы),
//       а инициализацию более тяжелых значений выполнять после проверки полученного значения (только если это требуется).
//
// Возвращаемое значение:
//   Произвольный
//
Функция СвойствоСтруктуры(Знач Структура, Знач Ключ, Знач ЗначениеПоУмолчанию = Неопределено) Экспорт
	//@skip-check variable-value-type
	Перем Результат;
	
	Если Структура = Неопределено Тогда Возврат ЗначениеПоУмолчанию; Иначе Возврат ?(Структура.Свойство(Ключ, Результат), Результат, ЗначениеПоУмолчанию); КонецЕсли;
	
КонецФункции

// Возвращает значение свойства соответствия.
//
// Параметры:
//   Соответствие - Соответствие из КлючИЗначение
//				  - ФиксированноеСоответствие из КлючИЗначение - объект, из которого необходимо прочитать значение ключа.
//   Ключ - Произвольный - имя свойства соответствия, для которого необходимо прочитать значение.
//   ЗначениеПоУмолчанию - Произвольный - возвращается когда в структуре нет значения по указанному ключу.
//       Для скорости рекомендуется передавать только быстро вычисляемые значения (например примитивные типы),
//       а инициализацию более тяжелых значений выполнять после проверки полученного значения (только если это требуется).
//
// Возвращаемое значение:
//   Произвольный
//
Функция СвойствоСоответствия(Знач Соответствие, Знач Ключ, Знач ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если Соответствие = Неопределено Тогда Возврат ЗначениеПоУмолчанию; Иначе Результат = Соответствие.Получить(Ключ); Возврат ?(Результат = Неопределено, ЗначениеПоУмолчанию, Результат); КонецЕсли;
	
КонецФункции

// Сравнивает данные сложной структуры с учетом вложенности.
// 
//@skip-check unknown-method-property
// 
// Параметры:
//  Данные1 - Произвольный - объект, который необходимо скопировать
//  		- ТаблицаЗначений
//  		- Структура
//  		- ФиксированнаяСтруктура
//  		- Соответствие из Произвольный
//  		- ФиксированноеСоответствие из Произвольный
//  		- Массив из Произвольный
//  		- ФиксированныйМассив из Произвольный
//  		- СписокЗначений из Произвольный
//  		- ХранилищеЗначения
//  Данные2 - Произвольный - объект, который необходимо скопировать
//  		- ТаблицаЗначений
//  		- Структура
//  		- ФиксированнаяСтруктура
//  		- Соответствие из Произвольный
//  		- ФиксированноеСоответствие из Произвольный
//  		- Массив из Произвольный
//  		- ФиксированныйМассив из Произвольный
//  		- СписокЗначений из Произвольный
//  		- ХранилищеЗначения
// 
// Возвращаемое значение:
//  Булево
//
Функция ДанныеСовпадают(Знач Данные1, Знач Данные2) Экспорт
	
	Тип1 = ТипЗнч(Данные1);
	Тип2 = ТипЗнч(Данные2);
	
	Если Тип1 <> Тип2 Тогда Возврат Ложь; КонецЕсли;
	Если ЭтоСтруктура(Данные1, Тип1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда Возврат Ложь; КонецЕсли;
		Для Каждого КлючИЗначение Из Данные1 Цикл СтароеЗначение = Неопределено; Если Не Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение) Или Не ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
		Возврат Истина;
		
	ИначеЕсли ЭтоСоответствие(Данные1, Тип1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда Возврат Ложь; КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		//@skip-check invocation-parameter-type-intersect
		//@skip-check wrong-type-expression
		Для Каждого КлючИЗначение Из Данные1 Цикл КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина); СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ); Если Не ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
		Для Каждого КлючИЗначение Из Данные2 Цикл Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ЭтоМассив(Данные1, Тип1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда Возврат Ложь; КонецЕсли;
		
		Индекс = Данные1.Количество() - 1;
		Пока Индекс >= 0 Цикл Если Не ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда Возврат Ложь; КонецЕсли; Индекс = Индекс - 1; КонецЦикла;
		Возврат Истина;
		
	ИначеЕсли ЭтоТаблицаЗначений(Данные1, Тип1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда Возврат Ложь; КонецЕсли;
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда Возврат Ложь; КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда Возврат Ложь; КонецЕсли;
			Индекс = Данные1.Количество() - 1;
			Пока Индекс >= 0 Цикл Если Не ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда Возврат Ложь; КонецЕсли; Индекс = Индекс - 1; КонецЦикла;
			
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ЭтоХранилищеЗначения(Данные1, Тип1) Тогда
		
		#Если Не ТонкийКлиент И Не ВебКлиент И Не ТолстыйКлиентУправляемоеПриложение Тогда
			
			//@skip-check empty-except-statement
			Попытка
				//@skip-check variable-value-type
				ДанныеДляПроверки1 = Спец_ОбщегоНазначения.ПолучитьЗначениеХранилищаЗначения(Данные1);
			Исключение
			КонецПопытки;
			
			//@skip-check empty-except-statement
			Попытка
				//@skip-check variable-value-type
				ДанныеДляПроверки2 = Спец_ОбщегоНазначения.ПолучитьЗначениеХранилищаЗначения(Данные2);
			Исключение
			КонецПопытки;
			
			Возврат ДанныеСовпадают(ДанныеДляПроверки1, ДанныеДляПроверки2);
			
		#КонецЕсли
		
	Иначе
		
		Возврат Данные1 = Данные2;
		
	КонецЕсли;
	
КонецФункции

//@skip-check empty-except-statement
//@skip-check unknown-method-property
//
// См. ДанныеСовпадают
// Работает сильно дольше. Если одного типа, и не массив структур например, то лучше воспользоваться "ДанныеСовпадают".
// 
// Параметры:
//  Данные1 - см. ДанныеСовпадают.Данные1
//  Данные2 - см. ДанныеСовпадают.Данные2
// 
// Возвращаемое значение:
//  Булево
//
Функция ДанныеСовпадаютБезУчетаПорядка(Знач Данные1, Знач Данные2) Экспорт
	
	ТипДанных1 = ТипЗнч(Данные1);
	ТипДанных2 = ТипЗнч(Данные2);
	
	Если ТипДанных1 <> ТипДанных2 Тогда
		
		НеМожемСравнить = Истина;
		Если ((ЭтоМассив(Данные1, ТипДанных1) Или ТипДанных1 = Тип("СписокЗначений"))
				И (ЭтоМассив(Данные2, ТипДанных2) Или ТипДанных2 = Тип("СписокЗначений")))
			Или ((ЭтоСтруктура(Данные1, ТипДанных1) Или ЭтоСоответствие(Данные1, ТипДанных1))
				И (ЭтоСтруктура(Данные2, ТипДанных2) Или ЭтоСоответствие(Данные2, ТипДанных2))) Тогда
			
			НеМожемСравнить = Ложь;
			
		КонецЕсли;
		
		Если НеМожемСравнить Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЭтоСтруктура(Данные1, ТипДанных1) Или ЭтоСоответствие(Данные1, ТипДанных1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если ЭтоСтруктура(Данные2, ТипДанных2) Тогда
			
			Для Каждого КлючЗначение Из Данные1 Цикл
				
				ВтороеЗначение = Неопределено;
				Если Не Данные2.Свойство(КлючЗначение.Ключ, ВтороеЗначение)
					Или Не ДанныеСовпадаютБезУчетаПорядка(КлючЗначение.Значение, ВтороеЗначение) Тогда
					
					Возврат Ложь;
					
				КонецЕсли;
				
			КонецЦикла;
			
			Возврат Истина;
			
		ИначеЕсли ЭтоСоответствие(Данные2, ТипДанных2) Тогда
			
			Для Каждого КлючЗначение Из Данные1 Цикл
				
				//@skip-check invocation-parameter-type-intersect
				//@skip-check wrong-type-expression
				ВтороеЗначение = Данные2.Получить(КлючЗначение.Ключ);
				Если ВтороеЗначение = Неопределено
					Или Не ДанныеСовпадаютБезУчетаПорядка(КлючЗначение.Значение, ВтороеЗначение) Тогда
					
					Возврат Ложь;
					
				КонецЕсли;
				
			КонецЦикла;
			
			Возврат Истина;
			
		Иначе
			
			Возврат Ложь;
			
		КонецЕсли;
		
	ИначеЕсли ЭтоМассив(Данные1, ТипДанных1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если ЭтоМассив(Данные2, ТипДанных2) Тогда
			
			Для Каждого Элемент Из Данные1 Цикл
				
				Найден = Ложь;
				Для Каждого ВторойЭлемент Из Данные2 Цикл
					
					Если ДанныеСовпадаютБезУчетаПорядка(Элемент, ВторойЭлемент) Тогда
						
						Найден = Истина;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не Найден Тогда
					Возврат Ложь;
				КонецЕсли;
				
			КонецЦикла;
			
			Возврат Истина;
			
		ИначеЕсли ТипДанных2 = Тип("СписокЗначений") Тогда
			
			Для Каждого Элемент Из Данные1 Цикл
				
				Найден = Ложь;
				Для Каждого СтрокаВторойЭлемент Из Данные2 Цикл
					
					Если ДанныеСовпадаютБезУчетаПорядка(Элемент, СтрокаВторойЭлемент.Значение) Тогда
						
						Найден = Истина;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не Найден Тогда
					Возврат Ложь;
				КонецЕсли;
				
			КонецЦикла;
			
			Возврат Истина;
			
		Иначе
			
			Возврат Ложь;
			
		КонецЕсли;
		
	ИначеЕсли ТипДанных1 = Тип("СписокЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если ЭтоМассив(Данные2, ТипДанных2) Тогда
			
			Для Каждого Элемент Из Данные1 Цикл
				
				Найден = Ложь;
				Для Каждого ВторойЭлемент Из Данные2 Цикл
					
					Если ДанныеСовпадаютБезУчетаПорядка(Элемент.Значение, ВторойЭлемент) Тогда
						
						Найден = Истина;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не Найден Тогда
					Возврат Ложь;
				КонецЕсли;
				
			КонецЦикла;
			
			Возврат Истина;
			
		ИначеЕсли ТипДанных2 = Тип("СписокЗначений") Тогда
			
			Для Каждого Элемент Из Данные1 Цикл
				
				Найден = Ложь;
				Для Каждого СтрокаВторойЭлемент Из Данные2 Цикл
					
					Если ДанныеСовпадаютБезУчетаПорядка(Элемент.Значение, СтрокаВторойЭлемент.Значение) Тогда
						
						Найден = Истина;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не Найден Тогда
					Возврат Ложь;
				КонецЕсли;
				
			КонецЦикла;
			
			Возврат Истина;
			
		Иначе
			
			Возврат Ложь;
			
		КонецЕсли;
		
	ИначеЕсли ЭтоТаблицаЗначений(Данные1, ТипДанных1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для Каждого Колонка1 Из Данные1.Колонки Цикл
			
			Если Данные2.Колонки.Найти(Колонка1.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Для Каждого Строка1 Из Данные1 Цикл
				
				Найден = Ложь;
				Для Каждого Строка2 Из Данные2 Цикл
					
					Если ДанныеСовпадаютБезУчетаПорядка(Строка1[Колонка1.Имя], Строка2[Колонка1.Имя]) Тогда
						
						Найден = Истина;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не Найден Тогда
					Возврат Ложь;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ЭтоХранилищеЗначения(Данные1, ТипДанных1) Тогда
		
		#Если Не ТонкийКлиент И Не ВебКлиент И Не ТолстыйКлиентУправляемоеПриложение Тогда
			
			Если Не ДанныеСовпадаютБезУчетаПорядка(Данные1.Получить(), Данные2.Получить()) Тогда
				Возврат Ложь;
			КонецЕсли;
			
		#КонецЕсли
		
		Возврат Истина;
		
	Иначе
		
		Возврат Данные1 = Данные2;
		
	КонецЕсли;
	
КонецФункции

// Возвращает флаг того, что исходный объект содержит ключ (поле, столбец, и т.п.).
// 
// Параметры:
//  ИсходныйОбъект - Произвольный - Объект для проверки
//  КлючДляПроверки - Строка
// 
// Возвращаемое значение:
//  Булево
//
Функция ЕстьРеквизитОбъекта(Знач ИсходныйОбъект, Знач КлючДляПроверки) Экспорт
	
	УникальныйИдентификаторДляПроверки = Новый УникальныйИдентификатор();
	СтруктураДляПроверки = Новый Структура(КлючДляПроверки, УникальныйИдентификаторДляПроверки);
	
	Попытка
		
		ЗаполнитьЗначенияСвойств(СтруктураДляПроверки, ИсходныйОбъект);
		Возврат СтруктураДляПроверки[КлючДляПроверки] <> УникальныйИдентификаторДляПроверки;
		
	Исключение
		
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции

#КонецОбласти

//@skip-check variable-value-type
#Область СлужебныеПроцедурыИФункции

//@skip-check statement-type-change
//@skip-check invocation-parameter-type-intersect
Функция РазностьОбъектов_Стандартная(Знач Объект1, Знач Объект2)
	
	ИсходныйТип = ТипЗнч(Объект1);
	Если ЭтоМассив(Объект1, ИсходныйТип) Тогда
		
		Результат = Новый Массив;
		Для Каждого Элемент Из Объект1 Цикл Если Объект2.Найти(Элемент) = Неопределено Тогда Результат.Добавить(Элемент); КонецЕсли; КонецЦикла;
		
	ИначеЕсли ЭтоСтруктура(Объект1, ИсходныйТип) Тогда
		
		Результат = Новый Структура;
		Для Каждого КлючЗначение Из Объект1 Цикл Если Не Объект2.Свойство(КлючЗначение.Ключ) Тогда Результат.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение); КонецЕсли; КонецЦикла;
		
	ИначеЕсли ЭтоСоответствие(Объект1, ИсходныйТип) Тогда
		
		Результат = Новый Соответствие;
		Для Каждого КлючЗначение Из Объект1 Цикл Если Объект2.Получить(КлючЗначение.Ключ) = Неопределено Тогда Результат[КлючЗначение.Ключ] = КлючЗначение.Значение; КонецЕсли; КонецЦикла;
		
	ИначеЕсли ИсходныйТип = Тип("СписокЗначений") Тогда
		
		Результат = Новый СписокЗначений;
		Для Каждого Строка Из Объект1 Цикл Если Объект2.НайтиПоЗначению(Строка.Значение) = Неопределено Тогда Результат.Добавить(Строка.Значение, Строка.Представление, Строка.Пометка, Строка.Картинка); КонецЕсли; КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура СортироватьМассивСтруктурПоКлючу_Рекурсия_ПоВозрастанию(МассивРезультат, Знач КлючСтруктуры, Знач ЛеваяГраница, Знач ПраваяГраница)
	
	i     = ЛеваяГраница;
	j     = ПраваяГраница;
	pivot = МассивРезультат[(i + j) / 2][КлючСтруктуры];
	
	Пока i < j Цикл Пока МассивРезультат[i][КлючСтруктуры] < pivot Цикл i = i + 1; КонецЦикла; Пока МассивРезультат[j][КлючСтруктуры] > pivot Цикл j = j - 1; КонецЦикла; Если i <= j Тогда Спец_ОбщегоНазначенияКлиентСервер.Swap(МассивРезультат[i], МассивРезультат[j]); i = i + 1; j = j - 1; КонецЕсли; КонецЦикла;
	Если j > ЛеваяГраница Тогда СортироватьМассивСтруктурПоКлючу_Рекурсия_ПоВозрастанию(МассивРезультат, КлючСтруктуры, ЛеваяГраница, j); КонецЕсли;
	Если i < ПраваяГраница Тогда СортироватьМассивСтруктурПоКлючу_Рекурсия_ПоВозрастанию(МассивРезультат, КлючСтруктуры, i, ПраваяГраница); КонецЕсли;
	
КонецПроцедуры

Процедура СортироватьМассивСтруктурПоКлючу_Рекурсия_ПоУбыванию(МассивРезультат, Знач КлючСтруктуры, Знач ЛеваяГраница, Знач ПраваяГраница)
	
	i     = ЛеваяГраница;
	j     = ПраваяГраница;
	pivot = МассивРезультат[(i + j) / 2][КлючСтруктуры];
	
	Пока i < j Цикл Пока МассивРезультат[i][КлючСтруктуры] > pivot Цикл i = i + 1; КонецЦикла; Пока МассивРезультат[j][КлючСтруктуры] < pivot Цикл j = j - 1; КонецЦикла; Если i <= j Тогда Спец_ОбщегоНазначенияКлиентСервер.Swap(МассивРезультат[i], МассивРезультат[j]); i = i + 1; j = j - 1; КонецЕсли; КонецЦикла;
	Если j > ЛеваяГраница Тогда СортироватьМассивСтруктурПоКлючу_Рекурсия_ПоУбыванию(МассивРезультат, КлючСтруктуры, ЛеваяГраница, j); КонецЕсли;
	Если i < ПраваяГраница Тогда СортироватьМассивСтруктурПоКлючу_Рекурсия_ПоУбыванию(МассивРезультат, КлючСтруктуры, i, ПраваяГраница); КонецЕсли;
	
КонецПроцедуры

//@skip-check invocation-parameter-type-intersect
//@skip-check empty-except-statement
#Область ВыгрузкаМассиваЗначений

//@skip-check unknown-method-property
//
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений
//  ИмяКолонки - см. ВыгрузитьМассивЗначений.ИмяКолонки
//  ТолькоУникальныеЗначения - см. ВыгрузитьМассивЗначений.ТолькоУникальныеЗначения
//  ИсключаяПустые - см. ВыгрузитьМассивЗначений.ИсключаяПустые
//  СтруктураОтбораДляВыгрузки - см. ВыгрузитьМассивЗначений.СтруктураОтбораДляВыгрузки
// 
// Возвращаемое значение:
//  см. ВыгрузитьМассивЗначений
//
Функция ВыгрузитьМассивЗначенийИзТаблицыЗначений(Знач ТаблицаЗначений, Знач ИмяКолонки, Знач ТолькоУникальныеЗначения, Знач ИсключаяПустые, Знач СтруктураОтбораДляВыгрузки)
	
	ТаблицаДляВыгрузки = ?(СтруктураОтбораДляВыгрузки = Неопределено, ТаблицаЗначений, ТаблицаЗначений.Скопировать(СтруктураОтбораДляВыгрузки, ИмяКолонки));
	Если ТолькоУникальныеЗначения Тогда ТаблицаДляВыгрузки.Свернуть(ИмяКолонки); КонецЕсли;
	
	Если ИсключаяПустые Тогда
		
		МассивРезультат = Новый Массив(); // Массив из Произвольный
		Для Каждого СтрокаТаблицы Из ТаблицаДляВыгрузки Цикл Попытка Если ЗначениеЗаполнено(СтрокаТаблицы[ИмяКолонки]) Тогда МассивРезультат.Добавить(СтрокаТаблицы[ИмяКолонки]); КонецЕсли; Исключение МассивРезультат.Добавить(СтрокаТаблицы[ИмяКолонки]); КонецПопытки; КонецЦикла;
		Возврат МассивРезультат;
		
	Иначе
		
		Возврат ТаблицаДляВыгрузки.ВыгрузитьКолонку(ИмяКолонки);
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  ДанныеФормыКоллекция - ДанныеФормыКоллекция
//  ИмяКолонки - см. ВыгрузитьМассивЗначений.ИмяКолонки
//  ТолькоУникальныеЗначения - см. ВыгрузитьМассивЗначений.ТолькоУникальныеЗначения
//  ИсключаяПустые - см. ВыгрузитьМассивЗначений.ИсключаяПустые
//  СтруктураОтбораДляВыгрузки - см. ВыгрузитьМассивЗначений.СтруктураОтбораДляВыгрузки
// 
// Возвращаемое значение:
//  см. ВыгрузитьМассивЗначений
//
Функция ВыгрузитьМассивЗначенийИзДанныхФормыКоллекции(Знач ДанныеФормыКоллекция, Знач ИмяКолонки, Знач ТолькоУникальныеЗначения, Знач ИсключаяПустые, Знач СтруктураОтбораДляВыгрузки)
	
	#Если Сервер Тогда
		
		Возврат ВыгрузитьМассивЗначенийИзТаблицыЗначений(ДанныеФормыКоллекция.Выгрузить(СтруктураОтбораДляВыгрузки, ИмяКолонки),
				ИмяКолонки,
				ТолькоУникальныеЗначения,
				ИсключаяПустые,
				Неопределено);
		
	#Иначе
		
		Возврат ?(ТолькоУникальныеЗначения,
				ВыгрузитьМассивЗначений_ТолькоУникальные(ДанныеФормыКоллекция, ИмяКолонки, ИсключаяПустые, СтруктураОтбораДляВыгрузки),
				ВыгрузитьМассивЗначений_Все(ДанныеФормыКоллекция, ИмяКолонки, ИсключаяПустые, СтруктураОтбораДляВыгрузки));
		
	#КонецЕсли
	
КонецФункции

// Параметры:
//	КоллекцияЗначений - см. ВыгрузитьМассивЗначений.КоллекцияЗначений
//	ИмяКолонки - см. ВыгрузитьМассивЗначений.ИмяКолонки
//	ИсключаяПустые - см. ВыгрузитьМассивЗначений.ИсключаяПустые
//	СтруктураОтбораДляВыгрузки - см. ВыгрузитьМассивЗначений.СтруктураОтбораДляВыгрузки
// 
// Возвращаемое значение:
//	см. ВыгрузитьМассивЗначений
//
Функция ВыгрузитьМассивЗначений_ТолькоУникальные(Знач КоллекцияЗначений, Знач ИмяКолонки, Знач ИсключаяПустые, Знач СтруктураОтбораДляВыгрузки)
	
	МассивРезультат = Новый Массив(); // Массив из см. КоллекцияЗначений
	УникальныеЗначения = Новый Соответствие();
	
	Если СтруктураОтбораДляВыгрузки = Неопределено Тогда
		
		Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
			
			Если УникальныеЗначения[ЭлементКоллекции[ИмяКолонки]] <> Неопределено Тогда Продолжить; КонецЕсли;
			
			Если ИсключаяПустые Тогда
				
				
				Попытка
					
					Если Не ЗначениеЗаполнено(ЭлементКоллекции[ИмяКолонки]) Тогда
						
						УникальныеЗначения[ЭлементКоллекции[ИмяКолонки]] = Истина;
						Продолжить;
						
					КонецЕсли;
					
				Исключение
				КонецПопытки;
				
			КонецЕсли;
			
			МассивРезультат.Добавить(ЭлементКоллекции[ИмяКолонки]);
			УникальныеЗначения[ЭлементКоллекции[ИмяКолонки]] = Истина;
			
		КонецЦикла;
		
	Иначе
		
		Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
			
			Если УникальныеЗначения[ЭлементКоллекции[ИмяКолонки]] <> Неопределено Тогда Продолжить; КонецЕсли;
			Если ИсключаяПустые Тогда
				
				Попытка
					
					Если Не ЗначениеЗаполнено(ЭлементКоллекции[ИмяКолонки]) Тогда
						
						УникальныеЗначения[ЭлементКоллекции[ИмяКолонки]] = Истина;
						Продолжить;
						
					КонецЕсли;
					
				Исключение
				КонецПопытки;
				
			КонецЕсли;
			
			ДобавляемЗначение = Истина;
			Для Каждого КлючЗначениеОтбор Из СтруктураОтбораДляВыгрузки Цикл
				
				Если ЭлементКоллекции[КлючЗначениеОтбор.Ключ] <> КлючЗначениеОтбор.Значение Тогда
					
					ДобавляемЗначение = Ложь;
					Прервать;
					
				КонецЕсли;
				
			КонецЦикла;
			
			Если ДобавляемЗначение Тогда
				
				МассивРезультат.Добавить(ЭлементКоллекции[ИмяКолонки]);
				УникальныеЗначения[ЭлементКоллекции[ИмяКолонки]] = Истина;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат МассивРезультат;
	
КонецФункции

// Параметры:
//	КоллекцияЗначений - см. ВыгрузитьМассивЗначений.КоллекцияЗначений
//	ИмяКолонки - см. ВыгрузитьМассивЗначений.ИмяКолонки
//	ИсключаяПустые - см. ВыгрузитьМассивЗначений.ИсключаяПустые
//	СтруктураОтбораДляВыгрузки - см. ВыгрузитьМассивЗначений.СтруктураОтбораДляВыгрузки
// 
// Возвращаемое значение:
//	см. ВыгрузитьМассивЗначений
//
Функция ВыгрузитьМассивЗначений_Все(Знач КоллекцияЗначений, Знач ИмяКолонки, Знач ИсключаяПустые, Знач СтруктураОтбораДляВыгрузки)
	
	МассивРезультат = Новый Массив(); // Массив из см. КоллекцияЗначений
	Если СтруктураОтбораДляВыгрузки = Неопределено Тогда
		
		Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл Если ИсключаяПустые Тогда Попытка Если Не ЗначениеЗаполнено(ЭлементКоллекции[ИмяКолонки]) Тогда Продолжить; КонецЕсли; Исключение КонецПопытки; КонецЕсли; МассивРезультат.Добавить(ЭлементКоллекции[ИмяКолонки]); КонецЦикла;
		
	Иначе
		
		Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
			
			Если ИсключаяПустые Тогда
				
				Попытка
					Если Не ЗначениеЗаполнено(ЭлементКоллекции[ИмяКолонки]) Тогда Продолжить; КонецЕсли;
				Исключение
				КонецПопытки;
				
			КонецЕсли;
			
			ДобавляемЗначение = Истина;
			Для Каждого КлючЗначениеОтбор Из СтруктураОтбораДляВыгрузки Цикл Если ЭлементКоллекции[КлючЗначениеОтбор.Ключ] <> КлючЗначениеОтбор.Значение Тогда ДобавляемЗначение = Ложь; Прервать; КонецЕсли; КонецЦикла;
			Если ДобавляемЗначение Тогда МассивРезультат.Добавить(ЭлементКоллекции[ИмяКолонки]); КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат МассивРезультат;
	
КонецФункции

#КонецОбласти

#КонецОбласти
