// @strict-types

//@skip-check method-too-many-params

#Область ПрограммныйИнтерфейс

// Выбрасывает исключение, если текущая база не PostgreSQL.
//
Процедура ИсключениеЕслиНеPostgreSQLБаза() Экспорт
	
	Спец_Проверить(Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы().ТипБазыДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL"),
			"Это не PostgreSQL база! Если это не так, выполните обработку обновления.");
	
КонецПроцедуры

// Подключить компоненту с инициализированным подключением.
// 
// Параметры:
//	КонстантноеИмяКомпоненты - Булево - Формировать компоненту с постоянным именем
// 
// Возвращаемое значение:
//	см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.ПолучитьКомпонентуPostgreSQL
//
Функция ПодключитьКомпонентуСИнициализированнымПодключением(Знач КонстантноеИмяКомпоненты = Истина) Экспорт

	ИсключениеЕслиНеPostgreSQLБаза();

	ВнешняяКомпонента = Спец_КомпонентаДополнительныеФункцииКлиентСервер.ПолучитьКомпонентуPostgreSQL(КонстантноеИмяКомпоненты);
	Спец_Проверить(ВнешняяКомпонента <> Неопределено, "Не удалось подключить внешнюю компоненту", "Подключить компоненту с инициализированным подключением");
	
	СтрокаПодключения = ПодготовитьСтрокуПодключенияКPostgreSQL();
	
	ВременныйКэш = Новый Структура("КомпонентаPostgreSQL", ВнешняяКомпонента);
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLУстановитьСоединение(СтрокаПодключения, ВременныйКэш);
	
	Возврат ВнешняяКомпонента;

КонецФункции

// Выполняет запрос к PostgreSQL и получает размер любого объекта (индекса, таблицы) в БД (в байтах).
// 
// Параметры:
//	НаименованиеОбъекта - Строка - Наименование объекта в PostgreSQL
//	НуженОбщийРазмерТаблицы - Булево - Нужно вернуть общий размер таблицы (pg_total_relation_size)
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Число - Размер объекта в PostgreSQL
//
Функция ПолучитьРазмерОбъектаВPostgreSQL(Знач НаименованиеОбъекта, Знач НуженОбщийРазмерТаблицы = Ложь, Кэш = Неопределено) Экспорт
	
	Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLСоединениеУспешноУстановлено(Кэш),
			"Не удалось подключиться к базе PostgreSQL!",
			"Спец_PostgreSQLКлиентСервер.ПолучитьРазмерОбъектаВPostgreSQL");
	
	Если НуженОбщийРазмерТаблицы Тогда
		ТекстСкрипта = СтрШаблон("SELECT pg_total_relation_size('%1') AS sizeObject", НаименованиеОбъекта);
	Иначе
		ТекстСкрипта = СтрШаблон("SELECT pg_relation_size('%1') AS sizeObject", НаименованиеОбъекта);
	КонецЕсли;

	СтруктураРезультатЗапроса = ПолучитьРезультатЗапросаРазмерТаблицы(ТекстСкрипта, Кэш);
	Если СтруктураРезультатЗапроса.Успешно Тогда
		Возврат СтруктураРезультатЗапроса.РезультатЗапроса.Получить(0).sizeObject;
	Иначе
		Возврат 0;
	КонецЕсли;

КонецФункции

// Подключает компоненту PostgreSQL для нужной базы и помещает её в общий кэш.
// Возвращает значение, которое необходимо передавать в параметр "Кэш" для выполнения запросов к нужной базе.
// 
// Параметры:
//  База - СправочникСсылка.Спец_Базы
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Структура:
//		* КомпонентаPostgreSQL - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.ПолучитьКомпонентуPostgreSQL
Функция ПодключитьКомпонентуPostgreSQLДляДругойБазы(Знач База, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	Если Кэш.КомпонентыPostgreSQLДляДругихБаз[База] <> Неопределено Тогда Возврат Кэш.КомпонентыPostgreSQLДляДругихБаз[База]; КонецЕсли;
	
	СтруктураПараметровБазы = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы(База);
	Если СтруктураПараметровБазы.ТипБазыДанных <> ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL")
		Или ПустаяСтрока(СтруктураПараметровБазы.СтрокаПодключенияКБазеДанных) Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Спец_ЗаписатьЛог("Получение компоненты PostgreSQL для другой базы",
			ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Информация"),
			"Попытка получения компоненты PostgreSQL с подключением к базе " + СтруктураПараметровБазы.НаименованиеБазы,
			Кэш);
	
	Попытка
		
		КомпонентаРезультат = Спец_ОбщегоНазначенияКлиентСервер.ПодключитьВнешнююКомпонентуДляРаботы("ОбщийМакет.Спец_КомпонентаLykovPostgreSQL",
				Спец_СтроковыеФункцииКлиентСервер.СтрокаЛатиницей(СтруктураПараметровБазы.ИмяБазы),
				"PostgreSQL",
				Истина,
				Истина);
		
		Спец_Проверить(КомпонентаРезультат <> Неопределено,
				"Не удалось подключить компоненту!",
				"Спец_PostgreSQLКлиентСервер.ПодключитьКомпонентуPostgreSQLДляДругойБазы");
		
		СтруктураРезультат = Новый Структура("КомпонентаPostgreSQL", КомпонентаРезультат);
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLУстановитьСоединение(СтруктураПараметровБазы.СтрокаПодключенияКБазеДанных, СтруктураРезультат);
		
		Кэш.КомпонентыPostgreSQLДляДругихБаз[База] = СтруктураРезультат;
		Возврат Кэш.КомпонентыPostgreSQLДляДругихБаз[База];
		
	Исключение
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(), "Подключение к PostgreSQL другой базы");
		Возврат Неопределено;
		
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область ПомещениеДанныхВоВременнуюТаблицу

// см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПоместитьТаблицу1СВоВременнуюТаблицу
// 
// Параметры:
//	ИсходныеДанные - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПоместитьТаблицу1СВоВременнуюТаблицу.ИсходныеДанные
//	ПараметрыПомещения - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПоместитьТаблицу1СВоВременнуюТаблицу.ПараметрыПомещения
//	ТекстОшибок - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПоместитьТаблицу1СВоВременнуюТаблицу.ТекстОшибок
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПоместитьТаблицу1СВоВременнуюТаблицу
//
Функция ПоместитьТаблицу1СВоВременнуюТаблицу(Знач ИсходныеДанные, Знач ПараметрыПомещения, ТекстОшибок, Знач Кэш) Экспорт
	
#Если Не ВебКлиент Тогда
	
	СтруктураТаблицыИзБД = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ПараметрыПомещения.ИмяМетаданныхИз1С);
	СоответствиеКолонок  = ПодготовитьКолонкиТаблицыДляПомещенияВоВременнуюТаблицу(ИсходныеДанные, ПараметрыПомещения, СтруктураТаблицыИзБД, ТекстОшибок, Кэш);
	
	Если СоответствиеКолонок = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураТекстовЗапросов = СформироватьТекстыЗапросовДляПомещенияВоВременнуюТаблицу(ПараметрыПомещения, СоответствиеКолонок, СтруктураТаблицыИзБД, ТекстОшибок, Кэш);
	
	// 1. Создание временной таблицы
	Если Не ПустаяСтрока(СтруктураТекстовЗапросов.ТекстЗапросаСозданиеВременнойТаблицы) Тогда
		
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(СтруктураТекстовЗапросов.ТекстЗапросаСозданиеВременнойТаблицы, ТекстОшибок, Кэш);
		Если Не Успешно Тогда
			Возврат Неопределено;
		КонецЕсли;
		
	КонецЕсли;
	
	// 2. Запись данных в JSON
	ПередаватьЧерезФайлы = Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ЛучшеПередаватьЧерезФайлы(ИсходныеДанные);
	ПотокДляЗаписи = Неопределено; // ФайловыйПоток;
	
	Если ПередаватьЧерезФайлы Тогда

		ПотокДляЗаписи = Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьФайловыйПотокСИменемФайла();
		ЗаписьJSON = Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьЗаписьJSONПоПотоку(ПотокДляЗаписи);

	Иначе
	
		ЗаписьJSON = Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьЗаписьJSONДляПреобразованияВСтроку();

	КонецЕсли;
	
	// Есть косяк 1С (если записывать массив в JSON на основании потока, у которого первый элемент - пустая строка,
	// то вызывается <непростительное> исключение 'Не установлен источник потока' (https://bugboard.v8.1c.ru/error/000135963)
	// Когда-нибудь 1С решат мою заявку, а сейчас всё необходимо делать через попытку
	
	Если ПередаватьЧерезФайлы Тогда
		
		Попытка
			
			ЗаписатьДанныеДляПередачиВКомпоненту(ИсходныеДанные, ЗаписьJSON, СоответствиеКолонок, СтруктураТаблицыИзБД, Кэш);
			
		Исключение
			
			ПередаватьЧерезФайлы = Ложь;
			
			ЗаписьJSON.Закрыть();
			Спец_ОбщегоНазначенияКлиентСервер.ЗакрытьПотокНеМешаяРаботе(ПотокДляЗаписи);
			
			ЗаписьJSON = Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьЗаписьJSONДляПреобразованияВСтроку();
			ЗаписатьДанныеДляПередачиВКомпоненту(ИсходныеДанные, ЗаписьJSON, СоответствиеКолонок, СтруктураТаблицыИзБД, Кэш);
			
		КонецПопытки;
		
	Иначе
		
		ЗаписатьДанныеДляПередачиВКомпоненту(ИсходныеДанные, ЗаписьJSON, СоответствиеКолонок, СтруктураТаблицыИзБД, Кэш);
		
	КонецЕсли;
	
	Если ПередаватьЧерезФайлы Тогда
		
		ЗаписьJSON.Закрыть();
		Спец_ОбщегоНазначенияКлиентСервер.ЗакрытьПотокНеМешаяРаботе(ПотокДляЗаписи, Истина, Ложь);
		
		ДанныеДляПередачи = ПотокДляЗаписи.ИмяФайла;
		
	Иначе
		
		ДанныеДляПередачи = ЗаписьJSON.Закрыть();
		
	КонецЕсли;
	
	// 3. Передача данных
	Попытка
		
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВставитьДанныеВТаблицу(
				СтруктураТекстовЗапросов.НаименованиеТаблицыДляВставкиДанных,
				ДанныеДляПередачи,
				СтрСоединить(Спец_РаботаСКоллекциямиКлиентСервер.ВыгрузитьМассивЗначений(СоответствиеКолонок, "Ключ"), ","),
				ПередаватьЧерезФайлы,
				Кэш);
		
	Исключение
		
		Если ПередаватьЧерезФайлы Тогда
			Спец_ОбщегоНазначенияКлиентСервер.УдалитьФайлыНеМешаяРаботе(ДанныеДляПередачи);
		КонецЕсли;
		Если ПараметрыПомещения.НачинатьТранзакцию Тогда
			Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
		КонецЕсли;
		
		ТекстОшибки = СтрШаблон(
				"Не удалось передать данные в новую временную таблицу!
				|	Текст ошибки: %1",
				
				Спец_ОбщегоНазначенияКлиентСервер.ПодробноеПредставлениеОшибкиЧерезОбработкуОшибок(ИнформацияОбОшибке(), Символы.Таб));
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(
				ТекстОшибки,
				"Помещение таблицы во временную таблицу в PostgreSQL -> Вставка данных в таблицу",
				ТекстОшибок);
		
		Возврат Неопределено;
		
	КонецПопытки;
	
	Если ПередаватьЧерезФайлы Тогда
		Спец_ОбщегоНазначенияКлиентСервер.УдалитьФайлыНеМешаяРаботе(ДанныеДляПередачи);
	КонецЕсли;
	
	// 4. Формирование готовой таблицы
	Если Не ПустаяСтрока(СтруктураТекстовЗапросов.ТекстЗапросаСозданиеГотовойТаблицы) Тогда
		
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(СтруктураТекстовЗапросов.ТекстЗапросаСозданиеГотовойТаблицы, ТекстОшибок, Кэш);
		Если Не Успешно Тогда
			
			Если ПараметрыПомещения.НачинатьТранзакцию Тогда
				Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
			КонецЕсли;
			
			Возврат Неопределено;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// 5. Если требуется анализ - делаем это
	Если СтруктураТекстовЗапросов.ТребуетсяАнализ Тогда
		
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата("ANALYZE " + ПараметрыПомещения.ИмяВременнойТаблицы, ТекстОшибок, Кэш);
		Если Не Успешно Тогда
			
			Если ПараметрыПомещения.НачинатьТранзакцию Тогда
				Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
			КонецЕсли;
			
			Возврат Неопределено;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// 6. Возврат готовой структуры
	//@skip-check constructor-function-return-section
	Возврат Новый Структура("ИмяТаблицы, СоответствиеПолей", ПараметрыПомещения.ИмяВременнойТаблицы, СоответствиеКолонок);

#Иначе
	
	ВызватьИсключение "Недоступно на веб-клиенте!";
	
#КонецЕсли

КонецФункции

//@skip-check unknown-method-property
//
// Параметры:
//	ИсходныеДанные - см. ПоместитьТаблицу1СВоВременнуюТаблицу.ИсходныеДанные
//	ПараметрыПомещения - см. ПоместитьТаблицу1СВоВременнуюТаблицу.ПараметрыПомещения
//	СтруктураТаблицыИз1С - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//	ТекстОшибок - см. ПоместитьТаблицу1СВоВременнуюТаблицу.ТекстОшибок
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//	
// Возвращаемое значение:
//	Соответствие из КлючИЗначение:
//		* Ключ - Строка
//		* Значение - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
//
Функция ПодготовитьКолонкиТаблицыДляПомещенияВоВременнуюТаблицу(Знач ИсходныеДанные, Знач ПараметрыПомещения, Знач СтруктураТаблицыИз1С, ТекстОшибок, Знач Кэш) Экспорт
	
	СоответствиеРезультат     = Новый Соответствие();
	ЕстьЗаписиВИсходныхДанных = ИсходныеДанные.Количество() > 0;
	
	ТипИсходныхДанных = ТипЗнч(ИсходныеДанные);
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ИсходныеДанные, ТипИсходныхДанных) Тогда
		
		Для Каждого КолонкаТаблицы Из ИсходныеДанные.Колонки Цикл
			
			МассивКолонокБД = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицыИз1С.Поля, КолонкаТаблицы.Имя); // Массив из Строка
			Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивКолонокБД);
			
			Если МассивКолонокБД.Количество() Тогда
				
				ДобавитьНайденнуюКолонкуВСоответствиеРезультат(СоответствиеРезультат, МассивКолонокБД, СтруктураТаблицыИз1С.ПоляPostgreSQL);
				
			ИначеЕсли КолонкаТаблицы.ТипЗначения.Типы().Количество() Тогда
				
				СоответствиеРезультат[КолонкаТаблицы.Имя] = СтруктураПоляПоОписаниюТипов(КолонкаТаблицы.Имя, КолонкаТаблицы.ТипЗначения, Кэш);
				
			Иначе
				
				Если Не ЕстьЗаписиВИсходныхДанных Тогда
					
					ТекстОшибки = "Для определения типа колонки нужна хотя бы одна запись в исходных данных!";
					Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибки, "Спец_PostgreSQLКлиентСервер.ПодготовитьПараметрыТаблицы1С(...)", ТекстОшибок);
					
					Возврат Неопределено;
					
				КонецЕсли;
				
				НулеваяСтрока = ИсходныеДанные.Получить(0);
				ТипКолонки = ТипЗнч(НулеваяСтрока[КолонкаТаблицы.Имя]);
				
				Если Не Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(НулеваяСтрока, ТипКолонки)
					И Не Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(НулеваяСтрока, ТипКолонки) Тогда
					
					СоответствиеРезультат[КолонкаТаблицы.Имя] = СтруктураПоляПоТипуЗначения(КолонкаТаблицы.Имя, ТипКолонки, Кэш);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;

	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИсходныеДанные, ТипИсходныхДанных) Тогда

		Если Не ЕстьЗаписиВИсходныхДанных Тогда
		
			ТекстОшибки = "Для определения типа колонки нужна хотя бы одна запись в исходных данных!";
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибки, "Спец_PostgreSQLКлиентСервер.ПодготовитьПараметрыТаблицы1С(...)", ТекстОшибок);
			
			Возврат Неопределено;
		
		КонецЕсли;

		НулеваяСтрока = ИсходныеДанные.Получить(0);
		ТипСтроки = ТипЗнч(НулеваяСтрока);
		
		Если Не Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(НулеваяСтрока, ТипСтроки)
			И Не Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСоответствие(НулеваяСтрока, ТипСтроки) Тогда
			
			ТекстОшибки = "Могу определить только массив структур / соответствий!";
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибки, "Спец_PostgreSQLКлиентСервер.ПодготовитьПараметрыТаблицы1С(...)", ТекстОшибок);
			
			Возврат Неопределено;
			
		КонецЕсли;
		
		Для Каждого КлючЗначение Из НулеваяСтрока Цикл
			
			МассивКолонокБД = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицыИз1С.Поля, КлючЗначение.Ключ); // Массив из Строка
			Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивКолонокБД);
			
			Если МассивКолонокБД.Количество() Тогда
				
				ДобавитьНайденнуюКолонкуВСоответствиеРезультат(СоответствиеРезультат, МассивКолонокБД, СтруктураТаблицыИз1С.ПоляPostgreSQL);
				
			Иначе
				
				ТипКолонки = ТипЗнч(КлючЗначение.Значение);
				Если Не Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(КлючЗначение.Значение, ТипКолонки)
					И Не Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(КлючЗначение.Значение, ТипКолонки) Тогда
					
					СоответствиеРезультат[КлючЗначение.Ключ] = СтруктураПоляПоТипуЗначения(КлючЗначение.Ключ, ТипКолонки, Кэш);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе

		ТекстОшибки = "Могу определить только массив или таблицу значений";
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибки, "Спец_PostgreSQLКлиентСервер.ПодготовитьПараметрыТаблицы1С(...)", ТекстОшибок);
		
		Возврат Неопределено;

	КонецЕсли;

	Возврат СоответствиеРезультат;

КонецФункции

// Параметры:
//	ПараметрыПомещения - см. ПоместитьТаблицу1СВоВременнуюТаблицу.ПараметрыПомещения
//	СоответствиеКолонок - см. ПодготовитьКолонкиТаблицыДляПомещенияВоВременнуюТаблицу
//	СтруктураТаблицыИз1С - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//	ТекстОшибок - см. ПоместитьТаблицу1СВоВременнуюТаблицу.ТекстОшибок
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Структура:
//    * ТекстЗапросаСозданиеВременнойТаблицы - Строка
//    * ТекстЗапросаСозданиеГотовойТаблицы - Строка
//    * ТребуетсяАнализ - Булево
//    * НаименованиеТаблицыДляВставкиДанных - Строка
//
Функция СформироватьТекстыЗапросовДляПомещенияВоВременнуюТаблицу(Знач ПараметрыПомещения, Знач СоответствиеКолонок, Знач СтруктураТаблицыИз1С, ТекстОшибок, Знач Кэш) Экспорт
	
	//@skip-check structure-consructor-too-many-keys
	СтруктураРезультат = Новый Структура("ТекстЗапросаСозданиеВременнойТаблицы, ТекстЗапросаСозданиеГотовойТаблицы, ТребуетсяАнализ, НаименованиеТаблицыДляВставкиДанных",
			"", "", Ложь, "");
	
	ТребуетсяПодготовительнаяТаблица = Ложь;
	Для Каждого КлючЗначение Из СоответствиеКолонок Цикл
		
		Если Не ПустаяСтрока(КлючЗначение.Значение.ФункцияПреобразования) Тогда
			
			ТребуетсяПодготовительнаяТаблица = Истина;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Чистим наименование временной таблицы
	ПараметрыПомещения.ИмяВременнойТаблицы = ОчиститьНаименованиеТаблицы(ПараметрыПомещения.ИмяВременнойТаблицы);
	
	// Индекс (если требуется)
	СтрокаИндекс = "";
	Если ПараметрыПомещения.МассивПолейДляИндекса.Количество() Тогда
		
		МассивПолейИндекс = Новый Массив(); // Массив из Строка
		Для Каждого КлючЗначение Из СоответствиеКолонок Цикл
			
			Если ПараметрыПомещения.МассивПолейДляИндекса.Найти(КлючЗначение.Значение.ИмяВ1С) <> Неопределено Тогда
				МассивПолейИндекс.Добавить(КлючЗначение.Ключ);
			КонецЕсли;
			
		КонецЦикла;
		
		Если МассивПолейИндекс.Количество() Тогда
			
			СтрокаИндекс = СтрШаблон(
					"
					|CREATE INDEX %1 ON %2
					|	(%3)
					|	WITH (fillfactor = 100)
					|;
					|
					|
					|",
					
					ОчиститьНаименованиеТаблицы(ПараметрыПомещения.ИмяВременнойТаблицы + "_idx"),
					ПараметрыПомещения.ИмяВременнойТаблицы,
					СтрСоединить(МассивПолейИндекс, ", "));
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ТребуетсяПодготовительнаяТаблица Тогда
		
		СтруктураРезультат.НаименованиеТаблицыДляВставкиДанных = ПараметрыПомещения.ИмяВременнойТаблицы + "_prepare";
		
		// Текст запроса создания временной таблицы
		МассивТекстЗапроса = Новый Массив(); // Массив из Строка
		Если ПараметрыПомещения.НачинатьТранзакцию Тогда
			МассивТекстЗапроса.Добавить("BEGIN");
		КонецЕсли;
		
		МассивКолонокДляДобавления = Новый Массив(); // Массив из Строка
		Для Каждого КлючЗначение Из СоответствиеКолонок Цикл
			МассивКолонокДляДобавления.Добавить(СтрШаблон("%1 %2", КлючЗначение.Ключ, КлючЗначение.Значение.ИмяТипаДанныхВБД));
		КонецЦикла;
		
		МассивТекстЗапроса.Добавить(СтрШаблон(
				"CREATE TEMPORARY TABLE %1
				|(
				|	%2
				|)
				|WITH (OIDS=FALSE)",
				
				СтруктураРезультат.НаименованиеТаблицыДляВставкиДанных,
				СтрСоединить(МассивКолонокДляДобавления,
						",
						|	")));
		
		СтруктураРезультат.ТекстЗапросаСозданиеВременнойТаблицы = СтрСоединить(МассивТекстЗапроса, Спец_КонстантыКлиентСервер.РазделительЗапросовВPostgreSQL());
		
		// Текст создания готовой таблицы
		МассивТекстЗапроса.Очистить();
		
		МассивКолонокДляЗапроса = Новый Массив(); // Массив из Строка
		Для Каждого КлючЗначение Из СоответствиеКолонок Цикл
			
			МассивКолонокДляЗапроса.Добавить(
					?(Не ПустаяСтрока(КлючЗначение.Значение.ФункцияПреобразования),
							СтрШаблон(КлючЗначение.Значение.ФункцияПреобразования + " AS %1", КлючЗначение.Ключ),
							СтрШаблон("%1 AS %1", КлючЗначение.Ключ)));
			
		КонецЦикла;
		
		СтруктураРезультат.ТекстЗапросаСозданиеГотовойТаблицы = СтрШаблон(
				"CREATE TEMPORARY TABLE %2
				|WITH (OIDS=FALSE)
				|ON COMMIT DROP AS
				|(
				|	SELECT %1
				|	FROM %2_prepare
				|)
				|;
				|
				|
				|DROP TABLE %2_prepare;
				|
				|%3
				|ANALYZE %2",
				
				СтрСоединить(МассивКолонокДляЗапроса,
						",
						|		"),
				ПараметрыПомещения.ИмяВременнойТаблицы,
				?(ПустаяСтрока(СтрокаИндекс), "", СтрокаИндекс));
		
	Иначе
		
		СтруктураРезультат.НаименованиеТаблицыДляВставкиДанных = ПараметрыПомещения.ИмяВременнойТаблицы;
		
		// Текст запроса создания готовой таблицы
		МассивТекстЗапроса = Новый Массив(); // Массив из Строка
		Если ПараметрыПомещения.НачинатьТранзакцию Тогда
			МассивТекстЗапроса.Добавить("BEGIN");
		КонецЕсли;
		
		МассивКолонокДляДобавления = Новый Массив(); // Массив из Строка
		Для Каждого КлючЗначение Из СоответствиеКолонок Цикл
			МассивКолонокДляДобавления.Добавить(СтрШаблон("%1 %2", КлючЗначение.Ключ, КлючЗначение.Значение.ИмяТипаДанныхВБД));
		КонецЦикла;
		
		МассивТекстЗапроса.Добавить(СтрШаблон(
				"CREATE TEMPORARY TABLE %1
				|(
				|	%2
				|)
				|WITH (OIDS=FALSE)
				|ON COMMIT DROP
				|;
				|
				|
				|%3",
				
				СтруктураРезультат.НаименованиеТаблицыДляВставкиДанных,
				СтрСоединить(МассивКолонокДляДобавления,
						",
						|	"),
				?(ПустаяСтрока(СтрокаИндекс), "", СтрокаИндекс)));
		
		СтруктураРезультат.ТекстЗапросаСозданиеВременнойТаблицы = СтрСоединить(МассивТекстЗапроса, Спец_КонстантыКлиентСервер.РазделительЗапросовВPostgreSQL());
		СтруктураРезультат.ТребуетсяАнализ = Истина;
		
	КонецЕсли;
		
	Возврат СтруктураРезультат;
	
КонецФункции

// Параметры:
//	ИсходныеДанные - см. ПоместитьТаблицу1СВоВременнуюТаблицу.ИсходныеДанные
//	ЗаписьJSON - ЗаписьJSON
//	СоответствиеКолонок - см. ПодготовитьКолонкиТаблицыДляПомещенияВоВременнуюТаблицу
//	СтруктураТаблицыИз1С - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ЗаписатьДанныеДляПередачиВКомпоненту(Знач ИсходныеДанные, Знач ЗаписьJSON, Знач СоответствиеКолонок, Знач СтруктураТаблицыИз1С, Знач Кэш) Экспорт
	
#Если Не ВебКлиент Тогда
	
	МассивСоставныхКолонок = Новый Массив(); // Массив из Строка
	Для Каждого КлючЗначение Из СоответствиеКолонок Цикл
		
		Если ЗначениеЗаполнено(КлючЗначение.Значение.ТипСоставногоПоля) Тогда
			МассивСоставныхКолонок.Добавить(КлючЗначение.Ключ);
		КонецЕсли;
		
	КонецЦикла;
	
	ЗаписьJSON.ЗаписатьНачалоМассива();
	Для Каждого ИсходнаяСтрока Из ИсходныеДанные Цикл
		
		ЗаписьJSON.ЗаписатьНачалоМассива();
		Для Каждого КлючЗначение Из СоответствиеКолонок Цикл
			
			Если МассивСоставныхКолонок.Найти(КлючЗначение.Ключ) = Неопределено Тогда
				ЗаписьJSON.ЗаписатьЗначение(ПолучитьЗначениеДляPostgreSQL(ИсходнаяСтрока[КлючЗначение.Значение.ИмяВ1С], , Кэш));
			Иначе
				ЗаписьJSON.ЗаписатьЗначение(ЗначениеДляPostgreSQL_СоставнаяКолонка(ИсходнаяСтрока[КлючЗначение.Значение.ИмяВ1С], КлючЗначение.Значение, Кэш));
			КонецЕсли;
			
		КонецЦикла;
		
		ЗаписьJSON.ЗаписатьКонецМассива();
		
	КонецЦикла;
	ЗаписьJSON.ЗаписатьКонецМассива();

#Иначе
	
	ВызватьИсключение "Недоступно на веб-клиенте!";

#КонецЕсли

КонецПроцедуры

#КонецОбласти

#Область ПоискСозданиеУдалениеОбъектов

// см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруПараметровДляЗаписиНапрямую
// 
//@skip-check constructor-function-return-section
//
// Параметры:
//	ПолноеИмяМетаданныхВ1С - Строка
// 
// Возвращаемое значение:
//	см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруПараметровДляЗаписиНапрямую
//
Функция ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL(Знач ПолноеИмяМетаданныхВ1С) Экспорт
	
	Возврат Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьСтруктуру(
			Спец_PostgreSQLВызовСервераПовтИсп.ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL(ПолноеИмяМетаданныхВ1С), Ложь);
	
КонецФункции

// см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьСтруктуруПоляДляСвязиДляЗаписи
// 
// Параметры:
//	НаименованиеВ1С - Строка
//	ИмяПоляДляСвязиВ1С - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьСтруктуруПоляДляСвязиДляЗаписи.ИмяПоляДляСвязиВ1С
//	ДополнительныеФункцииДляСвязи - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьСтруктуруПоляДляСвязиДляЗаписи.ДополнительныеФункцииДляСвязи
//	ТекстОшибок - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьСтруктуруПоляДляСвязиДляЗаписи.ТекстОшибок
// 
// Возвращаемое значение:
//	см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьСтруктуруПоляДляСвязиДляЗаписи
//
Функция ПолучитьСтруктуруПоляДляСвязиДляЗаписи(Знач НаименованиеВ1С, Знач ИмяПоляДляСвязиВ1С, Знач ДополнительныеФункцииДляСвязи, ТекстОшибок) Экспорт
	
	СтруктураТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(НаименованиеВ1С);
	Если ПустаяСтрока(СтруктураТаблицы.НаименованиеВPostgreSQL) Тогда
		Возврат Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД();
	КонецЕсли;

	МассивПоПолю = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицы.Поля, ИмяПоляДляСвязиВ1С, Новый Массив()); // ФиксированныйМассив из см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
	Если МассивПоПолю.Количество() = 0 Тогда

		ШаблонСообщения = НСтр("ru = 'Не удалось найти поле ""%1"" в таблице ""%2""'");
		ТекстСообщения = СтрШаблон(ШаблонСообщения, ИмяПоляДляСвязиВ1С, НаименованиеВ1С);
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстСообщения, "Структура поля для связи (PostgreSQL)", ТекстОшибок);

	Иначе
		
		СтруктураСтолбца = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицы.ПоляPostgreSQL, МассивПоПолю.Получить(0));
		Если СтруктураСтолбца <> Неопределено Тогда
			
			СтруктураРезультат = Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьРекурсивно(СтруктураСтолбца, Ложь); // см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
			Если Не ПустаяСтрока(ДополнительныеФункцииДляСвязи) Тогда
				СтруктураРезультат.ДополнительныеФункцииДляСвязи = ДополнительныеФункцииДляСвязи;
			КонецЕсли;
			
			Возврат СтруктураРезультат;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД();
	
КонецФункции

// см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ДобавитьКлючевоеПолеДляЗапроса
// 
// Параметры:
//	СтруктураПараметров - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ДобавитьКлючевоеПолеДляЗапроса.СтруктураПараметров
//	ИмяКлючевогоПоля - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ДобавитьКлючевоеПолеДляЗапроса.ИмяКлючевогоПоля
//	ДобавлятьПолеСвязи - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ДобавитьКлючевоеПолеДляЗапроса.ДобавлятьПолеСвязи
//	ДобавлятьПолеДляПроверкиКонфликтов - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ДобавитьКлючевоеПолеДляЗапроса.ДобавлятьПолеДляПроверкиКонфликтов
//
Процедура ДобавитьКлючевоеПолеДляЗапроса(Знач СтруктураПараметров, Знач ИмяКлючевогоПоля, Знач ДобавлятьПолеСвязи, Знач ДобавлятьПолеДляПроверкиКонфликтов) Экспорт

	СтруктураПараметровТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(СтруктураПараметров.ИмяМетаданныхВ1С);

	МассивПолейPostgreSQL = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураПараметровТаблицы.Поля, ИмяКлючевогоПоля, Новый Массив()); // ФиксированныйМассив из см. Строка
	Для Каждого ИмяПоля Из МассивПолейPostgreSQL Цикл

		СтруктураПоляИзPostrgeSQL = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураПараметровТаблицы.ПоляPostgreSQL, ИмяПоля); // см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
		Если СтруктураПоляИзPostrgeSQL = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Если ДобавлятьПолеСвязи Тогда
			СтруктураПараметров.ПоляДляСвязи.Добавить(СтруктураПоляИзPostrgeSQL);
		КонецЕсли;

		Если ДобавлятьПолеДляПроверкиКонфликтов Тогда
			СтруктураПараметров.ПоляДляПроверкиКонфликтов.Добавить(СтруктураПоляИзPostrgeSQL.ИмяСтолбцаВБД);
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.НайтиСоздатьОбъектыВБазеДанных
// 
// Параметры:
//  ИсходныеДанные - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.НайтиСоздатьОбъектыВБазеДанных.ИсходныеДанные
//  СтруктураПараметров - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.НайтиСоздатьОбъектыВБазеДанных.СтруктураПараметров
//  ТекстОшибок - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.НайтиСоздатьОбъектыВБазеДанных.ТекстОшибок
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос
//
Функция НайтиСоздатьОбъектыВPostgreSQL(Знач ИсходныеДанные, Знач СтруктураПараметров, ТекстОшибок, Знач Кэш) Экспорт
	
	ТипИсходныхДанных = ТипЗнч(ИсходныеДанные);
	
	ЭтоТаблицаЗначений = Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ИсходныеДанные, ТипИсходныхДанных);
	Если Не ЭтоТаблицаЗначений И Не Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИсходныеДанные, ТипИсходныхДанных) Тогда
		
		ТекстОшибки = "Некорректные входные данные! Могу читать только таблицу значений или массив структур / соответствий!";
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(
				ТекстОшибки,
				"Найти / создать объекты в PostgreSQL",
				ТекстОшибок);
		
		Возврат Новый Структура("Успешно, ТекстОшибки, РезультатЗапроса", Ложь, ТекстОшибки, Новый Массив());
		
	КонецЕсли;
	
	// 0. Подготовим поля для связи ссылок, если есть ТЧ
	МассивТабличныхЧастей = ПодготовитьТабличныеЧастиДляЗаписиНапрямую(СтруктураПараметров, ИсходныеДанные, ЭтоТаблицаЗначений, ТекстОшибок, Кэш);
	Если МассивТабличныхЧастей.Количество() Тогда
		ПроставитьУникальныеИдентификаторыДляСвязиСТабличнымиЧастями(ИсходныеДанные, ЭтоТаблицаЗначений, Кэш);
	КонецЕсли;
	
	// 1. Помещаем исходные данные во временную таблицу
	ПараметрыПомещения = Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруПараметровПомещениеДанныхВоВременнуюТаблицу();
	ПараметрыПомещения.ИмяМетаданныхИз1С = СтруктураПараметров.ИмяМетаданныхВ1С;
	ПараметрыПомещения.ИмяВременнойТаблицы = ПараметрыПомещения.ИмяМетаданныхИз1С;
	
	Для Каждого СтруктураПоля Из СтруктураПараметров.ПоляДляСвязи Цикл
		ПараметрыПомещения.МассивПолейДляИндекса.Добавить(СтруктураПоля.ИмяВ1С);
	КонецЦикла;
	
	ПараметрыПомещения.МассивПолейДляИндекса = Спец_РаботаСКоллекциямиКлиентСервер.СвернутьМассив(ПараметрыПомещения.МассивПолейДляИндекса);
	
	СтруктураРезультатПомещения = ПоместитьТаблицу1СВоВременнуюТаблицу(ИсходныеДанные, ПараметрыПомещения, ТекстОшибок, Кэш);
	Если СтруктураРезультатПомещения = Неопределено Тогда
		Возврат Новый Структура("Успешно, ТекстОшибки, РезультатЗапроса", Ложь, "", Новый Массив());
	КонецЕсли;
	
	// 2. Формируем текст запроса
	СтруктураДополнительныеПараметры = НоваяСтруктураДополнительныхПараметров(ЭтоТаблицаЗначений, "", МассивТабличныхЧастей);
	ТекстЗапроса = СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую(СтруктураПараметров,
			СтруктураРезультатПомещения,
			СтруктураДополнительныеПараметры,
			ТекстОшибок,
			Кэш);
	
	Если ПустаяСтрока(ТекстЗапроса) Тогда
		
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
		
		ТекстОшибки = "Не удалось сформировать текст запроса!";
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибки,
														 "Найти / создать объекты напрямую (PostgreSQL)",
														 ТекстОшибок);
		
		Возврат Новый Структура("Успешно, ТекстОшибки, РезультатЗапроса", Ложь, ТекстОшибки, Новый Массив());
		
	КонецЕсли;
	
	// 3. Выполняем запрос
	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Если Не СтруктураРезультат.Успешно Тогда
		
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось выполнить запрос!" + Символы.ПС + СтруктураРезультат.ТекстОшибки,
														 "Найти / создать объекты напрямую (PostgreSQL)",
														 ТекстОшибок);
		
		Возврат СтруктураРезультат;
		
	ИначеЕсли Не Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLЗафиксироватьТранзакцию(Кэш) Тогда
		
		// Чтобы не висело в блоке до завершения транзакции. Ничего страшного не будет, если запишется только ссылка без ТЧ.
		
		СтруктураРезультат.Успешно = Ложь;
		СтруктураРезультат.ТекстОшибки = "Не удалось зафиксировать транзакцию!";
		
		Возврат СтруктураРезультат;

	КонецЕсли;
	
	// 4. Проходим табличные части
	Если СтруктураПараметров.ТипОбновления <> ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиНеОбновлятьНеСоздавать") Тогда
		ПройтиТабличныеЧастиПослеЗаписиНапрямую(СтруктураРезультат, ИсходныеДанные, СтруктураПараметров, СтруктураДополнительныеПараметры, МассивТабличныхЧастей, ТекстОшибок, Кэш);
	КонецЕсли;
	
	Возврат СтруктураРезультат;

КонецФункции

//@skip-check structure-consructor-too-many-keys
//@skip-check constructor-function-return-section
//
// Параметры:
//  ЭтоТаблицаЗначений - Булево
//  ИмяТабличнойЧасти - Строка
//  МассивТабличныхЧастей - Массив из Строка
// 
// Возвращаемое значение:
//  Структура:
// * ТекстДляСвязи - Строка
// * ИмяТабличнойЧасти - Строка
// * ЕстьТабличныеЧасти - Булево
// * ЭтоСсылочныйОбъект - Булево
// * ПолеСсылка - Строка
// * КэшСсылок - Соответствие из КлючИЗначение:
// 	** Ключ - Строка
// 	** Значение - ЛюбаяСсылка
//
Функция НоваяСтруктураДополнительныхПараметров(Знач ЭтоТаблицаЗначений, Знач ИмяТабличнойЧасти, Знач МассивТабличныхЧастей) Экспорт
	
	Возврат Новый Структура(
			
			"ТекстДляСвязи,
			|ИмяТабличнойЧасти,
			|ЕстьТабличныеЧасти,
			|ЭтоТаблицаЗначений,
			|ЭтоСсылочныйОбъект,
			|ПолеСсылка,
			|КэшСсылок",
			
			"",
			ИмяТабличнойЧасти,
			МассивТабличныхЧастей.Количество() > 0,
			ЭтоТаблицаЗначений,
			Ложь,
			"",
			Новый Соответствие());
	
КонецФункции

// Возвращаемое значение:
//  Строка
//
Функция ИмяПоляДляСвязиСТабличнымиЧастями() Экспорт
	
	Возврат "spec_postgresql_key";
	
КонецФункции

// Параметры:
//	СтруктураПараметров - см. НайтиСоздатьОбъектыВPostgreSQL.СтруктураПараметров
//	ИсходныеДанные - см. НайтиСоздатьОбъектыВPostgreSQL.ИсходныеДанные
//	ЭтоТаблицаЗначений - Булево
//	ТекстОшибок - см. НайтиСоздатьОбъектыВPostgreSQL.ТекстОшибок
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Массив из Строка
//
Функция ПодготовитьТабличныеЧастиДляЗаписиНапрямую(Знач СтруктураПараметров, Знач ИсходныеДанные, Знач ЭтоТаблицаЗначений, ТекстОшибок, Знач Кэш) Экспорт
	
	МассивТабличныхЧастей = Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьМассив(СтруктураПараметров.МассивИменТабличныхЧастей, Ложь); // Массив из Строка
	Если МассивТабличныхЧастей.Количество() = 0 Тогда
		Возврат МассивТабличныхЧастей;
	КонецЕсли;
	
	Если ЭтоТаблицаЗначений Тогда
		
		МассивДляУдаления = Новый Массив(); // Массив из Строка
		Для Каждого ИмяТабличнойЧасти Из МассивТабличныхЧастей Цикл

			Если ИсходныеДанные.Колонки.Найти(ИмяТабличнойЧасти) = Неопределено Тогда
				МассивДляУдаления.Добавить(ИмяТабличнойЧасти);
			КонецЕсли;

		КонецЦикла;
		
		Для Каждого ИмяТабличнойЧастиДляУдаления Из МассивДляУдаления Цикл
			Спец_РаботаСКоллекциямиКлиентСервер.УдалитьЗначениеИзМассива(МассивТабличныхЧастей, ИмяТабличнойЧастиДляУдаления);
		КонецЦикла;
		
	Иначе

		МассивДляУдаления = Новый Массив(); // Массив из Строка

		НулеваяСтрока = ИсходныеДанные.Получить(0);
		Для Каждого ИмяТабличнойЧасти Из МассивТабличныхЧастей Цикл

			Если Не НулеваяСтрока.Свойство(ИмяТабличнойЧасти) Тогда
				МассивДляУдаления.Добавить(ИмяТабличнойЧасти);
			КонецЕсли;

		КонецЦикла;
		
		Для Каждого ИмяТабличнойЧастиДляУдаления Из МассивДляУдаления Цикл
			Спец_РаботаСКоллекциямиКлиентСервер.УдалитьЗначениеИзМассива(МассивТабличныхЧастей, ИмяТабличнойЧастиДляУдаления);
		КонецЦикла;
		
	КонецЕсли;

	Возврат МассивТабличныхЧастей;

КонецФункции

// Параметры:
//	СтруктураПараметров - см. НайтиСоздатьОбъектыВPostgreSQL.СтруктураПараметров
//	ПараметрыВременнойТаблицы - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//	СтруктураДополнительныеПараметры - см. НоваяСтруктураДополнительныхПараметров
//	ТекстОшибок - см. НайтиСоздатьОбъектыВPostgreSQL.ТекстОшибок
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
//
Функция СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую(Знач СтруктураПараметров, Знач ПараметрыВременнойТаблицы, Знач СтруктураДополнительныеПараметры, ТекстОшибок, Знач Кэш) Экспорт
	
	СтруктураПараметровТаблицыВБД = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(СтруктураПараметров.ИмяМетаданныхВ1С);
	
	// Связь таблиц
	СтруктураДополнительныеПараметры.ТекстДляСвязи = СформироватьТекстЗапросаСвязиТаблиц(СтруктураПараметров.ИмяМетаданныхВ1С, СтруктураПараметров.ПоляДляСвязи, Не ПустаяСтрока(СтруктураДополнительныеПараметры.ИмяТабличнойЧасти));
	СтруктураДополнительныеПараметры.ЭтоСсылочныйОбъект = Спец_ОбщегоНазначенияКлиентСервер.ЭтоСсылка(СтруктураПараметровТаблицыВБД.НаименованиеВ1С, Кэш, Тип("Строка"));
	
	Если СтруктураДополнительныеПараметры.ЭтоСсылочныйОбъект Тогда
		
		СтруктураДополнительныеПараметры.ПолеСсылка = ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(СтруктураПараметровТаблицыВБД.НаименованиеВ1С,
				"Ссылка",
				,
				СтруктураПараметровТаблицыВБД);
		
	КонецЕсли;
	
	// К сожалению, _keyfield не равен _lineno - 1,
	// поэтому приходится сначала очищать табличную часть, потом писать, что соответствует НайтиОбновлятьСоздавать
	Если Не ПустаяСтрока(СтруктураДополнительныеПараметры.ИмяТабличнойЧасти)
		Или СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьСоздавать") Тогда
		
		Возврат СформироватьТекстЗапроса_НайтиОбновлятьСоздавать(СтруктураПараметров, СтруктураПараметровТаблицыВБД, ПараметрыВременнойТаблицы, СтруктураДополнительныеПараметры, Кэш);
		
	ИначеЕсли СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиНеОбновлятьНеСоздавать") Тогда
		
		Возврат СформироватьТекстЗапроса_НайтиНеОбновлятьНеСоздавать(СтруктураПараметров, СтруктураПараметровТаблицыВБД, ПараметрыВременнойТаблицы, СтруктураДополнительныеПараметры, Кэш);
		
	ИначеЕсли СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьНеСоздавать") Тогда
		
		Возврат СформироватьТекстЗапроса_НайтиОбновлятьНеСоздавать(СтруктураПараметров, СтруктураПараметровТаблицыВБД, ПараметрыВременнойТаблицы, СтруктураДополнительныеПараметры, Кэш);
		
	ИначеЕсли СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиНеОбновлятьСоздавать") Тогда
		
		Возврат СформироватьТекстЗапроса_НайтиНеОбновлятьСоздавать(СтруктураПараметров, СтруктураПараметровТаблицыВБД, ПараметрыВременнойТаблицы, СтруктураДополнительныеПараметры, Кэш);
		
	Иначе
		
		ВызватьИсключение "Что-то пошло не так! Неизвестный тип обновления таблицы."
		
	КонецЕсли;
	
КонецФункции

//@skip-check variable-value-type
//@skip-check property-return-type
//@skip-check invocation-parameter-type-intersect
//
// Параметры:
//  СтруктураОбщийРезультат - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос
//  ИсходныеДанные - см. НайтиСоздатьОбъектыВPostgreSQL.ИсходныеДанные
//  СтруктураПараметров - см. НайтиСоздатьОбъектыВPostgreSQL.СтруктураПараметров
//  СтруктураДополнительныеПараметры - см. НоваяСтруктураДополнительныхПараметров
//  ИмяТабличнойЧасти - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Массив из Произвольный
//
Функция СформироватьМассивДанныхДляОтправкиПоТабличнойЧасти(Знач СтруктураОбщийРезультат, Знач ИсходныеДанные, Знач СтруктураПараметров, Знач СтруктураДополнительныеПараметры,
		Знач ИмяТабличнойЧасти, Знач Кэш) Экспорт
	
	МассивДляПередачи     = Новый Массив(); // Массив из Структура
	НулеваяКолонка        = Неопределено; // Структура
	МассивСсылокНеНайдено = Новый Массив(); // Массив из ЛюбаяСсылка
	
	Для Каждого СтруктураСтроки Из СтруктураОбщийРезультат.РезультатЗапроса Цикл
		
		Если СтруктураДополнительныеПараметры.КэшСсылок[СтруктураСтроки.uid] = Неопределено Тогда
			СтруктураДополнительныеПараметры.КэшСсылок[СтруктураСтроки.uid] = Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLЗначениеПоНормальному(СтруктураПараметров.ТипВ1С, СтруктураСтроки.uid);
		КонецЕсли;
		
		СтруктураОтбора = Новый Структура(ИмяПоляДляСвязиСТабличнымиЧастями(), СтруктураСтроки[ИмяПоляДляСвязиСТабличнымиЧастями()]);
		
		МассивСтрокПоСвязи = Спец_РаботаСКоллекциямиКлиентСервер.НайтиСтрокиВКоллекцииСтрок(СтруктураОтбора, ИсходныеДанные);
		Для Каждого ИсходнаяСтрока Из МассивСтрокПоСвязи Цикл
		
			МассивДанныхПоСтроке = ИсходнаяСтрока[ИмяТабличнойЧасти]; // Массив из Структура
			Если МассивДанныхПоСтроке.Количество() = 0 Тогда
				
				МассивСсылокНеНайдено.Добавить(СтруктураДополнительныеПараметры.КэшСсылок[СтруктураСтроки.uid]);
				Продолжить;
				
			КонецЕсли;
			
			#Если Не ТонкийКлиент И Не ВебКлиент И Не ТолстыйКлиентУправляемоеПриложение Тогда
				
				Если Не Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(МассивДанныхПоСтроке) Тогда
					МассивДанныхПоСтроке = Спец_ОбщегоНазначения.ПреобразоватьТаблицуЗначенийВМассивСтрок(МассивДанныхПоСтроке);
				КонецЕсли;
				
			#КонецЕсли
			
			ТекущийНомерСтроки = 1;
			Для Каждого СтрокаТабличнойЧасти Из МассивДанныхПоСтроке Цикл
				
				СтрокаДляВставки = Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьСтруктуру(СтрокаТабличнойЧасти, Ложь);
				
				СтрокаДляВставки.Вставить("Ссылка"            , СтруктураДополнительныеПараметры.КэшСсылок[СтруктураСтроки.uid]);
				СтрокаДляВставки.Вставить("spec_only_removed" , Ложь);
				
				Если Не СтруктураСтроки.Свойство("НомерСтроки") Тогда
					СтрокаДляВставки.Вставить("НомерСтроки", ТекущийНомерСтроки);
				КонецЕсли;
				
				ТекущийНомерСтроки = ТекущийНомерСтроки + 1;
				МассивДляПередачи.Добавить(СтрокаДляВставки);
				
			КонецЦикла;
			
			Если НулеваяКолонка = Неопределено Тогда
				НулеваяКолонка = СтрокаТабличнойЧасти;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	МассивИменКлючей = Новый Массив(); // Массив из Строка
	
	МассивИменКлючей.Добавить("Ссылка");
	МассивИменКлючей.Добавить("spec_only_removed");
	МассивИменКлючей.Добавить("НомерСтроки");
	
	Если НулеваяКолонка <> Неопределено Тогда
		
		Для Каждого КлючЗначение Из НулеваяКолонка Цикл
			МассивИменКлючей.Добавить(КлючЗначение.Ключ);
		КонецЦикла;
		
	КонецЕсли;
	
	МассивИменКлючей = Спец_РаботаСКоллекциямиКлиентСервер.СвернутьМассив(МассивИменКлючей);
	
	ИменаКлючей = СтрСоединить(МассивИменКлючей, ",");
	Для Каждого СсылкаНеНайдено Из МассивСсылокНеНайдено Цикл
		
		СтруктураСтроки = Новый Структура(ИменаКлючей);
		
		СтруктураСтроки.Ссылка            = СсылкаНеНайдено;
		СтруктураСтроки.spec_only_removed = Истина;
		
		МассивДляПередачи.Добавить(СтруктураСтроки);
		
	КонецЦикла;
	
	Возврат МассивДляПередачи;
	
КонецФункции

// см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.УдалитьДанныеПоОбъекту1СВБазеДанных
//
// Параметры:
//  ИсходныеДанные - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.УдалитьДанныеПоОбъекту1СВБазеДанных.ИсходныеДанные
//  ИмяМетаданныхИз1С - Строка
//  ТекстОшибок - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.УдалитьДанныеПоОбъекту1СВБазеДанных.ТекстОшибок
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.УдалитьДанныеПоОбъекту1СВБазеДанных
//
Функция УдалитьДанныеПоОбъекту1СВБазеДанных(Знач ИсходныеДанные, Знач ИмяМетаданныхИз1С, ТекстОшибок, Знач Кэш) Экспорт
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(ИсходныеДанные);

	СтруктураОсновнойТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданныхИз1С);
	Если ПустаяСтрока(СтруктураОсновнойТаблицы.НаименованиеВPostgreSQL) Тогда
		
		ТекстОшибки = "Не удалось найти параметры таблицы в БД по таблице " + ИмяМетаданныхИз1С;
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибки,
														 "Удалить данные по объекту (PostgreSQL)",
														 ТекстОшибок);
		
		Возврат Ложь;

	КонецЕсли;

	МассивТаблицДляОчистки = Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(СтруктураОсновнойТаблицы); // Массив из см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		МассивТЧ = Спец_ОбщегоНазначенияВызовСервера.ПолучитьМассивИменТабличныхЧастей(ИмяМетаданныхИз1С);
	#Иначе
		МассивТЧ = Спец_ОбщегоНазначения.ПолучитьМассивИменТабличныхЧастей(ИмяМетаданныхИз1С, Кэш);
	#КонецЕсли
	
	Для Каждого ИмяТабличнойЧасти Из МассивТЧ Цикл
		
		СтруктураТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданныхИз1С + "." + ИмяТабличнойЧасти);
		Если Не ПустаяСтрока(СтруктураТаблицы.НаименованиеВPostgreSQL) Тогда
			МассивТаблицДляОчистки.Добавить(СтруктураТаблицы);
		КонецЕсли;

	КонецЦикла;

	Если ИсходныеДанные.Количество() = 0 Тогда

		МассивИменаТаблиц = Новый Массив(); // Массив из Строка
		Для Каждого СтруктураТаблицы Из МассивТаблицДляОчистки Цикл
			МассивИменаТаблиц.Добавить(СтруктураТаблицы.НаименованиеВPostgreSQL);
		КонецЦикла;
		
		Возврат Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата("TRUNCATE " + СтрСоединить(МассивИменаТаблиц, ","), ТекстОшибок, Кэш);
		
	КонецЕсли;
	
	ПараметрыПомещения = Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруПараметровПомещениеДанныхВоВременнуюТаблицу();
	ПараметрыПомещения.ИмяМетаданныхИз1С = ИмяМетаданныхИз1С;
	ПараметрыПомещения.ИмяВременнойТаблицы = ПараметрыПомещения.ИмяМетаданныхИз1С;
	
	СтруктураРезультатПомещения = ПоместитьТаблицу1СВоВременнуюТаблицу(ИсходныеДанные, ПараметрыПомещения, ТекстОшибок, Кэш);
	Если СтруктураРезультатПомещения = Неопределено Или ПустаяСтрока(СтруктураРезультатПомещения.ИмяТаблицы) Тогда
		
		Спец_ЗаписатьЛог("Удаление объектов через PostgreSQL",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Ошибка"),
				ТекстОшибок,
				Кэш);
		
		Возврат Ложь;
		
	КонецЕсли;

	ГотовыйТекстЗапроса = СформироватьТекстЗапросаДляУдаленияДанных(МассивТаблицДляОчистки, СтруктураРезультатПомещения);
	Если Не Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ГотовыйТекстЗапроса, ТекстОшибок, Кэш) Тогда
		
		Спец_ЗаписатьЛог("Удаление объектов через PostgreSQL",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Ошибка"),
				ТекстОшибок,
				Кэш);
		
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
		Возврат Ложь;
		
	Иначе
		
		Возврат Истина;
	
	КонецЕсли;

КонецФункции

// Параметры:
//  МассивТаблицДляОчистки - Массив из см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//  СтруктураРезультатПомещения - см. ПоместитьТаблицу1СВоВременнуюТаблицу
// 
// Возвращаемое значение:
//  Строка
//
Функция СформироватьТекстЗапросаДляУдаленияДанных(Знач МассивТаблицДляОчистки, Знач СтруктураРезультатПомещения) Экспорт
	
	Если МассивТаблицДляОчистки.Количество() > 1 Тогда

		МассивТекстЗапроса = Новый Массив(); // Массив из Строка

		ШаблонТекстаЗапроса =
		
		"DELETE FROM ONLY %1
		|WHERE %2 IN (SELECT _idrref FROM %3)";

		Для Каждого СтруктураТаблицы Из МассивТаблицДляОчистки Цикл
			
			ТекстЗапроса = СтрШаблон(ШаблонТекстаЗапроса,
									 СтруктураТаблицы.НаименованиеВPostgreSQL,
									 Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(СтруктураТаблицы.НаименованиеВ1С, "Ссылка"),
									 СтруктураРезультатПомещения.ИмяТаблицы);

			МассивТекстЗапроса.Добавить(ТекстЗапроса);

		КонецЦикла;

		МассивТекстЗапроса.Добавить("COMMIT");

		Возврат СтрСоединить(МассивТекстЗапроса, Спец_КонстантыКлиентСервер.РазделительЗапросовВPostgreSQL());

	Иначе

		ШаблонТекстаЗапроса =
		
		"DELETE FROM ONLY %1
		|WHERE (%2) IN (SELECT %2 FROM %3);
		|
		|COMMIT;";

		МассивПолейИзPostgreSQL = Спец_РаботаСКоллекциямиКлиентСервер.ВыгрузитьМассивЗначений(СтруктураРезультатПомещения.СоответствиеПолей, "Ключ"); // Массив из Строка
		Возврат СтрШаблон(ШаблонТекстаЗапроса,
						  МассивТаблицДляОчистки.Получить(0).НаименованиеВPostgreSQL,
						  СтрСоединить(МассивПолейИзPostgreSQL, ","),
						  СтруктураРезультатПомещения.ИмяТаблицы);

	КонецЕсли;
	
КонецФункции

#КонецОбласти

// Параметры:
//	ИмяМетаданныхТаблицыВ1С - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьИмяПоляВPostgreSQLПоИмениВ1С.ИмяМетаданныхТаблицыВ1С
//	ИмяПоля - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьИмяПоляВPostgreSQLПоИмениВ1С.ИмяПоля
//	ТипСоставногоПоля - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьИмяПоляВPostgreSQLПоИмениВ1С.ТипСоставногоПоля
//	СтруктураТаблицы - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
// 
// Возвращаемое значение:
//  см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьИмяПоляВPostgreSQLПоИмениВ1С
//
Функция ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(Знач ИмяМетаданныхТаблицыВ1С, Знач ИмяПоля, Знач ТипСоставногоПоля = Неопределено, Знач СтруктураТаблицы = Неопределено) Экспорт
	
	Если СтруктураТаблицы = Неопределено Тогда
		СтруктураТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданныхТаблицыВ1С);
	КонецЕсли;
	
	Если ПустаяСтрока(СтруктураТаблицы.НаименованиеВPostgreSQL) Тогда
		Возврат "";
	КонецЕсли;
	
	МассивПолейРезультат = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицы.Поля, ИмяПоля); // ФиксированныйМассив из Строка
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивПолейРезультат);
	
	Если ТипСоставногоПоля = Неопределено Или МассивПолейРезультат.Количество() <= 1 Тогда
		Возврат СтрСоединить(МассивПолейРезультат, ",");
	КонецЕсли;
	
	Для Каждого ИмяСтолбца Из МассивПолейРезультат Цикл
		
		СтруктураПоля = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицы.ПоляPostgreSQL, ИмяСтолбца); // см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
		Если СтруктураПоля <> Неопределено И СтруктураПоля.ТипСоставногоПоля = ТипСоставногоПоля Тогда
			Возврат ИмяСтолбца;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат "";

КонецФункции

// Получить значение в формате для PostgreSQL (для чтение через COPY FROM)
// 
// Параметры:
//  ИсходноеЗначение - Произвольный - Значение для преобразования в PostgreSQL
//  ТипРеквизита - Неопределено, Тип - Тип реквизита
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка - Значение в формате PostgreSQL
//
Функция ПолучитьЗначениеДляPostgreSQL(Знач ИсходноеЗначение, Знач ТипРеквизита = Неопределено, Кэш = Неопределено) Экспорт

	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ИсходноеЗначение); КонецЕсли;
	Если ТипРеквизита = Тип("Строка") Тогда

		Возврат ИсходноеЗначение;

	ИначеЕсли Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ОписаниеТипаПеречисления().СодержитТип(ТипРеквизита) И ТипРеквизита <> Тип("Неопределено") Тогда
		
		СоответствиеПредопределенныхОбъектов = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСоответствиеПредопределенныхДанныхИГУИДов();
		Возврат Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СоответствиеПредопределенныхОбъектов, ИсходноеЗначение, "00000000-0000-0000-0000-000000000000");

	Иначе

		Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(ИсходноеЗначение);

	КонецЕсли;

КонецФункции

// Получить значение в формате для PostgreSQL (для записи в текст запроса)
// 
// Параметры:
//  ИсходноеЗначение - Произвольный - Значение для преобразования в PostgreSQL
//  ТипРеквизита - Неопределено, Тип - Тип реквизита
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка - Значение в формате PostgreSQL
//
Функция ПолучитьЗначениеДляPostgreSQLВТекстЗапроса(Знач ИсходноеЗначение, Знач ТипРеквизита = Неопределено, Кэш = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(ИсходноеЗначение); КонецЕсли;
	
	ЗначениеРеквизита = ПолучитьЗначениеДляPostgreSQL(ИсходноеЗначение, ТипРеквизита, Кэш);
	Если ТипРеквизита = Тип("Строка") Тогда
		Возврат СтрШаблон("'%1'", СтрЗаменить(ЗначениеРеквизита, "'", "''"));
	ИначеЕсли ТипРеквизита = Тип("Число") Или ТипРеквизита = Тип("Булево") Тогда
		Возврат ЗначениеРеквизита;
	ИначеЕсли ТипРеквизита = Тип("Дата") Тогда
		Возврат СтрШаблон("'%1'::timestamp", ЗначениеРеквизита);
	ИначеЕсли Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ОписаниеТипаВсеСсылки().СодержитТип(ТипРеквизита) Тогда
		Возврат СтрШаблон("lykov_uidtorref('%1')", ЗначениеРеквизита);
	Иначе
		Возврат ЗначениеРеквизита;
	КонецЕсли;
	
КонецФункции

// Получить значение для записи во временную таблицу в PostgreSQL по умолчанию (до преобразования)
// 
// Параметры:
//  СтруктураПоля - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
// 
// Возвращаемое значение:
//  Строка - Значение для записи во временную таблицу по умолчанию
//
Функция ПолучитьЗначениеДляЗаписиВоВременнуюТаблицуПоУмолчанию(Знач СтруктураПоля) Экспорт
	
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(СтруктураПоля, "ФункцияПреобразования") И Не ПустаяСтрока(СтруктураПоля.ФункцияПреобразования) Тогда
		
		Если СтрНачинаетсяС(СтруктураПоля.ИмяТипаДанныхВБД, "integer")
			Или СтрНачинаетсяС(СтруктураПоля.ИмяТипаДанныхВБД, "numeric") Тогда
			
			Возврат СтрШаблон(СтруктураПоля.ФункцияПреобразования, "0");
			
		ИначеЕсли СтрНачинаетсяС(СтруктураПоля.ИмяТипаДанныхВБД, "text")
			Или СтрНачинаетсяС(СтруктураПоля.ИмяТипаДанныхВБД, "mvarchar")
			Или СтрНачинаетсяС(СтруктураПоля.ИмяТипаДанныхВБД, "mchar") Тогда
			
			Возврат СтрШаблон(СтруктураПоля.ФункцияПреобразования, "''");
			
		Иначе
			
			Возврат СтрШаблон(СтруктураПоля.ФункцияПреобразования, "null");
			
		КонецЕсли;
		
	ИначеЕсли Не ЗначениеЗаполнено(СтруктураПоля.ТипСоставногоПоля) Тогда
		
		Если СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево") Тогда
			Возврат "false";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата") Тогда
			Возврат "'0001-01-01 00:00:00'::timestamp";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Строка") Тогда
			
			Возврат ?(Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(СтруктураПоля, "ИмяТипаДанныхВБД"),
					"''::" + СтруктураПоля.ИмяТипаДанныхВБД,
					"''::" + СтруктураПоля.ИмяТипаДанныхДляPostgreSQL);
			
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число") Тогда
			Возврат "0";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Ссылочный") Тогда
			Возврат "lykov_UIDToRRef('')";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.NULL") Тогда
			Возврат "NULL";
		Иначе
			Возврат "decode('', 'base64')";
		КонецЕсли;

	Иначе

		Если СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ИдентификаторСсылки") Тогда
			Возврат "lykov_UIDToRRef('')";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Строка") Тогда
			
			Возврат ?(Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(СтруктураПоля, "ИмяТипаДанныхВБД"),
					"''::" + СтруктураПоля.ИмяТипаДанныхВБД,
					"''::" + СтруктураПоля.ИмяТипаДанныхДляPostgreSQL);
			
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево") Тогда
			Возврат "false";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата") Тогда
			Возврат "'0001-01-01 00:00:00'::timestamp";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число") Тогда
			Возврат "0";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ДвоичныеДанные") Тогда
			Возврат "decode('', 'base64')";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.НомерТаблицы") Тогда
			Возврат "lykov_RTRefToBytea(0)";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ТипТаблицы") Тогда
			Возврат "lykov_TypeToBytea(1)";
		Иначе
			Возврат "NULL";
		КонецЕсли;

	КонецЕсли;

КонецФункции

// Получить функцию преобразования значения из PostgreSQL.
// 
// Параметры:
//  СтруктураПоля - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
// 
// Возвращаемое значение:
//  Строка - Функция преобразования
//
Функция ПолучитьФункциюПреобразованияЗначенияИзPostrgeSQL(Знач СтруктураПоля) Экспорт

	Если Не ЗначениеЗаполнено(СтруктураПоля.ТипСоставногоПоля) Тогда

		Если СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Ссылочный") Тогда
			Возврат "lykov_RRefToUID(%1)";
		Иначе
			Возврат "";
		КонецЕсли;

	Иначе

		Если СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ИдентификаторСсылки") Тогда
			Возврат "lykov_RRefToUID(%1)";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.НомерТаблицы") Тогда
			Возврат "lykov_RTRefToInteger(%1)";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ТипТаблицы") Тогда
			Возврат "lykov_ByteaToType(%1)";
		Иначе
			Возврат "";
		КонецЕсли;

	КонецЕсли;

КонецФункции

// Получить тип колонки для временной таблицы в PostgreSQL по умолчанию.
// 
// Параметры:
//  СтруктураПоля - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
// 
// Возвращаемое значение:
//  Строка - Тип колонки для временной таблицы по умолчанию
//
Функция ПолучитьТипКолонкиДляВременнойТаблицыПоУмолчанию(Знач СтруктураПоля) Экспорт

	Если Не ЗначениеЗаполнено(СтруктураПоля.ТипСоставногоПоля) Тогда

		Если СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево") Тогда
			Возврат "boolean";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата") Тогда
			Возврат "timestamp";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Строка") Тогда
			Возврат "mvarchar";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число") Тогда
			Возврат "numeric";
		Иначе
			Возврат "bytea";
		КонецЕсли;

	Иначе

		Если СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Строка") Тогда
			Возврат "mvarchar";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево") Тогда
			Возврат "boolean";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата") Тогда
			Возврат "timestamp";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число") Тогда
			Возврат "numeric";
		Иначе
			Возврат "bytea";
		КонецЕсли;

	КонецЕсли;

КонецФункции

// Преобразовать значение из PostgreSQL в значение 1С.
// 
// Параметры:
//  СтрокаСДанными - Структура - Структура строки из PostgreSQL
//  ПолноеИмяОбъекта - Строка - Полное имя объекта в 1С
//  ИмяСтолбцаВ1С - Строка - Имя столбца в 1С
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Неопределено, Булево, Число, Дата, Строка, ЛюбаяСсылка - Значение в 1С
//
Функция ПреобразоватьЗначениеИзPostgreSQL(Знач СтрокаСДанными, Знач ПолноеИмяОбъекта, Знач ИмяСтолбцаВ1С, Кэш = Неопределено) Экспорт

	СтруктураТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ПолноеИмяОбъекта);

	ПоляСтолбца = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицы.Поля, ИмяСтолбцаВ1С, Новый Массив); // ФиксированныйМассив из см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
	Если ПоляСтолбца.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если ПоляСтолбца.Количество() <> 1 Тогда
		
		// Сначала смотрим тип столбца
		ТипСтолбца = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
															  ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ТипТаблицы"),
															  ПоляСтолбца,
															  Кэш);
		Если ТипСтолбца = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;

		Если ТипСтолбца = "2" Тогда // Булево

			ЗначениеБулево = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	  ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево"),
																	  ПоляСтолбца,
																	  Кэш);
			Возврат ЗначениеБулево = "t";

		ИначеЕсли ТипСтолбца = "3" Тогда // Число

			ЗначениеЧисло = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	 ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число"),
																	 ПоляСтолбца,
																	 Кэш);
			Возврат ?(ЗначениеЧисло = Неопределено, 0, Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЗначениеЧисло));

		ИначеЕсли ТипСтолбца = "4" Тогда // Дата

			ЗначениеДата = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата"),
																	ПоляСтолбца,
																	Кэш);
			Возврат Спец_СтроковыеФункцииКлиентСервер.СтрокаВДату(ЗначениеДата, Кэш);

		ИначеЕсли ТипСтолбца = "5" Тогда // Строка

			ЗначениеСтрока = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	  ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Строка"),
																	  ПоляСтолбца,
																	  Кэш);
			Возврат ?(ЗначениеСтрока = Неопределено, "", ЗначениеСтрока);

		ИначеЕсли ТипСтолбца = "8" Тогда // Ссылочный

			НомерТаблицы = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.НомерТаблицы"),
																	ПоляСтолбца,
																	Кэш);
			Если НомерТаблицы = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;

			Ссылка = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
															  ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ИдентификаторСсылки"),
															  ПоляСтолбца,
															  Кэш);
			Если Ссылка = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;

			НомерТаблицыЧисло = Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(НомерТаблицы);
			НаименованиеТаблицыВ1С = Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьНаименованиеТаблицыВ1СПоКоду(НомерТаблицыЧисло);

			Если ПустаяСтрока(НаименованиеТаблицыВ1С) Тогда
				Возврат Неопределено;
			КонецЕсли;

			#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
				НужныйТип = Спец_ОбщегоНазначенияКлиентПовтИсп.ПолучитьСтруктуруИмениТипаДанныхОбъекта(НаименованиеТаблицыВ1С).Тип;
			#Иначе
				НужныйТип = Спец_ОбщегоНазначения.ПолучитьСтруктуруИмениТипаДанныхОбъекта(НаименованиеТаблицыВ1С, Кэш).Тип;
			#КонецЕсли
			
			Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLЗначениеПоНормальному(НужныйТип, Ссылка);

		Иначе

			Возврат Неопределено;

		КонецЕсли;

	Иначе

		НулевойСтолбец = ПоляСтолбца.Получить(0);
		Если Не Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(СтрокаСДанными, НулевойСтолбец.ИмяСтолбцаВБД, Кэш) Тогда
			Возврат Неопределено;
		КонецЕсли;

		ЗначениеСтолбца = СтрокаСДанными[НулевойСтолбец.ИмяСтолбцаВБД]; // Строка
		Если НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево") Тогда

			Возврат ЗначениеСтолбца = "t";

		ИначеЕсли НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата") Тогда

			Возврат Спец_СтроковыеФункцииКлиентСервер.СтрокаВДату(ЗначениеСтолбца, Кэш);

		ИначеЕсли НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Строка") Тогда

			Возврат ЗначениеСтолбца;

		ИначеЕсли НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число") Тогда

			Возврат Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЗначениеСтолбца);

		ИначеЕсли НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Ссылочный") Тогда

			#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
				ТипРеквизита = Спец_ОбщегоНазначенияВызовСервера.ПолучитьТипРеквизитаВ1С(ПолноеИмяОбъекта, ИмяСтолбцаВ1С);
			#Иначе
				ТипРеквизита = Спец_ОбщегоНазначения.ПолучитьТипРеквизитаВ1С(ПолноеИмяОбъекта, ИмяСтолбцаВ1С, Кэш);
			#КонецЕсли

			Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLЗначениеПоНормальному(ТипРеквизита, ЗначениеСтолбца);

		Иначе

			Возврат ЗначениеСтолбца;

		КонецЕсли;

	КонецЕсли;

КонецФункции

// Преобразовать значение из PostgreSQL в значение 1С по типу данных.
// 
// Параметры:
//  ЗначениеИзPostgreSQL - Строка, Число, Булево - Текстовое значение из PostgreSQL
//  ТипРезультат - Тип - Тип значения результат
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Неопределено, Булево, Число, Дата, Строка, ЛюбаяСсылка - Значение в 1С
//
Функция ПреобразоватьЗначениеИзPostgreSQLПоТипуДанных(Знач ЗначениеИзPostgreSQL, Знач ТипРезультат, Кэш = Неопределено) Экспорт
	
	Если ТипРезультат = Тип("Строка")
		Или ТипРезультат = Тип("Число")
		Или ТипРезультат = Тип("Булево") Тогда
		
		Возврат ЗначениеИзPostgreSQL;
		
	ИначеЕсли ТипРезультат = Тип("Дата") Тогда
		
		Возврат Спец_СтроковыеФункцииКлиентСервер.СтрокаВДату(ЗначениеИзPostgreSQL, Кэш);
		
	ИначеЕсли Спец_ОбщегоНазначенияКлиентСервер.ЭтоСсылка(ТипРезультат, Кэш, Тип("Тип")) Тогда
		
		Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLЗначениеПоНормальному(ТипРезультат, ЗначениеИзPostgreSQL);
		
	Иначе
		
		Возврат ЗначениеИзPostgreSQL;
		
	КонецЕсли;
	
КонецФункции

// Возвращаемое значение:
//  Строка
//
Функция ПодготовитьСтрокуПодключенияКPostgreSQL() Экспорт
	
	СтруктураПараметровБазы = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы();
	
	#Если Сервер Тогда
		
		СтрокаПодключения = СтруктураПараметровБазы.СтрокаПодключенияКБазеДанныхНаСервере;
		Если ПустаяСтрока(СтрокаПодключения) Тогда
			СтрокаПодключения = СтруктураПараметровБазы.СтрокаПодключенияКБазеДанных;
		КонецЕсли;
		
	#Иначе
		
		СтрокаПодключения = СтруктураПараметровБазы.СтрокаПодключенияКБазеДанных;
		
	#КонецЕсли
	
	Спец_Проверить(СтрокаПодключения, "Не установлена строка подключения к базе PostgreSQL!");
	
	// Добавим application_name, чтобы было понятно откуда подключение
	Если СтрНайти(НРег(СтрокаПодключения), "application_name") = 0 Тогда
		
		#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
			НомерСеанса = Спец_ОбщегоНазначенияВызовСервера.ПолучитьНомерСеансаИнформационнойБазы();
		#Иначе
			НомерСеанса = НомерСеансаИнформационнойБазы();
		#КонецЕсли
		
		ApplicationName = Спец_СтроковыеФункцииКлиентСервер.СтрокаЛатиницей(СтрШаблон("LykovAddIn_%1_%2",
				СтруктураПараметровБазы.ИмяБазы,
				Формат(НомерСеанса, "ЧН=0; ЧГ=")));
		
		СтрокаПодключения = СтрокаПодключения + СтрШаблон(" application_name='%1'", Лев(ApplicationName, 64));
		
	КонецЕсли;
	
	Возврат СтрокаПодключения;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

//@skip-check unknown-method-property
#Область ПодготовкаПараметровТаблицы

// Параметры:
//  СоответствиеРезультат - см. ПодготовитьПараметрыТаблицыДляПомещенияВоВременнуюТаблицу
//  МассивПолейБД - Массив из Строка
//  ПоляPostgreSQL - ФиксированноеСоответствие из КлючИЗначение:
//    * Ключ - Строка
//    * Значение - см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
//
Процедура ДобавитьНайденнуюКолонкуВСоответствиеРезультат(Знач СоответствиеРезультат, Знач МассивПолейБД, Знач ПоляPostgreSQL)
	
	Для Каждого ИмяПоля Из МассивПолейБД Цикл
		
		СтруктураПоля = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(ПоляPostgreSQL, ИмяПоля); // см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
		Если СтруктураПоля <> Неопределено Тогда
			СоответствиеРезультат[ИмяПоля] = СтруктураПоля;
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

//@skip-check unknown-method-property
#Область НайтиСоздатьОбъектыВPostgreSQL

Процедура ПроставитьУникальныеИдентификаторыДляСвязиСТабличнымиЧастями(Знач ИсходныеДанные, Знач ЭтоТаблицаЗначений, Знач Кэш)
	
	Если ЭтоТаблицаЗначений Тогда

		ИсходныеДанные.Колонки.Добавить(ИмяПоляДляСвязиСТабличнымиЧастями(), Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(36));
		Для Каждого ИсходнаяСтрока Из ИсходныеДанные Цикл
			//@skip-check property-return-type
			ИсходнаяСтрока[ИмяПоляДляСвязиСТабличнымиЧастями()] = Спец_КомпонентаДополнительныеФункцииКлиентСервер.ПолучитьУникальныйИдентификатор(Кэш);
		КонецЦикла;

	Иначе

		Для Каждого ИсходнаяСтрока Из ИсходныеДанные Цикл
			ИсходнаяСтрока.Вставить(ИмяПоляДляСвязиСТабличнымиЧастями(), Спец_КомпонентаДополнительныеФункцииКлиентСервер.ПолучитьУникальныйИдентификатор(Кэш));
		КонецЦикла;

	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  ПолноеИмяМетаданных - Строка
//  ПоляДляСвязи - Массив из см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьСтруктуруПоляДляСвязиДляЗаписи
//  ЭтоТабличнаяЧасть - Булево
// 
// Возвращаемое значение:
//  Строка
//
Функция СформироватьТекстЗапросаСвязиТаблиц(Знач ПолноеИмяМетаданных, Знач ПоляДляСвязи, Знач ЭтоТабличнаяЧасть)

	ШаблонСвязи          = "vt.%1 = resTable.%1";
	ШаблонСвязиСФункцией = "%1(vt.%2, resTable.%2)";

	МассивСвязи = Новый Массив(); // Массив из Строка
	Для Каждого СтруктураПоля Из ПоляДляСвязи Цикл
		
		Если ПустаяСтрока(СтруктураПоля.ДополнительныеФункцииДляСвязи) Тогда
			МассивСвязи.Добавить(СтрШаблон(ШаблонСвязи, СтруктураПоля.ИмяСтолбцаВБД));
		Иначе
			МассивСвязи.Добавить(СтрШаблон(ШаблонСвязиСФункцией, СтруктураПоля.ДополнительныеФункцииДляСвязи, СтруктураПоля.ИмяСтолбцаВБД));
		КонецЕсли;

	КонецЦикла;

	Возврат СтрСоединить(МассивСвязи,
			"
			|		AND ");

КонецФункции

// Параметры:
//  СтруктураПараметровЗаписи - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураПараметров
//  СтруктураПараметровТаблицыВБД - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//  ПараметрыВременнойТаблицы - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//  СтруктураДополнительныеПараметры - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураДополнительныеПараметры
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
//
Функция СформироватьТекстЗапроса_НайтиНеОбновлятьНеСоздавать(Знач СтруктураПараметровЗаписи, Знач СтруктураПараметровТаблицыВБД, Знач ПараметрыВременнойТаблицы,
		Знач СтруктураДополнительныеПараметры, Знач Кэш)
	
	ПоляДляВозврата = Новый Массив(); // Массив из Строка
	Если Спец_ОбщегоНазначенияКлиентСервер.ЭтоСсылка(СтруктураПараметровТаблицыВБД.НаименованиеВ1С, Кэш, Тип("Строка")) Тогда
		
		ПолеСсылка = ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(СтруктураПараметровТаблицыВБД.НаименованиеВ1С, "Ссылка", , СтруктураПараметровТаблицыВБД);
		ПоляДляВозврата.Добавить("lykov_RRefToUID(resTable." + ПолеСсылка + ") AS uid");
		
	Иначе
		
		ПоляДляВозврата.Добавить("resTable.*");
		
	КонецЕсли;
	
	Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьМассив(СтруктураПараметровЗаписи.ДополнительныеПоляДляВозврата, ПоляДляВозврата);
	
	ШаблонБазовогоЗапроса =
	
	"SELECT DISTINCT
	|	%1
	|FROM %2 AS vt
	|	JOIN %3 AS resTable
	|		ON %4";

	Возврат СтрШаблон(ШаблонБазовогоЗапроса,
			СтрСоединить(ПоляДляВозврата, ","),
			ПараметрыВременнойТаблицы.ИмяТаблицы,
			СтруктураПараметровТаблицыВБД.НаименованиеВPostgreSQL,
			СтруктураДополнительныеПараметры.ТекстДляСвязи);
	
КонецФункции

// Параметры:
//  СтруктураПараметровЗаписи - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураПараметров
//  СтруктураПараметровТаблицыВБД - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//  ПараметрыВременнойТаблицы - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//  СтруктураДополнительныеПараметры - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураДополнительныеПараметры
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
//
Функция СформироватьТекстЗапроса_НайтиОбновлятьНеСоздавать(Знач СтруктураПараметровЗаписи, Знач СтруктураПараметровТаблицыВБД, Знач ПараметрыВременнойТаблицы,
		Знач СтруктураДополнительныеПараметры, Знач Кэш)
	
	МассивПолейДляВозврата = СформироватьПоляДляВозвратаВ1С(СтруктураПараметровЗаписи,
			СтруктураПараметровТаблицыВБД,
			ПараметрыВременнойТаблицы,
			СтруктураДополнительныеПараметры,
			Кэш);
	
	МассивПолейДляОбновления = Новый Массив(); // Массив из Строка
	Для Каждого КлючЗначение Из ПараметрыВременнойТаблицы.СоответствиеПолей Цикл
		
		Если Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураПараметровТаблицыВБД.ПоляPostgreSQL, КлючЗначение.Ключ) <> Неопределено
			И СтруктураПараметровЗаписи.ПоляДляПроверкиКонфликтов.Найти(КлючЗначение.Ключ) = Неопределено Тогда
			
			МассивПолейДляОбновления.Добавить(СтрШаблон("%1 = vt.%1", КлючЗначение.Ключ));
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтрШаблон(
			
			"UPDATE ONLY %1 AS resTable SET
			|	%2
			|	FROM %3 AS vt
			|	WHERE %4
			|	%5",
			
			СтруктураПараметровТаблицыВБД.НаименованиеВPostgreSQL,
			СтрСоединить(МассивПолейДляОбновления,
					",
					|		"),
			ПараметрыВременнойТаблицы.ИмяТаблицы,
			СтруктураДополнительныеПараметры.ТекстДляСвязи,
			?(МассивПолейДляВозврата.Количество() = 0,
					"",
					"RETURNING " + СтрСоединить(МассивПолейДляВозврата,
							",
							|		")));
	
КонецФункции

// Параметры:
//  СтруктураПараметровЗаписи - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураПараметров
//  СтруктураПараметровТаблицыВБД - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//  ПараметрыВременнойТаблицы - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//  СтруктураДополнительныеПараметры - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураДополнительныеПараметры
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
//
Функция СформироватьТекстЗапроса_НайтиНеОбновлятьСоздавать(Знач СтруктураПараметровЗаписи, Знач СтруктураПараметровТаблицыВБД, Знач ПараметрыВременнойТаблицы,
		Знач СтруктураДополнительныеПараметры, Знач Кэш)
	
	СтруктураПолей = СтруктураПолейДляВставкиВInsertInto(СтруктураПараметровЗаписи,
			СтруктураПараметровТаблицыВБД,
			ПараметрыВременнойТаблицы,
			СтруктураДополнительныеПараметры,
			Кэш);
	
	Если СтруктураПараметровЗаписи.ВозвращатьРезультат
		И СтруктураПараметровЗаписи.ПринудительноВозвращатьВсеЗаписи
		И СтруктураПолей.МассивПолейДляВозврата.Количество() Тогда
		
		Возврат СтрШаблон(
				
				"INSERT INTO %1 AS resTable (%2)
				|	(
				|		SELECT %3
				|		FROM %4 AS vt
				|		%8
				|	)
				|	ON CONFLICT (%5) DO NOTHING
				|;
				|
				|
				|SELECT %6
				|FROM %4 AS vt
				|JOIN %1 AS resTable
				|	ON %7",
				
				СтруктураПараметровТаблицыВБД.НаименованиеВPostgreSQL,
				СтрСоединить(СтруктураПолей.МассивПолейДляВставки, ", "),
				СтрСоединить(СтруктураПолей.МассивДляЗапросаДляВставки,
						",
						|			"),
				ПараметрыВременнойТаблицы.ИмяТаблицы,
				СтруктураПолей.ТекстПоляДляКонфликта,
				СтрСоединить(СтруктураПолей.МассивПолейДляВозврата,
						",
						|	"),
				СтруктураДополнительныеПараметры.ТекстДляСвязи,
				СтруктураПолей.ТекстСвязиСИсходнойТаблицей);
		
	ИначеЕсли СтруктураПолей.ТребуетсяПредложениеWith Тогда
		
		Возврат СтрШаблон(
				
				"WITH resTable AS
				|(
				|	INSERT INTO %1 AS resTable (%2)
				|	(
				|		SELECT %3
				|		FROM %4 AS vt
				|		%8
				|	)
				|	ON CONFLICT (%5) DO NOTHING
				|	RETURNING *
				|)
				|SELECT %6
				|FROM %4 AS vt
				|JOIN resTable
				|	ON %7",
				
				СтруктураПараметровТаблицыВБД.НаименованиеВPostgreSQL,
				СтрСоединить(СтруктураПолей.МассивПолейДляВставки, ", "),
				СтрСоединить(СтруктураПолей.МассивДляЗапросаДляВставки,
						",
						|			"),
				ПараметрыВременнойТаблицы.ИмяТаблицы,
				СтруктураПолей.ТекстПоляДляКонфликта,
				СтрСоединить(СтруктураПолей.МассивПолейДляВозврата,
						",
						|	"),
				СтруктураДополнительныеПараметры.ТекстДляСвязи,
				СтруктураПолей.ТекстСвязиСИсходнойТаблицей);
		
	Иначе
		
		Возврат СтрШаблон(
				
				"INSERT INTO %1 AS resTable (%2)
				|	(
				|		SELECT %3
				|		FROM %4 AS vt
				|		%7
				|	)
				|	ON CONFLICT (%5) DO NOTHING
				|	%6",
				
				СтруктураПараметровТаблицыВБД.НаименованиеВPostgreSQL,
				СтрСоединить(СтруктураПолей.МассивПолейДляВставки, ", "),
				СтрСоединить(СтруктураПолей.МассивДляЗапросаДляВставки,
						",
						|			"),
				ПараметрыВременнойТаблицы.ИмяТаблицы,
				СтруктураПолей.ТекстПоляДляКонфликта,
				?(СтруктураПолей.МассивПолейДляВозврата.Количество() = 0,
						"",
						"RETURNING " + СтрСоединить(СтруктураПолей.МассивПолейДляВозврата,
								",
								|		")),
				СтруктураПолей.ТекстСвязиСИсходнойТаблицей);
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  СтруктураПараметровЗаписи - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураПараметров
//  СтруктураПараметровТаблицыВБД - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//  ПараметрыВременнойТаблицы - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//  СтруктураДополнительныеПараметры - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураДополнительныеПараметры
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
//
Функция СформироватьТекстЗапроса_НайтиОбновлятьСоздавать(Знач СтруктураПараметровЗаписи, Знач СтруктураПараметровТаблицыВБД, Знач ПараметрыВременнойТаблицы,
		Знач СтруктураДополнительныеПараметры, Знач Кэш)
	
	Если ПустаяСтрока(СтруктураДополнительныеПараметры.ИмяТабличнойЧасти) Тогда
		
		СтруктураПолей = СтруктураПолейДляВставкиВInsertInto(СтруктураПараметровЗаписи,
				СтруктураПараметровТаблицыВБД,
				ПараметрыВременнойТаблицы,
				СтруктураДополнительныеПараметры,
				Кэш);
		
		Если СтруктураПолей.ТребуетсяПредложениеWith Тогда
			
			Возврат СтрШаблон(
					
					"WITH resTable AS
					|(
					|	INSERT INTO %1 AS resTable (%2)
					|	(
					|		SELECT %3
					|		FROM %4 AS vt
					|		%9
					|	)
					|	ON CONFLICT (%5) DO UPDATE SET
					|		%6
					|	RETURNING *
					|)
					|SELECT %7
					|FROM %4 AS vt
					|JOIN resTable
					|	ON %8",
					
					СтруктураПараметровТаблицыВБД.НаименованиеВPostgreSQL,
					СтрСоединить(СтруктураПолей.МассивПолейДляВставки, ", "),
					СтрСоединить(СтруктураПолей.МассивДляЗапросаДляВставки,
							",
							|			"),
					ПараметрыВременнойТаблицы.ИмяТаблицы,
					СтруктураПолей.ТекстПоляДляКонфликта,
					СтрСоединить(СтруктураПолей.МассивПолейДляUpdate,
							",
							|			"),
					СтрСоединить(СтруктураПолей.МассивПолейДляВозврата,
							",
							|	"),
					СтруктураДополнительныеПараметры.ТекстДляСвязи,
					СтруктураПолей.ТекстСвязиСИсходнойТаблицей);
			
		Иначе
			
			Возврат СтрШаблон(
					
					"INSERT INTO %1 AS resTable (%2)
					|	(
					|		SELECT %3
					|		FROM %4 AS vt
					|		%8
					|	)
					|	ON CONFLICT (%5) DO UPDATE SET
					|		%6
					|	%7",
					
					СтруктураПараметровТаблицыВБД.НаименованиеВPostgreSQL,
					СтрСоединить(СтруктураПолей.МассивПолейДляВставки, ", "),
					СтрСоединить(СтруктураПолей.МассивДляЗапросаДляВставки,
							",
							|			"),
					ПараметрыВременнойТаблицы.ИмяТаблицы,
					СтруктураПолей.ТекстПоляДляКонфликта,
					СтрСоединить(СтруктураПолей.МассивПолейДляUpdate,
							",
							|			"),
					?(СтруктураПолей.МассивПолейДляВозврата.Количество() = 0,
							"",
							"RETURNING " + СтрСоединить(СтруктураПолей.МассивПолейДляВозврата,
									",
									|		")),
					СтруктураПолей.ТекстСвязиСИсходнойТаблицей);
			
		КонецЕсли;
		
	Иначе // Для табличных частей
		
		// Чтобы не запутаться:
		//	1) Удаляем все записи по ссылкам
		//	2) Добавляем все записи (т.е. выполняем СформироватьТекстЗапроса_НайтиНеОбновлятьСоздавать)
		
		КопияСтруктураДополнительныеПараметры = Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьСтруктуру(СтруктураДополнительныеПараметры); // см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураДополнительныеПараметры
		
		КопияСтруктураДополнительныеПараметры.ЕстьТабличныеЧасти = Ложь;
		КопияСтруктураДополнительныеПараметры.ИмяТабличнойЧасти = "";
		
		ТекстЗапросаВставка = СформироватьТекстЗапроса_НайтиНеОбновлятьСоздавать(СтруктураПараметровЗаписи,
				СтруктураПараметровТаблицыВБД,
				ПараметрыВременнойТаблицы,
				КопияСтруктураДополнительныеПараметры,
				Кэш);
		
		Возврат СтрШаблон(
				
				"DELETE FROM %1 AS resTable USING %2 AS vt
				|	WHERE resTable.%3 = vt.%3
				|;
				|
				|
				|DELETE FROM %2 AS vt
				|	WHERE vt.spec_only_removed
				|;
				|
				|
				|%4",
				
				СтруктураПараметровТаблицыВБД.НаименованиеВPostgreSQL,
				ПараметрыВременнойТаблицы.ИмяТаблицы,
				ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(СтруктураПараметровТаблицыВБД.НаименованиеВ1С, "Ссылка", , СтруктураПараметровТаблицыВБД),
				ТекстЗапросаВставка);
		
	КонецЕсли;
	
КонецФункции

// Параметры:
//  СтруктураПараметровЗаписи - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураПараметров
//  СтруктураПараметровТаблицыВБД - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//  ПараметрыВременнойТаблицы - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//  СтруктураДополнительныеПараметры - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураДополнительныеПараметры
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Структура:
//  	* ТребуетсяПредложениеWith - Булево
//  	* МассивПолейДляВозврата - Массив из Строка
//  	* МассивПолейДляВставки - Массив из Строка
//  	* МассивДляЗапросаДляВставки - Массив из Строка
//  	* МассивПолейДляUpdate - Массив из Строка
//  	* ТекстСвязиСИсходнойТаблицей - Строка
//  	* ТекстПоляДляКонфликта - Строка
//
Функция СтруктураПолейДляВставкиВInsertInto(Знач СтруктураПараметровЗаписи, Знач СтруктураПараметровТаблицыВБД, Знач ПараметрыВременнойТаблицы,
		Знач СтруктураДополнительныеПараметры, Знач Кэш)
	
	//@skip-check structure-consructor-too-many-keys
	СтруктураРезультат = Новый Структура(
			"ТребуетсяПредложениеWith,
			|МассивПолейДляВозврата,
			|МассивПолейДляВставки,
			|МассивДляЗапросаДляВставки,
			|МассивПолейДляUpdate,
			|ТекстСвязиСИсходнойТаблицей,
			|ТекстПоляДляКонфликта",
			
			Ложь,
			Новый Массив(),
			Новый Массив(),
			Новый Массив(),
			Новый Массив(),
			"",
			""); // см. СтруктураПолейДляВставкиВInsertInto
	
	СтруктураРезультат.МассивПолейДляВозврата = СформироватьПоляДляВозвратаВ1С(СтруктураПараметровЗаписи,
			СтруктураПараметровТаблицыВБД,
			ПараметрыВременнойТаблицы,
			СтруктураДополнительныеПараметры,
			Кэш);
	
	Для Каждого ТекстЗапросаПоля Из СтруктураРезультат.МассивПолейДляВозврата Цикл
		
		Если СтрНайти(ТекстЗапросаПоля, "vt.") > 0 Тогда
			
			СтруктураРезультат.ТребуетсяПредложениеWith = Истина;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ЭтоКлючевоеИзмерение = Ложь;
	НулевойМассивОграничений = ?(СтруктураПараметровТаблицыВБД.МассивИменКлючевыхИндексов.Количество() > 0,
			СтруктураПараметровТаблицыВБД.МассивИменКлючевыхИндексов.Получить(0),
			Новый Массив()); // Массив из Строка
	
	Для Каждого МассивСтолбцовОграничение Из СтруктураПараметровТаблицыВБД.МассивИменКлючевыхИндексов Цикл
		
		Если Спец_РаботаСКоллекциямиКлиентСервер.ДанныеСовпадаютБезУчетаПорядка(МассивСтолбцовОграничение, СтруктураПараметровЗаписи.ПоляДляПроверкиКонфликтов) Тогда
			
			ЭтоКлючевоеИзмерение = Истина;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ЭтоКлючевоеИзмерение Тогда
		
		СтруктураРезультат.ТекстСвязиСИсходнойТаблицей = СтрШаблон(
				
				"LEFT JOIN %1 AS resTable
				|		ON %2",
				
				СтруктураПараметровТаблицыВБД.НаименованиеВPostgreSQL,
				СтруктураДополнительныеПараметры.ТекстДляСвязи);
		
		СтруктураРезультат.ТекстПоляДляКонфликта = СтрСоединить(НулевойМассивОграничений, ", ");
		
	Иначе
		
		СтруктураРезультат.ТекстПоляДляКонфликта = СтрСоединить(СтруктураПараметровЗаписи.ПоляДляПроверкиКонфликтов, ", ");
		
	КонецЕсли;
	
	// Тут нужно пройтись по всем столбцам таблицы в БД (иначе по недостающим полям будет пытаться вставить null и вывалится ошибка)
	Для Каждого КлючЗначение Из СтруктураПараметровТаблицыВБД.ПоляPostgreSQL Цикл
		
		ДляЗапросаДляВставки = "";
		
		// Если есть поле во временной таблице - пишем в любом случае из него
		Если ПараметрыВременнойТаблицы.СоответствиеПолей[КлючЗначение.Ключ] <> Неопределено Тогда
			
			ДляЗапросаДляВставки = "vt." + КлючЗначение.Ключ;
			СтруктураРезультат.МассивПолейДляUpdate.Добавить(СтрШаблон("%1 = EXCLUDED.%1", КлючЗначение.Ключ));
			
		ИначеЕсли КлючЗначение.Ключ = СтруктураДополнительныеПараметры.ПолеСсылка Тогда // Ссылка
			
			Если Не ПустаяСтрока(СтруктураПараметровЗаписи.ИмяПоляГУИДа) Тогда
				
				Для Каждого КлючЗначениеПомещенноеПоле Из ПараметрыВременнойТаблицы.СоответствиеПолей Цикл
					
					Если КлючЗначениеПомещенноеПоле.Значение.ИмяВ1С = СтруктураПараметровЗаписи.ИмяПоляГУИДа Тогда
						
						Если КлючЗначениеПомещенноеПоле.Значение.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Строка") Тогда
							
							ДляЗапросаДляВставки = СтрШаблон("lykov_uidtorref(vt.%1)", КлючЗначениеПомещенноеПоле.Ключ);
							Прервать;
							
						ИначеЕсли КлючЗначениеПомещенноеПоле.Значение.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Ссылочный") Тогда
							
							ДляЗапросаДляВставки = СтрШаблон("vt.%1", КлючЗначениеПомещенноеПоле.Ключ);
							Прервать;
							
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
			Если ПустаяСтрока(ДляЗапросаДляВставки) Тогда
				ДляЗапросаДляВставки = "lykov_uidtorref(uuid_generate_v4()::text)";
			КонецЕсли;
			
		ИначеЕсли КлючЗначение.Ключ = "_predefinedid" Тогда // ГУИД предопределенного элемента (лучше лишний раз не трогать)
			
			ДляЗапросаДляВставки = "lykov_uidtorref('')";
			
		ИначеЕсли КлючЗначение.Ключ = "_version" Тогда // Поле версия (всегда прибавляем 1)
			
			ДляЗапросаДляВставки = "1";
			СтруктураРезультат.МассивПолейДляUpdate.Добавить("_version = resTable._version + 1"); // Всегда ставим версию + 1 (чтобы обновлялось на форме)
			
		ИначеЕсли КлючЗначение.Ключ = "_numberprefix" Тогда // Поле префикс нумерации. Тут нужно брать из метаданных
			
			ДатаДляЗаписи = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьПеридичностьНумерацииДокумента(СтруктураПараметровТаблицыВБД.НаименованиеВ1С);
			ДляЗапросаДляВставки = СтрШаблон("%1", ПолучитьЗначениеДляPostgreSQLВТекстЗапроса(ДатаДляЗаписи, Тип("Дата"), Кэш));
			
		ИначеЕсли КлючЗначение.Ключ = "_keyfield" Тогда // Ключ строки табличной части
			
			ПолеНомерСтроки = ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(СтруктураПараметровТаблицыВБД.НаименованиеВ1С, "НомерСтроки", , СтруктураПараметровТаблицыВБД);
			Если Не ПустаяСтрока(ПолеНомерСтроки) Тогда
				
				Если ПараметрыВременнойТаблицы.СоответствиеПолей[ПолеНомерСтроки] <> Неопределено Тогда
					ДляЗапросаДляВставки = СтрШаблон("lykov_keyfieldtobytea(%1)", ПолеНомерСтроки);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		// По умолчанию пишем по умолчанию (:
		Если ПустаяСтрока(ДляЗапросаДляВставки) Тогда
			ДляЗапросаДляВставки = ПолучитьЗначениеДляЗаписиВоВременнуюТаблицуПоУмолчанию(КлючЗначение.Значение);
		КонецЕсли;
		
		СтруктураРезультат.МассивПолейДляВставки.Добавить(КлючЗначение.Ключ);
		Если Не ЭтоКлючевоеИзмерение
			И НулевойМассивОграничений.Найти(КлючЗначение.Ключ) <> Неопределено Тогда
			
			СтруктураРезультат.МассивДляЗапросаДляВставки.Добавить(СтрШаблон("COALESCE(resTable.%1, %2) AS %1", КлючЗначение.Ключ, ДляЗапросаДляВставки));
			
		Иначе
			
			СтруктураРезультат.МассивДляЗапросаДляВставки.Добавить(СтрШаблон("%1 AS %2", ДляЗапросаДляВставки, КлючЗначение.Ключ));
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Параметры:
//  СтруктураПараметровЗаписи - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураПараметров
//  СтруктураПараметровТаблицыВБД - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//  ПараметрыВременнойТаблицы - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//  СтруктураДополнительныеПараметры - см. СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую.СтруктураДополнительныеПараметры
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
// Возвращаемое значение:
//  Массив из Строка
//
Функция СформироватьПоляДляВозвратаВ1С(Знач СтруктураПараметровЗаписи, Знач СтруктураПараметровТаблицыВБД, Знач ПараметрыВременнойТаблицы,
		Знач СтруктураДополнительныеПараметры, Знач Кэш)
	
	СсылкаДобавлена = Ложь;
	
	МассивПолейДляВозврата = Новый Массив(); // Массив из Строка
	Если СтруктураДополнительныеПараметры.ЕстьТабличныеЧасти Тогда
		
		МассивПолейДляВозврата.Добавить(СтрШаблон("vt.%1 AS %1", ИмяПоляДляСвязиСТабличнымиЧастями()));
		МассивПолейДляВозврата.Добавить("lykov_RRefToUID(resTable." + СтруктураДополнительныеПараметры.ПолеСсылка + ") AS uid");
		
		СсылкаДобавлена = Истина;
		
	КонецЕсли;
	
	Если СтруктураПараметровЗаписи.ВозвращатьРезультат Тогда
		
		Если СтруктураДополнительныеПараметры.ЭтоСсылочныйОбъект Тогда
			
			Если Не СсылкаДобавлена Тогда
				МассивПолейДляВозврата.Добавить("lykov_RRefToUID(resTable." + СтруктураДополнительныеПараметры.ПолеСсылка + ") AS uid");
			КонецЕсли;
			
		Иначе
			
			МассивПолейДляВозврата.Добавить("resTable.*");
			
		КонецЕсли;
		
		Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьМассив(СтруктураПараметровЗаписи.ДополнительныеПоляДляВозврата, МассивПолейДляВозврата);
		
	КонецЕсли;
	
	Возврат МассивПолейДляВозврата;
	
КонецФункции

//@skip-check structure-consructor-value-type
//@skip-check property-return-type
//
// Параметры:
//  СтруктураОбщийРезультат - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос
//  ИсходныеДанные - см. НайтиСоздатьОбъектыВPostgreSQL.ИсходныеДанные
//  СтруктураПараметров - см. НайтиСоздатьОбъектыВPostgreSQL.СтруктураПараметров
//  СтруктураДополнительныеПараметры - см. НоваяСтруктураДополнительныхПараметров
//  МассивТабличныхЧастей - Массив из Строка
//  ТекстОшибок - см. НайтиСоздатьОбъектыВPostgreSQL.ТекстОшибок
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ПройтиТабличныеЧастиПослеЗаписиНапрямую(Знач СтруктураОбщийРезультат, Знач ИсходныеДанные, Знач СтруктураПараметров, Знач СтруктураДополнительныеПараметры,
		Знач МассивТабличныхЧастей, ТекстОшибок, Знач Кэш)
	
	Если МассивТабличныхЧастей.Количество() = 0 Или СтруктураОбщийРезультат.РезультатЗапроса.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ИмяТабличнойЧасти Из МассивТабличныхЧастей Цикл
		
		МассивДанныхДляЗапроса = СформироватьМассивДанныхДляОтправкиПоТабличнойЧасти(СтруктураОбщийРезультат,
				ИсходныеДанные,
				СтруктураПараметров,
				СтруктураДополнительныеПараметры,
				ИмяТабличнойЧасти,
				Кэш);
		
		Если МассивДанныхДляЗапроса.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураПараметровПоТабличнойЧасти = ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL(СтруктураПараметров.ИмяМетаданныхВ1С + "." + ИмяТабличнойЧасти);
		СтруктураПараметровПоТабличнойЧасти.ВозвращатьРезультат = Ложь;
		
		СтруктураПоляДляСвязи = Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьСтруктуруПоляДляСвязиДляЗаписи(СтруктураПараметровПоТабличнойЧасти.ИмяМетаданныхВ1С, "Ссылка");
		
		СтруктураПараметровПоТабличнойЧасти.ПоляДляПроверкиКонфликтов.Добавить(СтруктураПоляДляСвязи.ИмяСтолбцаВБД);
		СтруктураПараметровПоТабличнойЧасти.ПоляДляПроверкиКонфликтов.Добавить("_keyfield");
		
		ПараметрыПомещенияТабличнойЧасти = Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруПараметровПомещениеДанныхВоВременнуюТаблицу();
		ПараметрыПомещенияТабличнойЧасти.ИмяМетаданныхИз1С = СтруктураПараметровПоТабличнойЧасти.ИмяМетаданныхВ1С;
		ПараметрыПомещенияТабличнойЧасти.ИмяВременнойТаблицы = ПараметрыПомещенияТабличнойЧасти.ИмяМетаданныхИз1С;
		
		ПараметрыПомещенияТабличнойЧасти.МассивПолейДляИндекса.Добавить("Ссылка");
		
		СтруктураРезультатПомещенияПоТабличнойЧасти = ПоместитьТаблицу1СВоВременнуюТаблицу(МассивДанныхДляЗапроса, ПараметрыПомещенияТабличнойЧасти, ТекстОшибок, Кэш);
		Если СтруктураРезультатПомещенияПоТабличнойЧасти = Неопределено Тогда
			
			СтруктураОбщийРезультат.Успешно = Ложь;
			Возврат;
			
		КонецЕсли;
		
		СтруктураДополнительныеПараметрыПоТабличнойЧасти = НоваяСтруктураДополнительныхПараметров(Ложь, ИмяТабличнойЧасти, Новый Массив());
		ТекстЗапроса = СформироватьТекстЗапросаДляПоискаЗаписиОбъектовНапрямую(СтруктураПараметровПоТабличнойЧасти,
				СтруктураРезультатПомещенияПоТабличнойЧасти,
				СтруктураДополнительныеПараметрыПоТабличнойЧасти,
				ТекстОшибок,
				Кэш);
		
		Если ПустаяСтрока(ТекстЗапроса) Тогда
			
			Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
			
			ТекстОшибки = "Не удалось сформировать текст запроса для ТЧ " + ИмяТабличнойЧасти;
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстОшибки,
															 "Найти / создать объекты напрямую (PostgreSQL)",
															 ТекстОшибок);
			
			СтруктураОбщийРезультат.Успешно = Ложь;
			Возврат;
			
		КонецЕсли;
		
		СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
		Если Не СтруктураРезультат.Успешно Тогда
			
			Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось выполнить запрос!" + Символы.ПС + СтруктураРезультат.ТекстОшибки,
															 "Найти / создать объекты напрямую (PostgreSQL)",
															 ТекстОшибок);
			
			СтруктураОбщийРезультат.Успешно = Ложь;
			Возврат;
			
		ИначеЕсли Не Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLЗафиксироватьТранзакцию(Кэш) Тогда
			
			// Чтобы не висело в блоке до завершения транзакции. Ничего страшного не будет, если запишется только ссылка без ТЧ.
			
			СтруктураОбщийРезультат.Успешно = Ложь;
			СтруктураОбщийРезультат.ТекстОшибки = "Не удалось зафиксировать транзакцию!";
			
			Возврат;
	
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

// Параметры:
//  ТекстСкрипта - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Структура:
// 		* Успешно - Булево - Флаг успешности выполнения запроса
// 		* РезультатЗапроса - Массив из Структура:
// 			** sizeObject - Число
// 		* ТекстОшибки - Строка - Если запрос не был выполнен, то в данном поле будет лежать текст ошибки
//
Функция ПолучитьРезультатЗапросаРазмерТаблицы(Знач ТекстСкрипта, Знач Кэш)

	//@skip-check constructor-function-return-section
	Возврат Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстСкрипта, , , Кэш);

КонецФункции

// Параметры:
//  ИмяПоля - Строка
//  ОписаниеТипов - ОписаниеТипов
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	- Неопределено
//	- Структура: см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
Функция СтруктураПоляПоОписаниюТипов(Знач ИмяПоля, Знач ОписаниеТипов, Знач Кэш)

	ОписаниеТиповДляПроверки = Новый ОписаниеТипов(ОписаниеТипов, , "NULL");

	КоличествоТипов = ОписаниеТиповДляПроверки.Типы().Количество();
	Спец_Проверить(КоличествоТипов = 1,
			"Нельзя составные типы (или пустой тип)",
			"Спец_PostgreSQLКлиентСервер.СтруктураПоляПоОписаниюТипов");
	
	Возврат СтруктураПоляПоТипуЗначения(ИмяПоля, ОписаниеТиповДляПроверки.Типы().Получить(0), Кэш);

КонецФункции

// Параметры:
//	ИмяПоля - Строка
//	ТипОбъекта - Тип
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
//
Функция СтруктураПоляПоТипуЗначения(Знач ИмяПоля, Знач ТипОбъекта, Знач Кэш)

	СтруктураПоля = Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД();
	СтруктураПоля.ИмяСтолбцаВБД = ИмяПоля;
	СтруктураПоля.ИмяВ1С = ИмяПоля;
	
	Если ТипОбъекта = Тип("Строка") Тогда

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Строка");
		СтруктураПоля.ИмяТипаДанныхВБД = "mvarchar";

	ИначеЕсли ТипОбъекта = Тип("Число") Тогда

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число");
		СтруктураПоля.ИмяТипаДанныхВБД = "numeric";

	ИначеЕсли ТипОбъекта = Тип("Дата") Тогда

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата");
		СтруктураПоля.ИмяТипаДанныхВБД = "timestamp";

	ИначеЕсли ТипОбъекта = Тип("Булево") Тогда

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево");
		СтруктураПоля.ИмяТипаДанныхВБД = "boolean";

	Иначе

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Ссылочный");
		СтруктураПоля.НеNull = Истина;

		Если Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ОписаниеТипаВсеСсылки().СодержитТип(ТипОбъекта) 
				Или ТипОбъекта = Тип("УникальныйИдентификатор") Тогда

			СтруктураПоля.ИмяТипаДанныхВБД = "mvarchar(36)";
			СтруктураПоля.ФункцияПреобразования = "lykov_UIDToRRef(%1)";

		ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоХранилищеЗначения(ТипОбъекта, Тип("Тип")) Или ТипОбъекта = Тип("ДвоичныеДанные") Тогда

			СтруктураПоля.ИмяТипаДанныхВБД = "text";
			СтруктураПоля.ФункцияПреобразования = "lykov_DDToBytea(%1)";

		Иначе

			СтруктураПоля.ИмяТипаДанныхВБД = "text";

		КонецЕсли;

	КонецЕсли;

	Возврат СтруктураПоля;

КонецФункции

// Параметры:
//	ИсходноеЗначение - Произвольный
//	СтруктураКолонки - см. СтруктураПоляПоТипуЗначения
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Строка
//
Функция ЗначениеДляPostgreSQL_СоставнаяКолонка(Знач ИсходноеЗначение, Знач СтруктураКолонки, Знач Кэш)

	ТипКолонки = ТипЗнч(ИсходноеЗначение);
	Если СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Строка") Тогда

		Возврат ?(ТипКолонки = Тип("Строка"),
				  ПолучитьЗначениеДляPostgreSQL(ИсходноеЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число") Тогда

		Возврат ?(ТипКолонки = Тип("Число"),
				  ПолучитьЗначениеДляPostgreSQL(ИсходноеЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево") Тогда

		Возврат ?(ТипКолонки = Тип("Булево"),
				  ПолучитьЗначениеДляPostgreSQL(ИсходноеЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата") Тогда

		Возврат ?(ТипКолонки = Тип("Дата"),
				  ПолучитьЗначениеДляPostgreSQL(ИсходноеЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ДвоичныеДанные") Тогда

		Возврат ?(Спец_РаботаСКоллекциямиКлиентСервер.ЭтоХранилищеЗначения(ИсходноеЗначение, ТипКолонки)
				  Или ТипКолонки = Тип("ДвоичныеДанные")
				  Или ТипКолонки = Тип("УникальныйИдентификатор"),
				  ПолучитьЗначениеДляPostgreSQL(ИсходноеЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ИдентификаторСсылки") Тогда
		
		Возврат ?(Спец_ОбщегоНазначенияКлиентСервер.ЭтоСсылка(ИсходноеЗначение, Кэш, ТипКолонки),
			  ПолучитьЗначениеДляPostgreSQL(ИсходноеЗначение, ТипКолонки, Кэш),
			  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));
		
	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.НомерТаблицы") Тогда

		ИмяМетаданныхПоТипу = Спец_ОбщегоНазначенияКлиентСервер.ИмяМетаданныхПоТипу(ТипКолонки, Кэш);
		Возврат ?(ПустаяСтрока(ИмяМетаданныхПоТипу),
				"0",
				ПолучитьЗначениеДляPostgreSQL(Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданныхПоТипу).КодТаблицы,
																		  Тип("Число"),
																		  Кэш));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ТипТаблицы") Тогда
		
		// Только простые типы пропишем
		Если ТипКолонки = Тип("Булево") Тогда
			Возврат "2";
		ИначеЕсли ТипКолонки = Тип("Число") Тогда
			Возврат "3";
		ИначеЕсли ТипКолонки = Тип("Дата") Тогда
			Возврат "4";
		ИначеЕсли ТипКолонки = Тип("Строка") Тогда
			Возврат "5";
		Иначе
			Возврат "8";
		КонецЕсли;

	Иначе

		Возврат "";

	КонецЕсли;

КонецФункции

// Параметры:
//  СтруктураПоля - см. СтруктураПоляПоТипуЗначения
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(Знач СтруктураПоля)

	Если Не ЗначениеЗаполнено(СтруктураПоля.ТипСоставногоПоля) Тогда

		Если СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево") Тогда
			Возврат "false";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата") Тогда
			Возврат "0001-01-01 00:00:00";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число") Тогда
			Возврат "0";
		Иначе
			Возврат "";
		КонецЕсли;

	Иначе

		Если СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата") Тогда
			Возврат "0001-01-01 00:00:00";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево") Тогда
			Возврат "false";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число") Тогда
			Возврат "0";
		Иначе
			Возврат "";
		КонецЕсли;

	КонецЕсли;

КонецФункции

// Параметры:
//  СтрокаСДанными - Структура
//  ТипСоставногоПоля - ПеречислениеСсылка.Спец_ТипыСоставныхПолейБазыДанных
//  ПоляСтолбца - ФиксированныйМассив из см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьЗначениеПоСоставномуТипуИзСтроки(Знач СтрокаСДанными, Знач ТипСоставногоПоля, Знач ПоляСтолбца, Знач Кэш)

	СтруктураОтбора = Новый Структура("ТипСоставногоПоля", ТипСоставногоПоля);

	НужныйСтолбец = Спец_РаботаСКоллекциямиКлиентСервер.НайтиСтрокиВКоллекцииСтрок(СтруктураОтбора, ПоляСтолбца, Истина); // см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруСтолбцаВБД
	Если НужныйСтолбец = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	Возврат ?(Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(СтрокаСДанными, НужныйСтолбец.ИмяСтолбцаВБД, Кэш),
			  СтрокаСДанными[НужныйСтолбец.ИмяСтолбцаВБД],
			  Неопределено);

КонецФункции

// Параметры:
//  НужноНаименование - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ОчиститьНаименованиеТаблицы(Знач НужноНаименование)
	
	ГотовоеИмяВременнойТаблицы = Спец_СтроковыеФункцииКлиентСервер.ОчиститьИмяДляЗапроса(Спец_СтроковыеФункцииКлиентСервер.СтрокаЛатиницей(НужноНаименование));
	Возврат Прав(ГотовоеИмяВременнойТаблицы, 55); // Максимальная длина 63 символа - для подготовительной таблицы "_prepare"
	
КонецФункции

#КонецОбласти
