// @strict-types

//@skip-check method-too-many-params

#Область ПрограммныйИнтерфейс

// Выбрасывает исключение, если текущая база не PostgreSQL.
//
Процедура ИсключениеЕслиНеPostgreSQLБаза() Экспорт
	
	Спец_Проверить(Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы().ТипБазыДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL"),
			"Это не PostgreSQL база! Если это не так, выполните обработку обновления.");
	
КонецПроцедуры

// Подключить компоненту с инициализированным подключением.
// 
// Параметры:
//	КонстантноеИмяКомпоненты - Булево - Формировать компоненту с постоянным именем
// 
// Возвращаемое значение:
//	см. Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьКомпонентуPostgreSQL
//
Функция ПодключитьКомпонентуСИнициализированнымПодключением(Знач КонстантноеИмяКомпоненты = Истина) Экспорт

	ИсключениеЕслиНеPostgreSQLБаза();

	ВнешняяКомпонента = Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьКомпонентуPostgreSQL(КонстантноеИмяКомпоненты);
	// Без источника, т.к. если компонента не подключается, то идёт переполнение стека (Спец_ЗаписатьЛог)
	Спец_Проверить(ВнешняяКомпонента <> Неопределено, "Не удалось подключить внешнюю компоненту");
	
	СтрокаПодключения = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы().СтрокаПодключенияКБазеДанных;
	Спец_Проверить(СтрокаПодключения, "Не установлена строка подключения к базе PostgreSQL!");
	
	ВременныйКэш = Новый Структура("КомпонентаPostgreSQL", ВнешняяКомпонента);
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLУстановитьСоединение(СтрокаПодключения, ВременныйКэш);
	
	Возврат ВнешняяКомпонента;

КонецФункции

// Выполняет запрос к PostgreSQL и получает размер любого объекта (индекса, таблицы) в БД (в байтах).
// 
// Параметры:
//	НаименованиеОбъекта - Строка - Наименование объекта в PostgreSQL
//	НуженОбщийРазмерТаблицы - Булево - Нужно вернуть общий размер таблицы (pg_total_relation_size)
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Число - Размер объекта в PostgreSQL
//
Функция ПолучитьРазмерОбъектаВPostgreSQL(Знач НаименованиеОбъекта, Знач НуженОбщийРазмерТаблицы = Ложь, Кэш = Неопределено) Экспорт
	
	Спец_Проверить(Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLСоединениеУспешноУстановлено(Кэш),
			"Не удалось подключиться к базе PostgreSQL!",
			"Спец_PostgreSQLКлиентСервер.ПолучитьРазмерОбъектаВPostgreSQL");
	
	Если НуженОбщийРазмерТаблицы Тогда
		ТекстСкрипта = СтрШаблон("SELECT pg_total_relation_size('%1') AS sizeObject", НаименованиеОбъекта);
	Иначе
		ТекстСкрипта = СтрШаблон("SELECT pg_relation_size('%1') AS sizeObject", НаименованиеОбъекта);
	КонецЕсли;

	СтруктураРезультатЗапроса = ПолучитьРезультатЗапросаРазмерТаблицы(ТекстСкрипта, Кэш);
	Если СтруктураРезультатЗапроса.Успешно Тогда
		Возврат СтруктураРезультатЗапроса.РезультатЗапроса.Получить(0).sizeObject;
	Иначе
		Возврат 0;
	КонецЕсли;

КонецФункции

// Подключает компоненту PostgreSQL для нужной базы и помещает её в общий кэш.
// Возвращает значение, которое необходимо передавать в параметр "Кэш" для выполнения запросов к нужной базе.
// 
// Параметры:
//  База - СправочникСсылка.Спец_Базы
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Структура:
//		* КомпонентаPostgreSQL - см. Спец_КомпонентаДополнительныеФункцииКлиентСерверПовтИсп.ПолучитьКомпонентуPostgreSQL
Функция ПодключитьКомпонентуPostgreSQLДляДругойБазы(Знач База, Кэш = Неопределено) Экспорт
	
	Если Кэш = Неопределено Тогда Кэш = Спец_ПолучитьКэш(); КонецЕсли;
	Если Кэш.КомпонентыPostgreSQLДляДругихБаз[База] <> Неопределено Тогда Возврат Кэш.КомпонентыPostgreSQLДляДругихБаз[База]; КонецЕсли;
	
	СтруктураПараметровБазы = Спец_ОбщегоНазначенияКлиентСерверПовтИсп.СтруктураПараметровБазы(База);
	Если СтруктураПараметровБазы.ТипБазыДанных <> ПредопределенноеЗначение("Перечисление.Спец_ТипыБазыДанных.PostgreSQL")
		Или ПустаяСтрока(СтруктураПараметровБазы.СтрокаПодключенияКБазеДанных) Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Спец_ЗаписатьЛог("Получение компоненты PostgreSQL для другой базы",
			ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Информация"),
			"Попытка получения компоненты PostgreSQL с подключением к базе " + СтруктураПараметровБазы.НаименованиеБазы,
			Кэш);
	
	Попытка
		
		КомпонентаРезультат = Спец_ОбщегоНазначенияКлиентСервер.ПодключитьВнешнююКомпонентуДляРаботы("ОбщийМакет.Спец_КомпонентаLykovPostgreSQL",
				Спец_СтроковыеФункцииКлиентСервер.СтрокаЛатиницей(СтруктураПараметровБазы.ИмяБазы),
				"PostgreSQL",
				Истина,
				Истина);
		
		Спец_Проверить(КомпонентаРезультат <> Неопределено,
				"Не удалось подключить компоненту!",
				"Спец_PostgreSQLКлиентСервер.ПодключитьКомпонентуPostgreSQLДляДругойБазы");
		
		СтруктураРезультат = Новый Структура("КомпонентаPostgreSQL", КомпонентаРезультат);
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLУстановитьСоединение(СтруктураПараметровБазы.СтрокаПодключенияКБазеДанных, СтруктураРезультат);
		
		Кэш.КомпонентыPostgreSQLДляДругихБаз[База] = СтруктураРезультат;
		Возврат Кэш.КомпонентыPostgreSQLДляДругихБаз[База];
		
	Исключение
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(), "Подключение к PostgreSQL другой базы");
		Возврат Неопределено;
		
	КонецПопытки;
	
КонецФункции

#Область ЧтениеЗаписьНапрямую

//@skip-check structure-consructor-too-many-keys
#Область ДляПараметровЗапроса

// Структура параметров для записи в PostgreSQL.
// 
// Параметры:
//	ПолноеИмяМетаданныхВ1С - Строка - Полное имя объекта метаданных в 1С
// 
// Возвращаемое значение:
//	см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПодготовитьСтруктуруПараметровДляЗаписиНапрямую
//
Функция ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL(Знач ПолноеИмяМетаданныхВ1С) Экспорт
	
	Возврат Новый Структура("НаименованиеВPostgreSQL,
							 |ИмяМетаданныхВ1С,
							 |ПоляДляСвязи,
							 |ПоляДляПроверкиКонфликтов,
							 |ФормироватьГУИДСсылкиПоПолю,
							 |ИмяПоляГУИДа,
							 |ДополнительныеПоляДляВозврата,
							 |ТипОбновления,
							 |ВозвращатьРезультат",
							 Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ПолноеИмяМетаданныхВ1С).НаименованиеВPostgreSQL,
							 ПолноеИмяМетаданныхВ1С,
							 Новый Массив(),
							 Новый Массив(),
							 Ложь,
							 "UID",
							 Новый Массив(),
							 ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьСоздавать"),
							 Истина);
	
КонецФункции

// Структуру поля для связи для записи напрямую в PostgreSQL.
// 
// Параметры:
//	НаименованиеВ1С - Строка - Наименование объекта метаданных в 1С
//	ИмяПоляДляСвязиВ1С - Строка - Имя поля для связи в 1С
//	ДополнительныеФункцииДляСвязи - Строка - Дополнительные функции для связи
//	ТекстОшибок - Строка - Текст ошибок
// 
// Возвращаемое значение:
//	см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьСтруктуруПоляДляСвязиДляЗаписи
//
Функция ПолучитьСтруктуруПоляДляСвязиДляЗаписи(Знач НаименованиеВ1С, Знач ИмяПоляДляСвязиВ1С, Знач ДополнительныеФункцииДляСвязи = "", ТекстОшибок = "") Экспорт

	СтруктураТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(НаименованиеВ1С);
	Если ПустаяСтрока(СтруктураТаблицы.НаименованиеВPostgreSQL) Тогда
		Возврат ПодготовитьСтруктуруСтолбцаВPostgreSQL();
	КонецЕсли;

	МассивПоПолю = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицы.Поля, ИмяПоляДляСвязиВ1С, Новый Массив()); // ФиксированныйМассив из см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
	Если МассивПоПолю.Количество() = 0 Тогда

		ШаблонСообщения = НСтр("ru = 'Не удалось найти поле ""%1"" в таблице ""%2""'");
		ТекстСообщения = СтрШаблон(ШаблонСообщения, ИмяПоляДляСвязиВ1С, НаименованиеВ1С);
		
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ТекстСообщения, "Структура поля для связи (PostgreSQL)", ТекстОшибок);
		Возврат ПодготовитьСтруктуруСтолбцаВPostgreSQL();

	ИначеЕсли ПустаяСтрока(ДополнительныеФункцииДляСвязи) Тогда

		Возврат Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьРекурсивно(МассивПоПолю.Получить(0), Ложь);

	Иначе

		СтруктураПоля = Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьСтруктуру(МассивПоПолю.Получить(0), Ложь);
		СтруктураПоля.Вставить("ДополнительныеФункцииДляСвязи", ДополнительныеФункцииДляСвязи);

		Возврат СтруктураПоля;

	КонецЕсли;

КонецФункции

// Добавляет все ключевые измерения регистра в структуру параметров для записи напрямую в PostgreSQL.
// 
// Параметры:
//  СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ДобавитьВсеКлючевыеИзмеренияРегистра(Знач СтруктураПараметров, Кэш = Неопределено) Экспорт

	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		МассивИзмерений = Спец_ОбщегоНазначенияВызовСервера.ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(СтруктураПараметров.ИмяМетаданныхВ1С);
	#Иначе
		МассивИзмерений = Спец_ОбщегоНазначения.ПолучитьМассивИменРеквизитовДляУникальностиЗаписиРегистра(СтруктураПараметров.ИмяМетаданныхВ1С, Кэш);
	#КонецЕсли

	Если МассивИзмерений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	СтруктураТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(СтруктураПараметров.ИмяМетаданныхВ1С);
	Если Не ПустаяСтрока(СтруктураТаблицы.НаименованиеВPostgreSQL) Тогда
		Для Каждого ИмяИзмерения Из МассивИзмерений Цикл ДобавитьКлючевоеПолеДляЗапроса(СтруктураПараметров, ИмяИзмерения, Истина, Истина, СтруктураТаблицы); КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// Добавляет ключевое поле для запроса для записи напрямую в PostgreSQL.
// 
// Параметры:
//	СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL
//	ИмяКлючевогоПоля - Строка - Имя ключевого поля
//	ДобавлятьПолеСвязи - Булево - Добавлять поле связи
//	ДобавлятьПолеДляПроверкиКонфликтов - Булево - Добавлять поле для проверки конфликтов
//	СтруктураПараметровТаблицы - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//
Процедура ДобавитьКлючевоеПолеДляЗапроса(Знач СтруктураПараметров, Знач ИмяКлючевогоПоля, Знач ДобавлятьПолеСвязи = Истина, Знач ДобавлятьПолеДляПроверкиКонфликтов = Истина, СтруктураПараметровТаблицы = Неопределено) Экспорт

	Если СтруктураПараметровТаблицы = Неопределено Тогда
		СтруктураПараметровТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(СтруктураПараметров.ИмяМетаданныхВ1С);
	КонецЕсли;

	МассивПолейPostgreSQL = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураПараметровТаблицы.Поля, ИмяКлючевогоПоля, Новый Массив()); // ФиксированныйМассив из см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
	Для Каждого СтруктураПоля Из МассивПолейPostgreSQL Цикл

		Если ДобавлятьПолеСвязи Тогда
			СтруктураПараметров.ПоляДляСвязи.Добавить(СтруктураПоля);
		КонецЕсли;

		Если ДобавлятьПолеДляПроверкиКонфликтов Тогда
			СтруктураПараметров.ПоляДляПроверкиКонфликтов.Добавить(СтруктураПоля.ИмяСтолбцаВPostgreSQL);
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

#КонецОбласти

// Найти создать строки регистра в таблице в PostgreSQL
// 
// Параметры:
//	ИсходныеДанные - Массив из Структура
//				   - Массив из ФиксированнаяСтруктура
//				   - ФиксированныйМассив из Структура
//				   - ФиксированныйМассив из ФиксированнаяСтруктура
//				   - ТаблицаЗначений -
//		Исходные данные для записи в PostgreSQL. Имена колонок должны совпадать с именами столбцов в 1С
//
//	СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL
//	ТекстОшибок - Строка - Тексты ошибок при выполнении
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Булево - Успешность выполнения
//
Функция НайтиСоздатьОбъектыРегистра(Знач ИсходныеДанные, Знач СтруктураПараметров, ТекстОшибок = "", Кэш = Неопределено) Экспорт
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.НачатьЗамерДляЛогирования("Найти / создать объекты регистра через PostgreSQL");
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQL_ПодключитьЕслиНеПодключали(Кэш);
	СтруктураРезультат = НайтиСоздатьОбъектыВPostgreSQL(ИсходныеДанные, СтруктураПараметров, ТекстОшибок, Кэш);
	
	Если СтруктураРезультат = Неопределено Или Не СтруктураРезультат.Успешно Тогда
		
		Спец_ЗаписатьЛог("Найти / создать объекты регистра через PostgreSQL",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
				"Не удалось записать данные в регистр напрямую!" + Символы.ПС + ТекстОшибок,
				Кэш);
		
	КонецЕсли;
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Найти / создать объекты регистра через PostgreSQL", , Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	Возврат СтруктураРезультат <> Неопределено И СтруктураРезультат.Успешно;

КонецФункции

// Поместить таблицу 1С во временную таблицу в PostgreSQL.
// 
// Параметры:
//	ИсходныеДанные - см. НайтиСоздатьОбъектыРегистра.ИсходныеДанные
//	ИмяМетаданныхИз1С - Строка - Полное имя объекта метаданных из 1С
//	ТекстОшибок - Строка - Текст ошибок
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//	СтруктураТаблицыPostgreSQL - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//	ПропуститьНачалоТранзакции - Булево - Пропустить начало транзакции
//	ИмяВременнойТаблицы - Строка - Имя временной таблицы
// 
// Возвращаемое значение:
//  см. Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПоместитьТаблицу1СВоВременнуюТаблицу
//
Функция ПоместитьТаблицу1СВоВременнуюТаблицу(Знач ИсходныеДанные, Знач ИмяМетаданныхИз1С, ТекстОшибок = "", Кэш = Неопределено, Знач СтруктураТаблицыPostgreSQL = Неопределено, Знач ПропуститьНачалоТранзакции = Ложь, Знач ИмяВременнойТаблицы = "") Экспорт

	Если СтруктураТаблицыPostgreSQL = Неопределено Тогда
		СтруктураТаблицыPostgreSQL = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданныхИз1С);
	КонецЕсли;

	СтруктураПараметровДляПомещения = ПодготовитьПараметрыТаблицы1С(ИсходныеДанные, СтруктураТаблицыPostgreSQL, ТекстОшибок, Кэш);
	Если СтруктураТаблицыPostgreSQL = Неопределено Или СтруктураПараметровДляПомещения = Неопределено Тогда

		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось подготовить параметры таблицы для помещения!",
														 "Помещение таблицы во временную таблицу в PostgreSQL -> Подготовка параметров",
														 ТекстОшибок);

		Возврат Неопределено;

	КонецЕсли;
	
	СтруктураПараметров = ПодготовитьСтруктуруПараметровДляПомещенияВоВременнуюТаблицу(СтруктураПараметровДляПомещения, СтруктураТаблицыPostgreSQL);
	ЧерезФайлы          = ЛучшеПередаватьЧерезФайлы(ИсходныеДанные);

	Попытка
		
		// Косяк 1С (если записывать массив, у которого первый элемент - пустая строка)
		ДанныеДляПередачи = ПолучитьДанныеДляПередачиВКомпоненту(ИсходныеДанные, ЧерезФайлы, СтруктураПараметровДляПомещения, СтруктураПараметров, Кэш);

	Исключение

		ЧерезФайлы = Ложь;
		ДанныеДляПередачи = ПолучитьДанныеДляПередачиВКомпоненту(ИсходныеДанные, ЧерезФайлы, СтруктураПараметровДляПомещения, СтруктураПараметров, Кэш);

	КонецПопытки;
	
	// Запрос к PostgreSQL
	
	// а) Начало транзакции и копирование данных в таблицу.
	Если ПустаяСтрока(ИмяВременнойТаблицы) Тогда
		ИмяВременнойТаблицы = "nas_tmp";
	КонецЕсли;

	Если Не ПропуститьНачалоТранзакции Тогда
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLНачатьТранзакцию(Кэш);
	КонецЕсли;

	ТекстЗапроса = СтрШаблон("CREATE TEMPORARY TABLE nas_prepare
							 |(
							 |	%1
							 |)", СтрСоединить(СтруктураПараметров.МассивСтолбцовДляPostgreSQL, "," + Символы.ПС));

	Если Не Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ТекстЗапроса, ТекстОшибок, Кэш) Тогда

		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
		Если ЧерезФайлы Тогда
			Спец_ОбщегоНазначенияКлиентСервер.УдалитьФайлыНеМешаяРаботе(ДанныеДляПередачи);
		КонецЕсли;

		Возврат Неопределено;

	КонецЕсли;
	
	// б) Перенос данных в PostgreSQL.
	МассивКолонокДляПередачиДанных = Новый Массив(); // Массив из Строка
	Для Каждого СтолбецPostgreSQL Из СтруктураПараметров.МассивСтолбцовДляPostgreSQL Цикл

		МассивРазделенный = СтрРазделить(СтолбецPostgreSQL, " ", Ложь);
		Если МассивРазделенный.Количество() > 0 Тогда
			МассивКолонокДляПередачиДанных.Добавить(СокрЛП(МассивРазделенный.Получить(0)));
		КонецЕсли;

	КонецЦикла;

	Попытка

		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВставитьДанныеВТаблицу("nas_prepare",
																						  ДанныеДляПередачи,
																						  СтрСоединить(МассивКолонокДляПередачиДанных, ","),
																						  ЧерезФайлы,
																						  Кэш);

	Исключение

		Если ЧерезФайлы Тогда
			Спец_ОбщегоНазначенияКлиентСервер.УдалитьФайлыНеМешаяРаботе(ДанныеДляПередачи);
		КонецЕсли;

		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку(ИнформацияОбОшибке(),
														 "Помещение таблицы во временную таблицу в PostgreSQL -> Вставка данных в таблицу",
														 ТекстОшибок);

		Возврат Неопределено;

	КонецПопытки;

	Если ЧерезФайлы Тогда
		Спец_ОбщегоНазначенияКлиентСервер.УдалитьФайлыНеМешаяРаботе(ДанныеДляПередачи);
	КонецЕсли;
	
	// в) Конечный запрос и удаление подготовительной таблицы.
	ТекстЗапроса = СтрШаблон("CREATE TEMPORARY TABLE %2 ON COMMIT DROP AS
							 |SELECT
							 |	%1
							 |FROM
							 |	nas_prepare;
							 |
							 |DROP TABLE nas_prepare;
							 |
							 |ANALYZE %2", СтрСоединить(СтруктураПараметров.МассивПолейДляЗапросаPostgreSQL, ","), ИмяВременнойТаблицы);

	Если Не Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ТекстЗапроса, ТекстОшибок, Кэш) Тогда
		Возврат Неопределено;
	КонецЕсли;

	СтруктураДляВозврата = Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьСтруктуру(СтруктураТаблицыPostgreSQL, Ложь);
	Спец_РаботаСКоллекциямиКлиентСервер.ДополнитьОбъект(СтруктураПараметровДляПомещения, СтруктураДляВозврата);

	СтруктураДляВозврата.Вставить("ИмяТаблицы", ИмяВременнойТаблицы);
	СтруктураДляВозврата.Вставить("МассивПолей", СтруктураПараметров.МассивПолейДляВозврата);

	//@skip-check constructor-function-return-section
	Возврат СтруктураДляВозврата;

КонецФункции

// Найти создать ссылочные объекты в PostgreSQL.
// 
// Параметры:
//  ИсходныеДанные - см. НайтиСоздатьОбъектыРегистра.ИсходныеДанные
//  СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL
//  ТекстОшибок - Строка - Текст ошибок
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос
//
Функция НайтиСоздатьОбъектыВPostgreSQL(Знач ИсходныеДанные, Знач СтруктураПараметров, ТекстОшибок = "", Кэш = Неопределено) Экспорт
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.НачатьЗамерДляЛогирования("Найти / создать объекты через PostgreSQL", Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	ТипИсходныхДанных = ТипЗнч(ИсходныеДанные);
	
	// 0. Подготовим поля для связи ссылок, если есть ТЧ
	МассивТабличныхЧастей = ПодготовитьТабличныеЧастиДляЗаписиНапрямую(СтруктураПараметров, ИсходныеДанные, ТипИсходныхДанных, ТекстОшибок);
	ЕстьТЧ = МассивТабличныхЧастей.Количество() > 0;
	
	// 1. Сначала основные данные
	ТекстЗапроса = НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса(ИсходныеДанные,
																					 СтруктураПараметров,
																					 СтруктураПараметров.ИмяМетаданныхВ1С,
																					 СтруктураПараметров.ФормироватьГУИДСсылкиПоПолю,
																					 Ложь,
																					 СтруктураПараметров.ВозвращатьРезультат Или ЕстьТЧ,
																					 Кэш,
																					 ЕстьТЧ,
																					 ТекстОшибок);

	Если ПустаяСтрока(ТекстЗапроса) Тогда

		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось сформировать текст запроса!",
														 "Найти / создать объекты напрямую (PostgreSQL)",
														 ТекстОшибок);
		
		Спец_ЗаписатьЛог("Найти / создать объекты через PostgreSQL",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
				ТекстОшибок,
				Кэш);
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Найти / создать объекты через PostgreSQL", , Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Возврат Неопределено;

	КонецЕсли;

	СтруктураРезультат = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
	Если Не СтруктураРезультат.Успешно Тогда

		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось выполнить запрос!" + Символы.ПС + СтруктураРезультат.ТекстОшибки,
														 "Найти / создать объекты напрямую (PostgreSQL)",
														 ТекстОшибок);
		
		Спец_ЗаписатьЛог("Найти / создать объекты через PostgreSQL",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
				ТекстОшибок,
				Кэш);
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Найти / создать объекты через PostgreSQL", , Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Возврат Неопределено;

	ИначеЕсли Не Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLЗафиксироватьТранзакцию(Кэш) Тогда
		
		// Чтобы не висело в блоке до завершения транзакции. Ничего страшного не будет, если запишется только ссылка без ТЧ.
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Найти / создать объекты через PostgreSQL", , Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Возврат Неопределено;

	КонецЕсли;

	Если ЕстьТЧ
		 И СтруктураПараметров.ТипОбновления <> ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиНеОбновлятьНеСоздавать")
		 И СтруктураРезультат.РезультатЗапроса.Количество() > 0 Тогда

		ПройтиТабличныеЧастиПослеЗаписиНапрямую(СтруктураРезультат, МассивТабличныхЧастей, СтруктураПараметров, ИсходныеДанные, Кэш, ТекстОшибок);

	КонецЕсли;
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Найти / создать объекты через PostgreSQL", , Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов

	//@skip-check constructor-function-return-section
	Возврат СтруктураРезультат;

КонецФункции

// Удалить данные по объекту 1С в PostgreSQL.
// 
// Параметры:
//  ИсходныеДанные - см. НайтиСоздатьОбъектыРегистра.ИсходныеДанные
//  ИмяМетаданныхИз1С - Строка - Полное имя объекта метаданных из 1С
//  ТекстОшибок - Строка - Тексты ошибок при выполнении
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Булево - Флаг успешности выполнения
//
Функция УдалитьДанныеПоОбъекту1СВPostgreSQL(Знач ИсходныеДанные, Знач ИмяМетаданныхИз1С, ТекстОшибок = "", Кэш = Неопределено) Экспорт
	
	// ++ Спец_БСП.Спец_ЛогированиеОбъектов
	Спец_ЛогированиеОбъектовКлиентСервер.НачатьЗамерДляЛогирования("Удаление объектов через PostgreSQL", Кэш);
	// -- Спец_БСП.Спец_ЛогированиеОбъектов
	
	Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(ИсходныеДанные);

	СтруктураОсновнойТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданныхИз1С);
	Если ПустаяСтрока(СтруктураОсновнойТаблицы.НаименованиеВPostgreSQL) Тогда

		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось найти параметры по указанной таблице!",
														 "Удалить данные по объекту (PostgreSQL)",
														 ТекстОшибок);
		
		Спец_ЗаписатьЛог("Удаление объектов через PostgreSQL",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
				ТекстОшибок,
				Кэш);
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Удаление объектов через PostgreSQL", , Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Возврат Ложь;

	КонецЕсли;

	МассивТаблицДляОчистки = Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(СтруктураОсновнойТаблицы); // Массив из см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
	
	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		МассивТЧ = Спец_ОбщегоНазначенияВызовСервера.ПолучитьМассивИменТабличныхЧастей(ИмяМетаданныхИз1С);
	#Иначе
		МассивТЧ = Спец_ОбщегоНазначения.ПолучитьМассивИменТабличныхЧастей(ИмяМетаданныхИз1С, Кэш);
	#КонецЕсли
	
	Для Каждого ИмяТабличнойЧасти Из МассивТЧ Цикл

		СтруктураТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданныхИз1С + "." + ИмяТабличнойЧасти);
		Если Не ПустаяСтрока(СтруктураТаблицы.НаименованиеВPostgreSQL) Тогда
			МассивТаблицДляОчистки.Добавить(СтруктураТаблицы);
		КонецЕсли;

	КонецЦикла;

	Если ИсходныеДанные.Количество() = 0 Тогда

		МассивИменаТаблиц = Новый Массив(); // Массив из Строка
		Для Каждого СтруктураТаблицы Из МассивТаблицДляОчистки Цикл
			МассивИменаТаблиц.Добавить(СтруктураТаблицы.НаименованиеВPostgreSQL);
		КонецЦикла;
		
		
		Успешно = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата("TRUNCATE " + СтрСоединить(МассивИменаТаблиц, ","), ТекстОшибок, Кэш);
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Удаление объектов через PostgreSQL", , Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Возврат Успешно;
		
	КонецЕсли;

	СтруктураРезультатПомещения = ПоместитьТаблицу1СВоВременнуюТаблицу(ИсходныеДанные, ИмяМетаданныхИз1С, ТекстОшибок, Кэш, СтруктураОсновнойТаблицы);
	Если СтруктураРезультатПомещения = Неопределено Или ПустаяСтрока(СтруктураРезультатПомещения.ИмяТаблицы) Тогда
		
		Спец_ЗаписатьЛог("Удаление объектов через PostgreSQL",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
				ТекстОшибок,
				Кэш);
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Удаление объектов через PostgreSQL", , Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Возврат Ложь;
		
	КонецЕсли;

	Если МассивТЧ.Количество() > 0 Тогда

		МассивТекстЗапроса = Новый Массив(); // Массив из Строка

		ШаблонТекстаЗапроса =
		"DELETE FROM ONLY %1
		|WHERE %2 IN (SELECT _idrref FROM %3)";

		Для Каждого СтруктураТаблицы Из МассивТаблицДляОчистки Цикл

			ТекстЗапроса = СтрШаблон(ШаблонТекстаЗапроса,
									 СтруктураТаблицы.НаименованиеВPostgreSQL,
									 Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(СтруктураТаблицы.НаименованиеВ1С, "Ссылка"),
									 СтруктураРезультатПомещения.ИмяТаблицы);

			МассивТекстЗапроса.Добавить(ТекстЗапроса);

		КонецЦикла;

		МассивТекстЗапроса.Добавить("COMMIT");

		ГотовыйТекстЗапроса = СтрСоединить(МассивТекстЗапроса, ";" + Символы.ПС);

	Иначе

		ШаблонТекстаЗапроса =
		"DELETE FROM ONLY %1
		|WHERE (%2) IN (SELECT %2 FROM %3);
		|
		|COMMIT;";

		МассивПолейИзPostgreSQL = Новый Массив(); // Массив из Строка
		Для Каждого ИмяПоля1С Из СтруктураРезультатПомещения.МассивИменКолонокОбновлять Цикл
			Для Каждого КлючЗначение Из СтруктураРезультатПомещения.Поля[ИмяПоля1С] Цикл МассивПолейИзPostgreSQL.Добавить(КлючЗначение.ИмяСтолбцаВPostgreSQL); КонецЦикла;
		КонецЦикла;

		ГотовыйТекстЗапроса = СтрШаблон(ШаблонТекстаЗапроса,
										СтруктураОсновнойТаблицы.НаименованиеВPostgreSQL,
										СтрСоединить(МассивПолейИзPostgreSQL, ","),
										СтруктураРезультатПомещения.ИмяТаблицы);

	КонецЕсли;
	
	Если Не Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапросБезРезультата(ГотовыйТекстЗапроса, ТекстОшибок, Кэш) Тогда
		
		Спец_ЗаписатьЛог("Удаление объектов через PostgreSQL",
				ПредопределенноеЗначение("Перечисление.Спец_УровниЛогирования.Предупреждение"),
				ТекстОшибок,
				Кэш);
		
		Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Удаление объектов через PostgreSQL", , Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Возврат Ложь;
		
	Иначе
		
		// ++ Спец_БСП.Спец_ЛогированиеОбъектов
		Спец_ЛогированиеОбъектовКлиентСервер.ЛогироватьЗавершениеЗамера("Удаление объектов через PostgreSQL", , Кэш);
		// -- Спец_БСП.Спец_ЛогированиеОбъектов
		
		Возврат Истина;
	
	КонецЕсли;

КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Получить значение в формате для PostgreSQL (для чтение через COPY FROM)
// 
// Параметры:
//  пЗначение - Произвольный - Значение для преобразования в PostgreSQL
//  ТипРеквизита - Неопределено, Тип - Тип реквизита
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка - Значение в формате PostgreSQL
//
Функция ПолучитьЗначениеДляPostgreSQL(Знач пЗначение, Знач ТипРеквизита = Неопределено, Кэш = Неопределено) Экспорт

	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(пЗначение); КонецЕсли;
	Если ТипРеквизита = Тип("Строка") Тогда

		Возврат пЗначение;

	ИначеЕсли Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ОписаниеТипаПеречисления().СодержитТип(ТипРеквизита) И ТипРеквизита <> Тип("Неопределено") Тогда
		
		СоответствиеПредопределенныхОбъектов = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСоответствиеПредопределенныхДанныхИГУИДов();
		Возврат Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СоответствиеПредопределенныхОбъектов, пЗначение, "00000000-0000-0000-0000-000000000000");

	Иначе

		Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLСтрокуПоНормальному(пЗначение);

	КонецЕсли;

КонецФункции

// Получить значение в формате для PostgreSQL (для записи в текст запроса)
// 
// Параметры:
//  пЗначение - Произвольный - Значение для преобразования в PostgreSQL
//  ТипРеквизита - Неопределено, Тип - Тип реквизита
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка - Значение в формате PostgreSQL
//
Функция ПолучитьЗначениеДляPostgreSQLВТекстЗапроса(Знач пЗначение, Знач ТипРеквизита = Неопределено, Кэш = Неопределено) Экспорт
	
	Если ТипРеквизита = Неопределено Тогда ТипРеквизита = ТипЗнч(пЗначение); КонецЕсли;
	
	ЗначениеРеквизита = ПолучитьЗначениеДляPostgreSQL(пЗначение, ТипРеквизита, Кэш);
	Если ТипРеквизита = Тип("Строка") Тогда
		Возврат СтрШаблон("'%1'", ЗначениеРеквизита);
	ИначеЕсли ТипРеквизита = Тип("Число") Или ТипРеквизита = Тип("Булево") Тогда
		Возврат ЗначениеРеквизита;
	ИначеЕсли ТипРеквизита = Тип("Дата") Тогда
		Возврат СтрШаблон("'%1'::timestamp", ЗначениеРеквизита);
	ИначеЕсли Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ОписаниеТипаВсеСсылки().СодержитТип(ТипРеквизита) Тогда
		Возврат СтрШаблон("lykov_uidtorref('%1')", ЗначениеРеквизита);
	Иначе
		Возврат ЗначениеРеквизита;
	КонецЕсли;
	
КонецФункции

// Получить значение для записи во временную таблицу в PostgreSQL по умолчанию (до преобразования)
// 
// Параметры:
//  СтруктураПоля - см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
// 
// Возвращаемое значение:
//  Строка - Значение для записи во временную таблицу по умолчанию
//
Функция ПолучитьЗначениеДляЗаписиВоВременнуюТаблицуПоУмолчанию(Знач СтруктураПоля) Экспорт

	Если Не ЗначениеЗаполнено(СтруктураПоля.ТипСоставногоПоля) Тогда

		Если СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево") Тогда
			Возврат "false";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата") Тогда
			Возврат "'0001-01-01 00:00:00'::timestamp";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Строка") Тогда
			Возврат "''::" + СтруктураПоля.ИмяТипаДанныхДляPostgreSQL;
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число") Тогда
			Возврат "0";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Ссылочный") Тогда
			Возврат "lykov_UIDToRRef('')";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.NULL") Тогда
			Возврат "NULL";
		Иначе
			Возврат "decode('', 'base64')";
		КонецЕсли;

	Иначе

		Если СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ИдентификаторСсылки") Тогда
			Возврат "lykov_UIDToRRef('')";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Строка") Тогда
			Возврат "''::" + СтруктураПоля.ИмяТипаДанныхДляPostgreSQL;
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево") Тогда
			Возврат "false";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата") Тогда
			Возврат "'0001-01-01 00:00:00'::timestamp";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число") Тогда
			Возврат "0";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ДвоичныеДанные") Тогда
			Возврат "decode('', 'base64')";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.НомерТаблицы") Тогда
			Возврат "lykov_RTRefToBytea(0)";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ТипТаблицы") Тогда
			Возврат "lykov_TypeToBytea(1)";
		Иначе
			Возврат "NULL";
		КонецЕсли;

	КонецЕсли;

КонецФункции

// Получить функцию преобразования значения из PostgreSQL.
// 
// Параметры:
//  СтруктураПоля - см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
// 
// Возвращаемое значение:
//  Строка - Функция преобразования
//
Функция ПолучитьФункциюПреобразованияЗначенияИзPostrgeSQL(Знач СтруктураПоля) Экспорт

	Если Не ЗначениеЗаполнено(СтруктураПоля.ТипСоставногоПоля) Тогда

		Если СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Ссылочный") Тогда
			Возврат "lykov_RRefToUID(%1)";
		Иначе
			Возврат "";
		КонецЕсли;

	Иначе

		Если СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ИдентификаторСсылки") Тогда
			Возврат "lykov_RRefToUID(%1)";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.НомерТаблицы") Тогда
			Возврат "lykov_RTRefToInteger(%1)";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ТипТаблицы") Тогда
			Возврат "lykov_ByteaToType(%1)";
		Иначе
			Возврат "";
		КонецЕсли;

	КонецЕсли;

КонецФункции

// Получить тип колонки для временной таблицы в PostgreSQL по умолчанию.
// 
// Параметры:
//  СтруктураПоля - см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
// 
// Возвращаемое значение:
//  Строка - Тип колонки для временной таблицы по умолчанию
//
Функция ПолучитьТипКолонкиДляВременнойТаблицыПоУмолчанию(Знач СтруктураПоля) Экспорт

	Если Не ЗначениеЗаполнено(СтруктураПоля.ТипСоставногоПоля) Тогда

		Если СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево") Тогда
			Возврат "boolean";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата") Тогда
			Возврат "timestamp";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Строка") Тогда
			Возврат "mvarchar";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число") Тогда
			Возврат "numeric";
		Иначе
			Возврат "bytea";
		КонецЕсли;

	Иначе

		Если СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Строка") Тогда
			Возврат "mvarchar";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево") Тогда
			Возврат "boolean";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата") Тогда
			Возврат "timestamp";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число") Тогда
			Возврат "numeric";
		Иначе
			Возврат "bytea";
		КонецЕсли;

	КонецЕсли;

КонецФункции

// Преобразовать значение из PostgreSQL в значение 1С.
// 
// Параметры:
//  СтрокаСДанными - Структура - Структура строки из PostgreSQL
//  ПолноеИмяОбъекта - Строка - Полное имя объекта в 1С
//  ИмяСтолбцаВ1С - Строка - Имя столбца в 1С
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Неопределено, Булево, Число, Дата, Строка, ЛюбаяСсылка - Значение в 1С
//
Функция ПреобразоватьЗначениеИзPostgreSQL(Знач СтрокаСДанными, Знач ПолноеИмяОбъекта, Знач ИмяСтолбцаВ1С, Кэш = Неопределено) Экспорт

	СтруктураТаблицы = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ПолноеИмяОбъекта);

	ПоляСтолбца = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицы.Поля, ИмяСтолбцаВ1С, Новый Массив); // ФиксированныйМассив из см. Спец_PostgreSQLКлиентСервер.ПодготовитьСтруктуруСтолбцаВPostgreSQL
	Если ПоляСтолбца.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если ПоляСтолбца.Количество() <> 1 Тогда
		
		// Сначала смотрим тип столбца
		ТипСтолбца = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
															  ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ТипТаблицы"),
															  ПоляСтолбца,
															  Кэш);
		Если ТипСтолбца = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;

		Если ТипСтолбца = "2" Тогда // Булево

			ЗначениеБулево = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	  ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево"),
																	  ПоляСтолбца,
																	  Кэш);
			Возврат ЗначениеБулево = "t";

		ИначеЕсли ТипСтолбца = "3" Тогда // Число

			ЗначениеЧисло = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	 ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число"),
																	 ПоляСтолбца,
																	 Кэш);
			Возврат ?(ЗначениеЧисло = Неопределено, 0, Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЗначениеЧисло));

		ИначеЕсли ТипСтолбца = "4" Тогда // Дата

			ЗначениеДата = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата"),
																	ПоляСтолбца,
																	Кэш);
			Возврат ?(ЗначениеДата = Неопределено, Дата(1, 1, 1), Спец_СтроковыеФункцииКлиентСервер.СтрокаВДату(ЗначениеДата, ЧастиДаты.ДатаВремя));

		ИначеЕсли ТипСтолбца = "5" Тогда // Строка

			ЗначениеСтрока = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	  ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Строка"),
																	  ПоляСтолбца,
																	  Кэш);
			Возврат ?(ЗначениеСтрока = Неопределено, "", ЗначениеСтрока);

		ИначеЕсли ТипСтолбца = "8" Тогда // Ссылочный

			НомерТаблицы = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
																	ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.НомерТаблицы"),
																	ПоляСтолбца,
																	Кэш);
			Если НомерТаблицы = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;

			Ссылка = ПолучитьЗначениеПоСоставномуТипуИзСтроки(СтрокаСДанными,
															  ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ИдентификаторСсылки"),
															  ПоляСтолбца,
															  Кэш);
			Если Ссылка = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;

			НомерТаблицыЧисло = Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(НомерТаблицы);
			НаименованиеТаблицыВ1С = Спец_РаботаСБазойДанныхНапрямуюКлиентСервер.ПолучитьНаименованиеТаблицыВ1СПоКоду(НомерТаблицыЧисло);

			Если ПустаяСтрока(НаименованиеТаблицыВ1С) Тогда
				Возврат Неопределено;
			КонецЕсли;

			ПозицияТочки  = СтрНайти(НаименованиеТаблицыВ1С, ".");
			НужноеИмяТипа = Лев(НаименованиеТаблицыВ1С, ПозицияТочки - 1) + "Ссылка" + Сред(НаименованиеТаблицыВ1С, ПозицияТочки);

			Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLЗначениеПоНормальному(Тип(НужноеИмяТипа), Ссылка);

		Иначе

			Возврат Неопределено;

		КонецЕсли;

	Иначе

		НулевойСтолбец = ПоляСтолбца.Получить(0);
		Если Не Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(СтрокаСДанными, НулевойСтолбец.ИмяСтолбцаВPostgreSQL, Кэш) Тогда
			Возврат Неопределено;
		КонецЕсли;

		ЗначениеСтолбца = СтрокаСДанными[НулевойСтолбец.ИмяСтолбцаВPostgreSQL]; // Строка
		Если НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево") Тогда

			Возврат ЗначениеСтолбца = "t";

		ИначеЕсли НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата") Тогда

			Возврат Спец_СтроковыеФункцииКлиентСервер.СтрокаВДату(ЗначениеСтолбца, ЧастиДаты.ДатаВремя);

		ИначеЕсли НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Строка") Тогда

			Возврат ЗначениеСтолбца;

		ИначеЕсли НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число") Тогда

			Возврат Спец_СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЗначениеСтолбца);

		ИначеЕсли НулевойСтолбец.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Ссылочный") Тогда

			#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
				ТипРеквизита = Спец_ОбщегоНазначенияВызовСервера.ПолучитьТипРеквизитаВ1С(ПолноеИмяОбъекта, ИмяСтолбцаВ1С);
			#Иначе
				ТипРеквизита = Спец_ОбщегоНазначения.ПолучитьТипРеквизитаВ1С(ПолноеИмяОбъекта, ИмяСтолбцаВ1С, Кэш);
			#КонецЕсли

			Возврат Спец_ОбщегоНазначенияКлиентСервер.ПолучитьXMLЗначениеПоНормальному(ТипРеквизита, ЗначениеСтолбца);

		Иначе

			Возврат ЗначениеСтолбца;

		КонецЕсли;

	КонецЕсли;

КонецФункции

// ЭТО ОЧЕНЬ ГРУБАЯ ОЦЕНКА (более точная будет занимать слишком много времени).
// Берём количество строк * количество колонок и, так как в основном передаются ссылки,
// за количество байт в одном столбце берём 36 символов (длина идентификатора ссылки).
// Если полученный размер превышает 2 буфера данных для потоков, то лучше передавать через файлы.
// 
// Параметры:
//  ИсходныеДанныеДляПередачи - ТаблицаЗначений, Массив из Структура - Исходные данные для передачи
// 
// Возвращаемое значение:
//  Булево - Флаг того, что лучше передавать через файлы
//
Функция ЛучшеПередаватьЧерезФайлы(Знач ИсходныеДанныеДляПередачи) Экспорт

	ТипИсходныхДанных = ТипЗнч(ИсходныеДанныеДляПередачи);
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ИсходныеДанныеДляПередачи, ТипИсходныхДанных) Тогда

		Возврат ИсходныеДанныеДляПередачи.Количество()
				* ИсходныеДанныеДляПередачи.Колонки.Количество()
				* Спец_КонстантыКлиентСервер.ДлинаИдентификатораСсылки() > Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков"), 16384) * 2;

	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИсходныеДанныеДляПередачи, ТипИсходныхДанных) Тогда

		Если ИсходныеДанныеДляПередачи.Количество() = 0 Тогда
			Возврат Ложь;
		ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(ИсходныеДанныеДляПередачи.Получить(0)) Тогда
			Возврат ИсходныеДанныеДляПередачи.Количество()
					* ИсходныеДанныеДляПередачи.Получить(0).Количество()
					* Спец_КонстантыКлиентСервер.ДлинаИдентификатораСсылки() > Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков"), 16384) * 2;
		Иначе
			Возврат ИсходныеДанныеДляПередачи.Количество()
					* Спец_КонстантыКлиентСервер.ДлинаИдентификатораСсылки() > Спец_ПолучитьКонстанту(ПредопределенноеЗначение("ПланВидовХарактеристик.Спец_Константы.РазмерБуфераДляПотоков"), 16384) * 2;
		КонецЕсли;

	Иначе

		Возврат Ложь;

	КонецЕсли;

КонецФункции

// Подготовить структуру столбца в PostgreSQL для работы с БД напрямую.
// 
// Возвращаемое значение:
//  Структура - Структура столбца в PostgreSQL:
// * ИмяСтолбцаВPostgreSQL - Строка - Наименование столбца в PostgreSQL
// * ИмяВ1С - Строка - Наименование столбца в 1С
// * ТипДанных - ПеречислениеСсылка.Спец_ТипыДанныхБазыДанных - Тип данных столбца в PostgreSQL
// * ТипСоставногоПоля - ПеречислениеСсылка.Спец_ТипыСоставныхПолейБазыДанных - Тип составного поля в PostgreSQL
// * ИмяТипаДанныхДляPostgreSQL - Строка - Наименование типа данных в PostgreSQL
// * ФункцияПреобразования - Строка - Функция преобразования для связи в PostgreSQL
// * НеNull - Булево - Колонка должна быть не null
//
Функция ПодготовитьСтруктуруСтолбцаВPostgreSQL() Экспорт

	//@skip-check structure-consructor-too-many-keys
	СтруктураДляВозврата = Новый Структура("ИмяСтолбцаВPostgreSQL,
							|ИмяВ1С,
							|ТипДанных,
							|ТипСоставногоПоля,
							|ИмяТипаДанныхДляPostgreSQL,
							|ФункцияПреобразования,
							|НеNull", "", "", ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.ПустаяСсылка"), ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ПустаяСсылка"), "", "", Ложь);
							
	Возврат СтруктураДляВозврата;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПодготовкаПараметровТаблицы

// Параметры:
//	ИсходныеДанные - Массив из Структура
//				   - ТаблицаЗначений
//  СтруктураТаблицы - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//  ТекстОшибок - Строка
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//	
// Возвращаемое значение:
//	Структура:
//		* СоответствиеВсехПолейPostrgeSQL - Соответствие из КлючИЗначение:
//			** Ключ - Строка
//			** Значение - Массив из см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
//		* МассивИменКолонокОбновлять - Массив из Строка - Только те, которые есть в ИсходныеДанные (имена из 1С)
//		* МассивКолонокДляЗначенияПоУмолчанию - Массив из Строка - Только те, которых нет в ИсходныеДанные, но есть в таблице PostgreSQL (имена 1С)
//
Функция ПодготовитьПараметрыТаблицы1С(Знач ИсходныеДанные, Знач СтруктураТаблицы, ТекстОшибок, Знач Кэш)

	Если СтруктураТаблицы = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	СтруктураРезультат = НоваяСтруктураПараметровТаблицы1С(СтруктураТаблицы.ПоляPostgreSQL);

	ТипИсходныхДанных = ТипЗнч(ИсходныеДанные);
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ИсходныеДанные, ТипИсходныхДанных) Тогда

		МассивКолонокДляПодбораПоЗначению = Новый Массив(); // Массив из Строка
		Для Каждого КлючЗначение Из СтруктураТаблицы.Поля Цикл

			Если ИсходныеДанные.Колонки.Найти(КлючЗначение.Ключ) <> Неопределено Тогда
				ДобавитьНайденнуюКолонкуВПараметрыТаблицы(СтруктураРезультат, КлючЗначение);
			Иначе
				ДобавитьКолонкуВЗначенияПоУмолчаниюВПараметрыТаблицы(СтруктураРезультат, КлючЗначение);
			КонецЕсли;

		КонецЦикла;
		
		// Добавляем колонки, которых нет в 1С.
		Для Каждого Колонка Из ИсходныеДанные.Колонки Цикл

			Если СтруктураРезультат.МассивИменКолонокОбновлять.Найти(Колонка.Имя) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;

			Если Колонка.ТипЗначения.Типы().Количество() > 0 Тогда

				ТипОбъекта = Колонка.ТипЗначения.Типы().Получить(0);
				Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ТипОбъекта, Тип("Тип"))
					 Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ТипОбъекта, Тип("Тип")) Тогда // Передана табличная часть объекта

					Продолжить;

				КонецЕсли;

				СтруктураРезультат.МассивИменКолонокОбновлять.Добавить(Колонка.Имя);

				СтруктураПоля = СтруктураПоляПоОписаниюТипов(Колонка.Имя, Колонка.ТипЗначения, Кэш);
				СтруктураРезультат.СоответствиеВсехПолейPostrgeSQL[СтруктураПоля.ИмяСтолбцаВPostgreSQL] = Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(СтруктураПоля);

			Иначе

				МассивКолонокДляПодбораПоЗначению.Добавить(Колонка.Имя);

			КонецЕсли;

		КонецЦикла;

		Если МассивКолонокДляПодбораПоЗначению.Количество() > 0 И ИсходныеДанные.Количество() > 0 Тогда

			Если ИсходныеДанные.Количество() = 0 Тогда
				Возврат СтруктураРезультат;
			КонецЕсли;

			НулеваяСтрока = ИсходныеДанные.Получить(0);
			Для Каждого ИмяКолонки Из МассивКолонокДляПодбораПоЗначению Цикл
				ДобавитьКолонкуПоЗначениюВПараметрыТаблицы(НулеваяСтрока[ИмяКолонки], ИмяКолонки, СтруктураРезультат, Кэш);
			КонецЦикла;

		КонецЕсли;

	ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИсходныеДанные, ТипИсходныхДанных) И ИсходныеДанные.Количество() > 0 Тогда

		НулеваяСтрока = ИсходныеДанные.Получить(0);

		ТипСтроки = ТипЗнч(НулеваяСтрока);
		Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоСтруктура(НулеваяСтрока, ТипСтроки) Тогда

			Для Каждого КлючЗначение Из СтруктураТаблицы.Поля Цикл

				Если НулеваяСтрока.Свойство(КлючЗначение.Ключ) Тогда
					ДобавитьНайденнуюКолонкуВПараметрыТаблицы(СтруктураРезультат, КлючЗначение);
				Иначе
					ДобавитьКолонкуВЗначенияПоУмолчаниюВПараметрыТаблицы(СтруктураРезультат, КлючЗначение);
				КонецЕсли;

			КонецЦикла;

		Иначе

			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Могу распознать только массив структур!",
															 "Спец_PostgreSQLКлиентСервер.ПодготовитьПараметрыТаблицы1С(...)",
															 ТекстОшибок);

			Возврат Неопределено;

		КонецЕсли;

		Для Каждого КлючЗначение Из НулеваяСтрока Цикл

			Если СтруктураРезультат.МассивИменКолонокОбновлять.Найти(КлючЗначение.Ключ) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;

			ДобавитьКолонкуПоЗначениюВПараметрыТаблицы(КлючЗначение.Значение, КлючЗначение.Ключ, СтруктураРезультат, Кэш);

		КонецЦикла;

	Иначе

		Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Нужен либо массив либо таблица значений!",
														 "Спец_PostgreSQLКлиентСервер.ПодготовитьПараметрыТаблицы1С(...)",
														 ТекстОшибок);

		Возврат Неопределено;

	КонецЕсли;

	СтруктураРезультат.МассивИменКолонокОбновлять = Спец_РаботаСКоллекциямиКлиентСервер.СвернутьМассив(СтруктураРезультат.МассивИменКолонокОбновлять);
	СтруктураРезультат.МассивКолонокДляЗначенияПоУмолчанию = Спец_РаботаСКоллекциямиКлиентСервер.СвернутьМассив(СтруктураРезультат.МассивКолонокДляЗначенияПоУмолчанию);

	Возврат СтруктураРезультат;

КонецФункции

// Параметры:
//  СтруктураРезультат - см. ПодготовитьПараметрыТаблицы1С
//  КлючЗначениеСтруктурыПоля - КлючИЗначение:
//		* Ключ - Строка
//		* Значение - Массив из см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
//
Процедура ДобавитьНайденнуюКолонкуВПараметрыТаблицы(Знач СтруктураРезультат, Знач КлючЗначениеСтруктурыПоля)

	Для Каждого СтруктураПоля Из КлючЗначениеСтруктурыПоля.Значение Цикл

		Если СтруктураПоля.ИмяСтолбцаВPostgreSQL = "_predefinedid" Тогда // Не надо трогать, если строка в базе уже есть.
			Продолжить;
		КонецЕсли;

		СтруктураРезультат.МассивИменКолонокОбновлять.Добавить(СтруктураПоля.ИмяВ1С);

	КонецЦикла;

КонецПроцедуры

// Параметры:
//  СтруктураРезультат - см. ПодготовитьПараметрыТаблицы1С
//  КлючЗначениеСтруктурыПоля - КлючИЗначение:
//		* Ключ - Строка
//		* Значение - Массив из см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
//
Процедура ДобавитьКолонкуВЗначенияПоУмолчаниюВПараметрыТаблицы(СтруктураРезультат, Знач КлючЗначениеСтруктурыПоля)

	Для Каждого СтруктураПоля Из КлючЗначениеСтруктурыПоля.Значение Цикл
		СтруктураРезультат.МассивКолонокДляЗначенияПоУмолчанию.Добавить(СтруктураПоля.ИмяВ1С);
	КонецЦикла;

КонецПроцедуры

// Параметры:
//	ЗначениеСтроки - Произвольный
//	ИмяКолонки - Строка
//	СтруктураРезультат - см. ПодготовитьПараметрыТаблицы1С
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//
Процедура ДобавитьКолонкуПоЗначениюВПараметрыТаблицы(Знач ЗначениеСтроки, Знач ИмяКолонки, Знач СтруктураРезультат, Знач Кэш)

	ТипОбъекта = ТипЗнч(ЗначениеСтроки);
	Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ЗначениеСтроки, ТипОбъекта)
			Или Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ЗначениеСтроки, ТипОбъекта) Тогда // Передана табличная часть объекта

		Возврат;

	КонецЕсли;

	СтруктураРезультат.МассивИменКолонокОбновлять.Добавить(ИмяКолонки);

	СтруктураПоля = СтруктураПоляПоТипуЗначения(ИмяКолонки, ТипОбъекта, Кэш);
	СтруктураРезультат.СоответствиеВсехПолейPostrgeSQL[СтруктураПоля.ИмяСтолбцаВPostgreSQL] = Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассиве(СтруктураПоля);

КонецПроцедуры

#КонецОбласти

#Область ПомещениеВоВременнуюТаблицу

// Параметры:
//	СтруктураПараметровДляПомещения - см. ПодготовитьПараметрыТаблицы1С
//	СтруктураТаблицыPostgreSQL - см. Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных
//
// Возвращаемое значение:
//	Структура:
//		* МассивПолейДляВозврата - Массив из Строка
//		* МассивСтолбцовДляPostgreSQL - Массив из Строка
//		* МассивПолейДляЗапросаPostgreSQL - Массив из Строка
//		* СоответствиеКэшЭтоСоставное - Соответствие из КлючИЗначение:
//			** Ключ - Строка
//			** Значение - Булево
//		* СоответствиеДляИсходныхДанных - Соответствие из КлючИЗначение:
//			** Ключ - Строка - Имя столбца в 1С
//			** Значение - ФиксированныйМассив из см. Спец_PostgreSQLКлиентСервер.ПодготовитьСтруктуруСтолбцаВPostgreSQL
//
Функция ПодготовитьСтруктуруПараметровДляПомещенияВоВременнуюТаблицу(Знач СтруктураПараметровДляПомещения, Знач СтруктураТаблицыPostgreSQL)

	СтруктураРезультат = НоваяСтруктураПараметровДляПомещенияВоВременнуюТаблицу();
	Для Каждого ИмяКолонки Из СтруктураПараметровДляПомещения.МассивИменКолонокОбновлять Цикл

		МассивСтруктурПолей = СтруктураТаблицыPostgreSQL.Поля.Получить(ИмяКолонки);
		Если МассивСтруктурПолей <> Неопределено Тогда // Это поле из 1С

			СтруктураРезультат.СоответствиеДляИсходныхДанных[ИмяКолонки] = МассивСтруктурПолей;
			Для Каждого СтруктураПоля Из МассивСтруктурПолей Цикл
				ЗаполнитьМассивыДляЗапросаPostrgeSQL(СтруктураРезультат, СтруктураПоля);
			КонецЦикла;

		Иначе // Руками добавленное поле

			ФиксМассивСтруктурПолей = СтруктураПараметровДляПомещения.СоответствиеВсехПолейPostrgeSQL.Получить(ИмяКолонки);
			Если ФиксМассивСтруктурПолей <> Неопределено Тогда

				СтруктураРезультат.СоответствиеДляИсходныхДанных[ИмяКолонки] = СтруктураПоля;
				Для Каждого СтруктураПоля Из ФиксМассивСтруктурПолей Цикл
					ЗаполнитьМассивыДляЗапросаPostrgeSQL(СтруктураРезультат, СтруктураПоля);
				КонецЦикла;

			КонецЕсли;

		КонецЕсли;

		СтруктураРезультат.СоответствиеКэшЭтоСоставное[ИмяКолонки] = СтруктураРезультат.СоответствиеДляИсходныхДанных[ИмяКолонки] <> Неопределено
				И СтруктураРезультат.СоответствиеДляИсходныхДанных[ИмяКолонки].Количество() > 1;

	КонецЦикла;

	Для Каждого ИмяКолонки Из СтруктураПараметровДляПомещения.МассивКолонокДляЗначенияПоУмолчанию Цикл

		МассивСтруктурПолей = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураТаблицыPostgreSQL.Поля, ИмяКолонки, Новый Массив()); // ФиксированныйМассив из см. Спец_PostgreSQLКлиентСервер.ПодготовитьСтруктуруСтолбцаВPostgreSQL
		Для Каждого СтруктураПоля Из МассивСтруктурПолей Цикл

			СтруктураРезультат.МассивПолейДляВозврата.Добавить(НРег(СтруктураПоля.ИмяСтолбцаВPostgreSQL));
			СтруктураРезультат.МассивПолейДляЗапросаPostgreSQL.Добавить(СтрШаблон("%1 AS %2",
															   ПолучитьЗначениеДляЗаписиВоВременнуюТаблицуПоУмолчанию(СтруктураПоля),
															   НРег(СтруктураПоля.ИмяСтолбцаВPostgreSQL)));

		КонецЦикла;

	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Параметры:
//  СтруктураРезультат - см. ПодготовитьСтруктуруПараметровДляПомещенияВоВременнуюТаблицу
//  СтруктураПоля - см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
//
Процедура ЗаполнитьМассивыДляЗапросаPostrgeSQL(Знач СтруктураРезультат, Знач СтруктураПоля)

	ИмяСтолбца = НРег(СтруктураПоля.ИмяСтолбцаВPostgreSQL);
	ИмяДляЗапроса = "nas_prepare." + ИмяСтолбца;

	СтруктураРезультат.МассивПолейДляВозврата.Добавить(ИмяСтолбца);

	СтруктураРезультат.МассивСтолбцовДляPostgreSQL.Добавить(СтрШаблон("%1 %2", ИмяСтолбца, СтруктураПоля.ИмяТипаДанныхДляPostgreSQL));
	Если Не ПустаяСтрока(СтруктураПоля.ФункцияПреобразования) Тогда

		СтруктураРезультат.МассивПолейДляЗапросаPostgreSQL.Добавить(СтрШаблон("%1 AS %2", СтрШаблон(СтруктураПоля.ФункцияПреобразования, ИмяДляЗапроса), ИмяСтолбца));

	Иначе

		СтруктураРезультат.МассивПолейДляЗапросаPostgreSQL.Добавить(СтрШаблон("%1 AS %2", ИмяДляЗапроса, ИмяСтолбца));

	КонецЕсли;

КонецПроцедуры

// Параметры:
//	ИсходныеДанные - см. НайтиСоздатьОбъектыРегистра.ИсходныеДанные
//	ЧерезФайлы - Булево
//  СтруктураПараметровДляПомещения - см. ПодготовитьПараметрыТаблицы1С
//  СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляПомещенияВоВременнуюТаблицу
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьДанныеДляПередачиВКомпоненту(Знач ИсходныеДанные, Знач ЧерезФайлы, Знач СтруктураПараметровДляПомещения, Знач СтруктураПараметров, Знач Кэш)
	
#Если Не ВебКлиент Тогда

	Если ЧерезФайлы Тогда

		ПотокДляЗаписи = Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьФайловыйПотокСИменемФайла();
		ЗаписьJSON = Спец_ОбщегоНазначенияКлиентСервер.ПодготовитьЗаписьJSONПоПотоку(ПотокДляЗаписи);

	Иначе

		ЗаписьJSON = Новый ЗаписьJSON();
		ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));

	КонецЕсли;

	ЗаписьJSON.ЗаписатьНачалоМассива();
	Для Каждого Стр Из ИсходныеДанные Цикл ЗаписьJSON.ЗаписатьНачалоМассива(); Для Каждого ИмяКолонки Из СтруктураПараметровДляПомещения.МассивИменКолонокОбновлять Цикл Если СтруктураПараметров.СоответствиеКэшЭтоСоставное[ИмяКолонки] Тогда Для Каждого СтруктураПоля Из СтруктураПараметров.СоответствиеДляИсходныхДанных[ИмяКолонки] Цикл ЗаписьJSON.ЗаписатьЗначение(ЗначениеДляPostgreSQL_СоставнаяКолонка(Стр[ИмяКолонки], СтруктураПоля, Кэш)); КонецЦикла; Иначе ЗаписьJSON.ЗаписатьЗначение(ПолучитьЗначениеДляPostgreSQL(Стр[ИмяКолонки], , Кэш)); КонецЕсли; КонецЦикла; ЗаписьJSON.ЗаписатьКонецМассива(); КонецЦикла;
	ЗаписьJSON.ЗаписатьКонецМассива();

	Если ЧерезФайлы Тогда

		ЗаписьJSON.Закрыть();
		Спец_ОбщегоНазначенияКлиентСервер.ЗакрытьПотокНеМешаяРаботе(ПотокДляЗаписи, Истина);
		Возврат ПотокДляЗаписи.ИмяФайла;

	Иначе

		Возврат ЗаписьJSON.Закрыть();

	КонецЕсли;

#Иначе
	
	ВызватьИсключение "Недоступно на веб-клиенте!";

#КонецЕсли

КонецФункции

#КонецОбласти

#Область НайтиСоздатьОбъектыВPostgreSQL

// Параметры:
//	СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL
//	ИсходныеДанные - см. НайтиСоздатьОбъектыРегистра.ИсходныеДанные
//	ТипИсходныхДанных - Тип
//	ТекстОшибок - Строка
// 
// Возвращаемое значение:
//	Массив из Строка
//
Функция ПодготовитьТабличныеЧастиДляЗаписиНапрямую(Знач СтруктураПараметров, Знач ИсходныеДанные, Знач ТипИсходныхДанных, ТекстОшибок)

	#Если ТонкийКлиент Или ВебКлиент Или ТолстыйКлиентУправляемоеПриложение Тогда
		МассивТабличныхЧастей = Спец_ОбщегоНазначенияВызовСервера.ПолучитьМассивИменТабличныхЧастей(СтруктураПараметров.ИмяМетаданныхВ1С);
	#Иначе
		МассивТабличныхЧастей = Спец_ОбщегоНазначения.ПолучитьМассивИменТабличныхЧастей(СтруктураПараметров.ИмяМетаданныхВ1С);
	#КонецЕсли

	Если МассивТабличныхЧастей.Количество() > 0 Тогда // Подчистим ТЧ, если их нет.

		МассивДляУдаления = Новый Массив(); // Массив из Строка
		Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ИсходныеДанные, ТипИсходныхДанных) Тогда

			Для Каждого ИмяТабличнойЧасти Из МассивТабличныхЧастей Цикл

				Если ИсходныеДанные.Колонки.Найти(ИмяТабличнойЧасти) = Неопределено Тогда
					МассивДляУдаления.Добавить(ИмяТабличнойЧасти);
				КонецЕсли;

			КонецЦикла;

		ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоМассив(ИсходныеДанные, ТипИсходныхДанных) Тогда

			Если ИсходныеДанные.Количество() > 0 Тогда

				НулеваяСтрока = ИсходныеДанные.Получить(0);
				Для Каждого ИмяТабличнойЧасти Из МассивТабличныхЧастей Цикл

					Если Не НулеваяСтрока.Свойство(ИмяТабличнойЧасти) Тогда
						МассивДляУдаления.Добавить(ИмяТабличнойЧасти);
					КонецЕсли;

				КонецЦикла;

			КонецЕсли;

		Иначе

			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Могу работать только с массивами или таблицами значений!",
															 "Найти / создать объекты в PostgreSQL -> Табличные части",
															 ТекстОшибок);

			Возврат Неопределено;

		КонецЕсли;

		Для Каждого ИмяДляУдаления Из МассивДляУдаления Цикл
			Спец_РаботаСКоллекциямиКлиентСервер.УдалитьЗначениеИзМассива(МассивТабличныхЧастей, ИмяДляУдаления);
		КонецЦикла;

	КонецЕсли;

	Если МассивТабличныхЧастей.Количество() > 0 Тогда

		Если Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ИсходныеДанные, ТипИсходныхДанных) Тогда

			ИсходныеДанные.Колонки.Добавить("postgresql_key", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(36));
			Для Каждого ИсходнаяСтрока Из ИсходныеДанные Цикл
				//@skip-check property-return-type
				ИсходнаяСтрока.postgresql_key = Спец_СтроковыеФункцииКлиентСервер.ПолучитьУникальныйИдентификатор();
			КонецЦикла;

		Иначе

			Для Каждого ИсходнаяСтрока Из ИсходныеДанные Цикл
				ИсходнаяСтрока.Вставить("postgresql_key", Спец_СтроковыеФункцииКлиентСервер.ПолучитьУникальныйИдентификатор());
			КонецЦикла;

		КонецЕсли;

	КонецЕсли;

	Возврат МассивТабличныхЧастей;

КонецФункции

//@skip-check structure-consructor-value-type
//@skip-check property-return-type
//
// Параметры:
//  СтруктураРезультат - см. Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос
//  МассивТабличныхЧастей - Массив из Строка
//  СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL
//  ИсходныеДанные - см. НайтиСоздатьОбъектыРегистра.ИсходныеДанные
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  ТекстОшибок - Строка
//
Процедура ПройтиТабличныеЧастиПослеЗаписиНапрямую(Знач СтруктураРезультат, Знач МассивТабличныхЧастей, Знач СтруктураПараметров, Знач ИсходныеДанные, Знач Кэш, ТекстОшибок)

	Для Каждого ИмяТабличнойЧасти Из МассивТабличныхЧастей Цикл

		МассивДанныхДляЧистки = Новый Массив(); // Массив из Строка
		ИмяМетаданных1С = СтруктураПараметров.ИмяМетаданныхВ1С + "." + ИмяТабличнойЧасти;
		СтруктураТЧ = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданных1С);
		ШаблонПараметрДляЧистки = "lykov_UIDToRRef('%1')";

		ДанныеДляПередачи = Новый Массив(); // Массив из Структура
		Для Каждого ИсходнаяСтрока Из ИсходныеДанные Цикл

			
			СтруктураОтбора = Новый Структура("postgresql_key", ИсходнаяСтрока["postgresql_key"]);
			СтрокаГУИД = Спец_РаботаСКоллекциямиКлиентСервер.НайтиСтрокиВКоллекцииСтрок(СтруктураОтбора, СтруктураРезультат.РезультатЗапроса, Истина);

			Если СтрокаГУИД = Неопределено Тогда
				Продолжить;
			КонецЕсли;

			ДанныеДляРедактирования = ИсходнаяСтрока[ИмяТабличнойЧасти]; // ТаблицаЗначений, Массив из Структура
			ЭтоТаблицаЗначений = Спец_РаботаСКоллекциямиКлиентСервер.ЭтоТаблицаЗначений(ДанныеДляРедактирования);
			
			Если ДанныеДляРедактирования.Количество() = 0 Тогда

				МассивДанныхДляЧистки.Добавить(СтрШаблон(ШаблонПараметрДляЧистки, СтрокаГУИД["uid"]));
				Продолжить;

			КонецЕсли;

			Если ЭтоТаблицаЗначений Тогда
				
				Если ДанныеДляРедактирования.Колонки.Найти("НомерСтроки") = Неопределено Тогда
					ДанныеДляРедактирования.Колонки.Добавить("НомерСтроки", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаЧисло(15));
				КонецЕсли;
				Если ДанныеДляРедактирования.Колонки.Найти("Ссылка") = Неопределено Тогда
					ДанныеДляРедактирования.Колонки.Добавить("Ссылка", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаСтрока(36));
				КонецЕсли;
				Если ДанныеДляРедактирования.Колонки.Найти("_keyfield") = Неопределено Тогда
					ДанныеДляРедактирования.Колонки.Добавить("_keyfield", Спец_ОбщегоНазначенияКлиентСервер.ОписаниеТипаЧисло(15));
				КонецЕсли;
				
			КонецЕсли;
			
			НомерСтроки = 1;
			Для Каждого СтрокаТЧ Из ДанныеДляРедактирования Цикл

				Если ЭтоТаблицаЗначений Тогда

					СтрокаТЧ.НомерСтроки = НомерСтроки;
					СтрокаТЧ.Ссылка = СтрокаТЧ;
					СтрокаТЧ._keyfield = НомерСтроки;

				Иначе
					
					СтрокаТЧ.Вставить("НомерСтроки", НомерСтроки);
					СтрокаТЧ.Вставить("Ссылка", СтрокаГУИД["uid"]);
					СтрокаТЧ.Вставить("_keyfield", СтрокаТЧ["НомерСтроки"]);
					
				КонецЕсли;

				ДанныеДляПередачи.Добавить(СтрокаТЧ);
				НомерСтроки = НомерСтроки + 1;

			КонецЦикла;

		КонецЦикла;

		Если МассивДанныхДляЧистки.Количество() > 0
			 И (СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьНеСоздавать")
				Или СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьСоздавать")) Тогда

			ШаблонТекстаЗапроса =
			"DELETE FROM ONLY %1
			|WHERE %2 IN (%3)";

			ТекстЗапроса = СтрШаблон(ШаблонТекстаЗапроса,
									 СтруктураТЧ.НаименованиеВPostgreSQL,
									 Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(ИмяМетаданных1С, "Ссылка"),
									 СтрСоединить(МассивДанныхДляЧистки, ","));

			СтруктураРезультатТЧ = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, 0, , Кэш);
			Если СтруктураРезультатТЧ <> Истина Тогда

				Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось выполнить запрос! " + СтруктураРезультатТЧ.ТекстОшибки,
																 "Найти / создать объекты в PostgreSQL -> Табличные части",
																 ТекстОшибок);

				Возврат;

			КонецЕсли;

		КонецЕсли;

		Если ДанныеДляПередачи.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;

		ТекстЗапроса = НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса(ДанныеДляПередачи,
																						 СтруктураПараметров,
																						 ИмяМетаданных1С,
																						 Ложь,
																						 Истина,
																						 Ложь,
																						 Кэш,
																						 Ложь,
																						 ТекстОшибок);

		Если ПустаяСтрока(ТекстЗапроса) Тогда

			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось сформировать запрос для обновления таблицы!",
															 "Найти / создать объекты в PostgreSQL -> Табличные части",
															 ТекстОшибок);

			Возврат;

		КонецЕсли;

		СтруктураРезультатТЧ = Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстЗапроса, , , Кэш);
		Если Не СтруктураРезультатТЧ.Успешно Тогда

			Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLОтменитьТранзакцию(Кэш);
			Спец_ОбщегоНазначенияКлиентСервер.ДобавитьОшибку("Не удалось выполнить запрос по ТЧ! " + СтруктураРезультатТЧ.ТекстОшибки,
															  "Найти / создать объекты в PostgreSQL -> Табличные части",
															 ТекстОшибок);

			Возврат;

		ИначеЕсли Не Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLЗафиксироватьТранзакцию(Кэш) Тогда
			
			// Чтобы не висело в блоке до завершения транзакции. Ничего страшного не будет, если запишется только одна из ТЧ.
			Возврат;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область НайтиСоздатьДанныеВPostrgeSQL_ФормированиеЗапроса

// Параметры:
//  ИсходныеДанные - см. НайтиСоздатьОбъектыРегистра.ИсходныеДанные
//  СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL
//  ИмяМетаданныхВ1С - Строка
//  ФормироватьГУИДСсылкиПоПолю - Булево
//  ЭтоТабличнаяЧасть - Булево
//  ВозвращатьРезультат - Булево
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
//  НужноВернутьКлюч - Булево
//  ТекстОшибок - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса(Знач ИсходныеДанные, Знач СтруктураПараметров, Знач ИмяМетаданныхВ1С, Знач ФормироватьГУИДСсылкиПоПолю, Знач ЭтоТабличнаяЧасть, Знач ВозвращатьРезультат, Знач Кэш, Знач НужноВернутьКлюч, ТекстОшибок)

	// Помещаем таблицу во временную
	СтруктураРезультатПомещения = ПоместитьТаблицу1СВоВременнуюТаблицу(ИсходныеДанные, ИмяМетаданныхВ1С, ТекстОшибок, Кэш);
	Если СтруктураРезультатПомещения = Неопределено Тогда
		Возврат "";
	КонецЕсли;

	МассивПолейТаблицыДляЗаписи = Новый Массив(); // Массив из Строка
	ИмяТаблицыPostgreSQL = ?(ЭтоТабличнаяЧасть,
							 Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданныхВ1С).НаименованиеВPostgreSQL,
							 СтруктураПараметров.НаименованиеВPostgreSQL);

	ПолеСсылка = Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьИмяПоляВPostgreSQLПоИмениВ1С(ИмяМетаданныхВ1С, "Ссылка");
	
	// Связь таблиц
	ТекстСвязиТаблиц = НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_ТекстСвязиТаблиц(ИмяМетаданныхВ1С,
																										  ПолеСсылка,
																										  СтруктураПараметров.ПоляДляСвязи,
																										  ЭтоТабличнаяЧасть);
	
	// Если поиск, то ничего лишнего.
	Если СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиНеОбновлятьНеСоздавать") Тогда

		Возврат НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_ТолькоПоиск(СтруктураПараметров.ДополнительныеПоляДляВозврата,
																							  ПолеСсылка,
																							  СтруктураРезультатПомещения.ИмяТаблицы,
																							  ИмяТаблицыPostgreSQL,
																							  ТекстСвязиТаблиц);

	КонецЕсли;
	
	// Поля для возврата
	ПолеДляВозврата = НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_ПоляДляВозврата(СтруктураПараметров.ДополнительныеПоляДляВозврата,
																										ПолеСсылка,
																										СтруктураРезультатПомещения.МассивПолей,
																										СтруктураПараметров.ТипОбновления,
																										НужноВернутьКлюч);
	
	// Конфликтные поля
	КонфликтныеПоля = ?(ЭтоТабличнаяЧасть, ПолеСсылка + ",_keyfield", СтрСоединить(СтруктураПараметров.ПоляДляПроверкиКонфликтов, ","));
	
	// Готовим базовый запрос
	БазовыйЗапрос = НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_БазовыйЗапрос(ИмяТаблицыPostgreSQL,
																									СтруктураПараметров,
																									СтруктураРезультатПомещения,
																									ТекстСвязиТаблиц,
																									ФормироватьГУИДСсылкиПоПолю,
																									МассивПолейТаблицыДляЗаписи);
	
	// Теперь добавляем в запрос для нужной операции.
	Если СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиНеОбновлятьСоздавать") Тогда

		Возврат НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_НайтиНеОбновлятьСоздавать(ВозвращатьРезультат,
																											БазовыйЗапрос,
																											ИмяТаблицыPostgreSQL,
																											МассивПолейТаблицыДляЗаписи,
																											КонфликтныеПоля,
																											ПолеДляВозврата,
																											ТекстСвязиТаблиц);

	ИначеЕсли СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьНеСоздавать") Тогда

		Возврат НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_НайтиОбновлятьНеСоздавать(ВозвращатьРезультат,
																											БазовыйЗапрос,
																											ИмяТаблицыPostgreSQL,
																											СтруктураРезультатПомещения,
																											КонфликтныеПоля,
																											ПолеДляВозврата,
																											ТекстСвязиТаблиц,
																											ЭтоТабличнаяЧасть,
																											ПолеСсылка);

	ИначеЕсли СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьСоздавать") Тогда

		Возврат НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_НайтиОбновлятьСоздавать(ВозвращатьРезультат,
																										  БазовыйЗапрос,
																										  ИмяТаблицыPostgreSQL,
																										  СтруктураРезультатПомещения,
																										  КонфликтныеПоля,
																										  ПолеДляВозврата,
																										  ТекстСвязиТаблиц,
																										  ЭтоТабличнаяЧасть,
																										  ПолеСсылка,
																										  МассивПолейТаблицыДляЗаписи);

	Иначе

		Возврат "";

	КонецЕсли;

КонецФункции

// Параметры:
//  ИмяТаблицыPostgreSQL - Строка
//  СтруктураПараметров - см. ПодготовитьСтруктуруПараметровДляЗаписиВPostgreSQL
//  СтруктураРезультатПомещения - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//  ТекстСвязиТаблиц - Строка
//  ФормироватьГУИДСсылкиПоПолю - Булево
//  МассивПолейТаблицыДляЗаписи - Массив из Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_БазовыйЗапрос(Знач ИмяТаблицыPostgreSQL, Знач СтруктураПараметров, Знач СтруктураРезультатПомещения, Знач ТекстСвязиТаблиц, Знач ФормироватьГУИДСсылкиПоПолю, МассивПолейТаблицыДляЗаписи)

	ШаблонПоля = "vt.%1 AS %1";
	ШаблонПоляNull = "COALESCE(resTable.%1, vt.%1) AS %1";

	ШаблонБазовогоЗапроса =
	"SELECT
	|	%1
	|FROM %2 AS vt
	|	%5 JOIN %3 AS resTable
	|		ON %4";

	МассивПолейБазовогоЗапроса = Новый Массив(); // Массив из Строка
	ТолькоИзИсходной           = СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьНеСоздавать");
	ОбщийМассивПолей           = Новый Массив(); // Массив из Строка

	Для Каждого КлючЗначение Из СтруктураРезультатПомещения.СоответствиеВсехПолейPostrgeSQL Цикл
		
		МассивПолейДляОбработки = КлючЗначение.Значение;
		Спец_РаботаСКоллекциямиКлиентСервер.ЗначениеВМассив(МассивПолейДляОбработки);
		
		Для Каждого СтруктураПоля Из МассивПолейДляОбработки Цикл
	
			ОбщийМассивПолей.Добавить(СтруктураПоля.ИмяСтолбцаВPostgreSQL);
			Если СтруктураРезультатПомещения.МассивПолей.Найти(СтруктураПоля.ИмяСтолбцаВPostgreSQL) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
	
			Если СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьНеСоздавать")
				 И СтруктураПараметров.ПоляДляПроверкиКонфликтов.Найти(СтруктураПоля.ИмяСтолбцаВPostgreSQL) = Неопределено
				 И СтруктураРезультатПомещения.МассивИменКолонокОбновлять.Найти(СтруктураПоля.ИмяВ1С) = Неопределено Тогда
	
				Продолжить;
	
			КонецЕсли;
			
			// Проверяем корректность стандартных полей (ссылочных типов)
			Если СтруктураПоля.ИмяСтолбцаВPostgreSQL = "_idrref" Тогда
	
				Если ТолькоИзИсходной Тогда
	
					МассивПолейБазовогоЗапроса.Добавить("resTable._idrref AS _idrref");
	
				ИначеЕсли ФормироватьГУИДСсылкиПоПолю
						  И Не ПустаяСтрока(СтруктураПараметров.ИмяПоляГУИДа)
						  И СтруктураРезультатПомещения.МассивПолей.Найти(СтруктураПараметров.ИмяПоляГУИДа) <> Неопределено Тогда
	
					МассивПолейБазовогоЗапроса.Добавить("COALESCE(resTable._idrref, lykov_UIDToRRef(vt." + СтруктураПараметров.ИмяПоляГУИДа + ")) AS _idrref");
	
				Иначе
	
					МассивПолейБазовогоЗапроса.Добавить("COALESCE(resTable._idrref, lykov_UIDToRRef(uuid_generate_v4()::text)) AS _idrref");
	
				КонецЕсли;
	
			ИначеЕсли СтруктураПоля.ИмяСтолбцаВPostgreSQL = "_predefinedid" Тогда
	
				Если ТолькоИзИсходной Тогда
					МассивПолейБазовогоЗапроса.Добавить("resTable._predefinedid AS _predefinedid");
				Иначе
					МассивПолейБазовогоЗапроса.Добавить("lykov_UIDToRRef(null) AS _predefinedid"); // Не нужно сюда ничего ставить левого.
				КонецЕсли;
	
			ИначеЕсли СтруктураПоля.ИмяСтолбцаВPostgreSQL = "_version" Тогда // Всегда прибавляем единицу (для корректного потом отображения на форме)
	
				МассивПолейБазовогоЗапроса.Добавить("COALESCE(resTable._version + 1, vt._version) AS _version");
	
			ИначеЕсли СтруктураРезультатПомещения.МассивИменКолонокОбновлять.Найти(СтруктураПоля.ИмяВ1С) <> Неопределено Тогда
	
				МассивПолейБазовогоЗапроса.Добавить(СтрШаблон(ШаблонПоля, СтруктураПоля.ИмяСтолбцаВPostgreSQL));
	
			Иначе
	
				МассивПолейБазовогоЗапроса.Добавить(СтрШаблон(ШаблонПоляNull, СтруктураПоля.ИмяСтолбцаВPostgreSQL));
	
			КонецЕсли;
	
			МассивПолейТаблицыДляЗаписи.Добавить(СтруктураПоля.ИмяСтолбцаВPostgreSQL);
			
		КонецЦикла;

	КонецЦикла;

	РазностьМассивов = Спец_РаботаСКоллекциямиКлиентСервер.РазностьОбъектов(СтруктураРезультатПомещения.МассивПолей, ОбщийМассивПолей);
	Для Каждого НеизвестноеПоле Из РазностьМассивов Цикл
		МассивПолейБазовогоЗапроса.Добавить(СтрШаблон(ШаблонПоля, НеизвестноеПоле));
	КонецЦикла;

	ТипСоединения = "";
	Если СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьСоздавать")
		 Или СтруктураПараметров.ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиНеОбновлятьСоздавать") Тогда

		ТипСоединения = "LEFT";

	КонецЕсли;

	Возврат СтрШаблон(ШаблонБазовогоЗапроса,
					  СтрСоединить(МассивПолейБазовогоЗапроса, ","),
					  СтруктураРезультатПомещения.ИмяТаблицы,
					  ИмяТаблицыPostgreSQL,
					  ТекстСвязиТаблиц,
					  ТипСоединения);

КонецФункции

// Параметры:
//  ИмяМетаданныхВ1С - Строка
//  ПолеСсылка - Строка
//  ПоляДляСвязи - Массив из см. ПолучитьСтруктуруПоляДляСвязиДляЗаписи
//  ЭтоТабличнаяЧасть - Булево
// 
// Возвращаемое значение:
//  Строка
//
Функция НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_ТекстСвязиТаблиц(Знач ИмяМетаданныхВ1С, Знач ПолеСсылка, Знач ПоляДляСвязи, Знач ЭтоТабличнаяЧасть)

	ШаблонСвязи          = "vt.%1 = resTable.%1";
	ШаблонСвязиСФункцией = "%1(vt.%2, resTable.%2)";

	МассивСвязи = Новый Массив(); // Массив из Строка
	Если ЭтоТабличнаяЧасть Тогда

		МассивСвязи.Добавить(СтрШаблон(ШаблонСвязи, ПолеСсылка));
		МассивСвязи.Добавить(СтрШаблон(ШаблонСвязи, "_keyfield"));

	Иначе

		Для Каждого СтруктураПоля Из ПоляДляСвязи Цикл

			МассивСвязи.Добавить(СтрШаблон(ШаблонСвязи, СтруктураПоля.ИмяСтолбцаВPostgreSQL));
			Если СтруктураПоля.Свойство("ДополнительныеФункцииДляСвязи") И Не ПустаяСтрока(СтруктураПоля.ДополнительныеФункцииДляСвязи) Тогда
				МассивСвязи.Добавить(СтрШаблон(ШаблонСвязиСФункцией, СтруктураПоля.ДополнительныеФункцииДляСвязи, СтруктураПоля.ИмяСтолбцаВPostgreSQL));
			КонецЕсли;

		КонецЦикла;

	КонецЕсли;

	Возврат СтрСоединить(МассивСвязи, " AND ");

КонецФункции

// Параметры:
//  ДополнительныеПоляДляВозврата - Массив из Строка
//  ПолеСсылка - Строка
//  ИмяПомещеннойТаблицы - Строка
//  ИмяТаблицыPostgreSQL - Строка
//  ТекстСвязиТаблиц - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_ТолькоПоиск(Знач ДополнительныеПоляДляВозврата, Знач ПолеСсылка, Знач ИмяПомещеннойТаблицы, Знач ИмяТаблицыPostgreSQL, Знач ТекстСвязиТаблиц)

	ПоляДляВозврата = Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьРекурсивно(ДополнительныеПоляДляВозврата, Ложь); // Массив из Строка
	Если Не ПустаяСтрока(ПолеСсылка) Тогда
		ПоляДляВозврата.Добавить("lykov_RRefToUID(resTable." + ПолеСсылка + ") AS uid");
	КонецЕсли;

	Если ПоляДляВозврата.Количество() = 0 Тогда
		ПоляДляВозврата.Добавить("resTable.*");
	КонецЕсли;

	ШаблонБазовогоЗапроса =
	"SELECT DISTINCT
	|	%1
	|FROM %2 AS vt
	|	JOIN %3 AS resTable
	|		ON %4";

	Возврат СтрШаблон(ШаблонБазовогоЗапроса, СтрСоединить(ПоляДляВозврата, ","), ИмяПомещеннойТаблицы, ИмяТаблицыPostgreSQL, ТекстСвязиТаблиц);

КонецФункции

// Параметры:
//  ДополнительныеПоляДляВозврата - Массив из Строка
//  ПолеСсылка - Строка
//  МассивПолей - Массив из Строка
//  ТипОбновления - ПеречислениеСсылка.Спец_ТипыОбновленияТаблицыБазыДанных
//  НужноВернутьКлюч - Булево
// 
// Возвращаемое значение:
//  Строка
//
Функция НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_ПоляДляВозврата(Знач ДополнительныеПоляДляВозврата, Знач ПолеСсылка, Знач МассивПолей, Знач ТипОбновления, Знач НужноВернутьКлюч)

	ПоляДляВозврата = Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьРекурсивно(ДополнительныеПоляДляВозврата, Ложь); // Массив из Строка
	Если Не ПустаяСтрока(ПолеСсылка) Тогда

		Если МассивПолей.Найти(ПолеСсылка) = Неопределено
			 Или ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиОбновлятьНеСоздавать") Тогда

			ШаблонДляВозврата = "lykov_RRefToUID(resTable.%1) AS UID";

		Иначе

			ШаблонДляВозврата = "lykov_RRefToUID(COALESCE(resTable.%1, vt.%1)) AS UID";

		КонецЕсли;

		ПоляДляВозврата.Добавить(СтрШаблон(ШаблонДляВозврата, ПолеСсылка));

		Если НужноВернутьКлюч Тогда
			ПоляДляВозврата.Добавить("vt.postgresql_key AS postgresql_key");
		КонецЕсли;

	Иначе

		Если ТипОбновления = ПредопределенноеЗначение("Перечисление.Спец_ТипыОбновленияТаблицыБазыДанных.НайтиНеОбновлятьСоздавать") Тогда
			ПоляДляВозврата.Добавить("vt.*");
		Иначе
			ПоляДляВозврата.Добавить("resTable.*");
		КонецЕсли;

	КонецЕсли;

	Возврат СтрСоединить(ПоляДляВозврата, ",");

КонецФункции

// Параметры:
//  ВозвращатьРезультат - Булево
//  БазовыйЗапрос - Строка
//  ИмяТаблицыPostgreSQL - Строка
//  МассивПолейТаблицыДляЗаписи - Массив из Строка
//  КонфликтныеПоля - Строка
//  ПолеДляВозврата - Строка
//  ТекстСвязиТаблиц - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_НайтиНеОбновлятьСоздавать(Знач ВозвращатьРезультат, Знач БазовыйЗапрос, Знач ИмяТаблицыPostgreSQL, Знач МассивПолейТаблицыДляЗаписи, Знач КонфликтныеПоля, Знач ПолеДляВозврата, Знач ТекстСвязиТаблиц)

	Если ВозвращатьРезультат Тогда

		ШаблонТекстаЗапроса =
		"CREATE TEMPORARY TABLE vtTMP ON COMMIT DROP AS
		|(
		|	%1
		|)
		|;
		|
		|WITH resTable AS
		|(
		|	INSERT INTO %2 AS resTable (%3)
		|	SELECT %3 FROM vtTMP
		|	ON CONFLICT (%4) DO NOTHING
		|	RETURNING *
		|)
		|SELECT
		|	%5
		|FROM vtTMP AS vt
		|	LEFT JOIN resTable
		|		ON %6";

		Возврат СтрШаблон(ШаблонТекстаЗапроса,
						  БазовыйЗапрос,
						  ИмяТаблицыPostgreSQL,
						  СтрСоединить(МассивПолейТаблицыДляЗаписи, ","),
						  КонфликтныеПоля,
						  ПолеДляВозврата,
						  ТекстСвязиТаблиц);

	Иначе

		ШаблонТекстаЗапроса =
		"WITH vt AS
		|(
		|	%1
		|)
		|INSERT INTO %2 AS resTable (%3)
		|	SELECT %3 FROM vt
		|	ON CONFLICT (%4) DO NOTHING";

		Возврат СтрШаблон(ШаблонТекстаЗапроса, БазовыйЗапрос, ИмяТаблицыPostgreSQL, СтрСоединить(МассивПолейТаблицыДляЗаписи, ","), КонфликтныеПоля);

	КонецЕсли;

КонецФункции

// Параметры:
//  ВозвращатьРезультат - Булево
//  БазовыйЗапрос - Строка
//  ИмяТаблицыPostgreSQL - Строка
//  СтруктураРезультатПомещения - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//  КонфликтныеПоля - Строка
//  ПолеДляВозврата - Строка
//  ТекстСвязиТаблиц - Строка
//  ЭтоТабличнаяЧасть - Булево
//  ПолеСсылка - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_НайтиОбновлятьНеСоздавать(Знач ВозвращатьРезультат, Знач БазовыйЗапрос, Знач ИмяТаблицыPostgreSQL, Знач СтруктураРезультатПомещения, Знач КонфликтныеПоля, Знач ПолеДляВозврата, Знач ТекстСвязиТаблиц, Знач ЭтоТабличнаяЧасть, Знач ПолеСсылка)

	ШаблонSet = "%1 = vt.%1";

	МассивТекстДействия = Новый Массив(); // Массив из Строка
	Для Каждого ИмяКолонки Из СтруктураРезультатПомещения.МассивИменКолонокОбновлять Цикл

		МассивКолонок = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураРезультатПомещения.Поля, ИмяКолонки, Новый Массив()); // Массив из см. Спец_PostgreSQLКлиентСервер.ПодготовитьСтруктуруСтолбцаВPostgreSQL
		Для Каждого СтруктураПоля Из МассивКолонок Цикл
			МассивТекстДействия.Добавить(СтрШаблон(ШаблонSet, СтруктураПоля.ИмяСтолбцаВPostgreSQL));
		КонецЦикла;

	КонецЦикла;

	Если ЭтоТабличнаяЧасть Тогда

		ШаблонТекстаЗапроса =
		"CREATE TEMPORARY TABLE vtTMP ON COMMIT DROP AS
		|(
		|	%3
		|)
		|;
		|
		|WITH vtIDRref AS
		|(
		|	SELECT DISTINCT
		|		%6,
		|		_keyfield
		|	FROM vtTMP
		|)
		|DELETE FROM ONLY %1
		|WHERE
		|	%6 IN (SELECT DISTINCT %6 FROM vtIDRref)
		|	AND (%6, _keyfield) NOT IN (SELECT %6, _keyfield FROM vtIDRref)
		|;
		|
		|UPDATE ONLY %1 AS resTable SET
		|	%2
		|FROM
		|(
		|	SELECT * FROM vtTMP
		|) AS vt
		|WHERE
		|	%4
		|%5";

		Возврат СтрШаблон(ШаблонТекстаЗапроса,
						  ИмяТаблицыPostgreSQL,
						  СтрСоединить(МассивТекстДействия, ","),
						  БазовыйЗапрос,
						  ТекстСвязиТаблиц,
						  ?(ВозвращатьРезультат, "RETURNING " + ПолеДляВозврата, ""),
						  ПолеСсылка);

	ИначеЕсли ВозвращатьРезультат Тогда

		ШаблонТекстаЗапроса =
		"UPDATE ONLY %1 AS resTable SET
		|	%2
		|FROM
		|(
		|	%3
		|) AS vt
		|WHERE
		|	%4
		|RETURNING %5";

		Возврат СтрШаблон(ШаблонТекстаЗапроса, ИмяТаблицыPostgreSQL, СтрСоединить(МассивТекстДействия, ","), БазовыйЗапрос, ТекстСвязиТаблиц, ПолеДляВозврата);

	Иначе

		ШаблонТекстаЗапроса =
		"UPDATE ONLY %1 AS resTable SET
		|	%2
		|FROM
		|(
		|	%3
		|) AS vt
		|WHERE
		|	%4";

		Возврат СтрШаблон(ШаблонТекстаЗапроса, ИмяТаблицыPostgreSQL, СтрСоединить(МассивТекстДействия, ","), БазовыйЗапрос, ТекстСвязиТаблиц);

	КонецЕсли;

КонецФункции

// Параметры:
//  ВозвращатьРезультат - Булево
//  БазовыйЗапрос - Строка
//  ИмяТаблицыPostgreSQL - Строка
//  СтруктураРезультатПомещения - см. ПоместитьТаблицу1СВоВременнуюТаблицу
//  КонфликтныеПоля - Строка
//  ПолеДляВозврата - Строка
//  ТекстСвязиТаблиц - Строка
//  ЭтоТабличнаяЧасть - Булево
//  ПолеСсылка - Строка
//  МассивПолейТаблицыДляЗаписи - Массив из Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция НайтиСоздатьДанныеПоОбъекту1СВPostgreSQL_СформироватьТекстЗапроса_НайтиОбновлятьСоздавать(Знач ВозвращатьРезультат, Знач БазовыйЗапрос, Знач ИмяТаблицыPostgreSQL, Знач СтруктураРезультатПомещения, Знач КонфликтныеПоля, Знач ПолеДляВозврата, Знач ТекстСвязиТаблиц, Знач ЭтоТабличнаяЧасть, Знач ПолеСсылка, Знач МассивПолейТаблицыДляЗаписи)

	ШаблонSet = "%1 = EXCLUDED.%1";

	МассивТекстДействия = Новый Массив(); // Массив из Строка
	Для Каждого ИмяКолонки Из СтруктураРезультатПомещения.МассивИменКолонокОбновлять Цикл

		МассивКолонок = Спец_РаботаСКоллекциямиКлиентСервер.СвойствоСоответствия(СтруктураРезультатПомещения.Поля, ИмяКолонки, Новый Массив()); // Массив из см. Спец_PostgreSQLКлиентСервер.ПодготовитьСтруктуруСтолбцаВPostgreSQL
		Для Каждого СтруктураПоля Из МассивКолонок Цикл
			МассивТекстДействия.Добавить(СтрШаблон(ШаблонSet, СтруктураПоля.ИмяСтолбцаВPostgreSQL));
		КонецЦикла;

	КонецЦикла;

	МассивТекстЗапроса = Новый Массив(); // Массив из Строка

	НужнаВременнаяТаблица = ЭтоТабличнаяЧасть Или ВозвращатьРезультат;
	Если НужнаВременнаяТаблица Тогда

		МассивТекстЗапроса.Добавить(СтрШаблон("CREATE TEMPORARY TABLE vtTMP ON COMMIT DROP AS
											  |(
											  |	%1
											  |)", БазовыйЗапрос));

		Если ЭтоТабличнаяЧасть Тогда

			ШаблонУдаленияТаблицы =
			"WITH vtIDRref AS
			|(
			|	SELECT DISTINCT
			|		%2,
			|		_keyfield
			|	FROM vtTMP
			|)
			|DELETE FROM ONLY %1
			|WHERE
			|	%2 IN (SELECT DISTINCT %2 FROM vtIDRref)
			|	AND (%2, _keyfield) NOT IN (SELECT %2, _keyfield FROM vtIDRref)";

			МассивТекстЗапроса.Добавить(СтрШаблон(ШаблонУдаленияТаблицы, ИмяТаблицыPostgreSQL, ПолеСсылка));

		КонецЕсли;

	КонецЕсли;

	Если ВозвращатьРезультат Тогда

		ШаблонТекстаЗапроса =
		"WITH resTable AS
		|(
		|	INSERT INTO %1 AS resTable (%2)
		|	SELECT %2 FROM vtTMP
		|	ON CONFLICT (%3) DO UPDATE SET
		|		%4
		|	RETURNING *
		|)
		|SELECT
		|	%5
		|FROM vtTMP AS vt
		|	JOIN resTable
		|		ON %6";

		МассивТекстЗапроса.Добавить(СтрШаблон(ШаблонТекстаЗапроса,
											  ИмяТаблицыPostgreSQL,
											  СтрСоединить(МассивПолейТаблицыДляЗаписи, ","),
											  КонфликтныеПоля,
											  СтрСоединить(МассивТекстДействия, ","),
											  ПолеДляВозврата,
											  ТекстСвязиТаблиц));

	ИначеЕсли НужнаВременнаяТаблица Тогда

		ШаблонТекстаЗапроса =
		"INSERT INTO %1 AS resTable (%2)
		|SELECT %2 FROM vtTMP
		|ON CONFLICT (%3) DO UPDATE SET
		|	%4";

		МассивТекстЗапроса.Добавить(СтрШаблон(ШаблонТекстаЗапроса,
											  ИмяТаблицыPostgreSQL,
											  СтрСоединить(МассивПолейТаблицыДляЗаписи, ","),
											  КонфликтныеПоля,
											  СтрСоединить(МассивТекстДействия, ",")));

	Иначе

		ШаблонТекстаЗапроса =
		"WITH vt AS
		|(
		|	%1
		|)
		|INSERT INTO %2 AS resTable (%3)
		|SELECT %3 FROM vt
		|ON CONFLICT (%4) DO UPDATE SET
		|	%5";

		МассивТекстЗапроса.Добавить(СтрШаблон(ШаблонТекстаЗапроса,
											  БазовыйЗапрос,
											  ИмяТаблицыPostgreSQL,
											  СтрСоединить(МассивПолейТаблицыДляЗаписи, ","),
											  КонфликтныеПоля,
											  СтрСоединить(МассивТекстДействия, ",")));

	КонецЕсли;

	Возврат СтрСоединить(МассивТекстЗапроса, "
											 |;
											 |");

КонецФункции

#КонецОбласти

// Параметры:
//  ТекстСкрипта - Строка
//  Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Структура:
// 		* Успешно - Булево - Флаг успешности выполнения запроса
// 		* РезультатЗапроса - Массив из Структура:
// 			** sizeObject - Число
// 		* ТекстОшибки - Строка - Если запрос не был выполнен, то в данном поле будет лежать текст ошибки
//
Функция ПолучитьРезультатЗапросаРазмерТаблицы(Знач ТекстСкрипта, Знач Кэш)

	//@skip-check constructor-function-return-section
	Возврат Спец_КомпонентаДополнительныеФункцииКлиентСервер.PostgreSQLВыполнитьЗапрос(ТекстСкрипта, , , Кэш);

КонецФункции

// Параметры:
//  ИмяПоля - Строка
//  ОписаниеТипов - ОписаниеТипов
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	- Неопределено
//	- Структура: см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
Функция СтруктураПоляПоОписаниюТипов(Знач ИмяПоля, Знач ОписаниеТипов, Знач Кэш)

	ОписаниеТиповДляПроверки = Новый ОписаниеТипов(ОписаниеТипов, , "NULL");

	КоличествоТипов = ОписаниеТиповДляПроверки.Типы().Количество();
	Спец_Проверить(КоличествоТипов = 1,
			"Нельзя составные типы (или пустой тип)",
			"Спец_PostgreSQLКлиентСервер.СтруктураПоляПоОписаниюТипов");
	
	Возврат СтруктураПоляПоТипуЗначения(ИмяПоля, ОписаниеТиповДляПроверки.Типы().Получить(0), Кэш);

КонецФункции

// Параметры:
//	ИмяПоля - Строка
//	ТипОбъекта - Тип
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	см. ПодготовитьСтруктуруСтолбцаВPostgreSQL
//
Функция СтруктураПоляПоТипуЗначения(Знач ИмяПоля, Знач ТипОбъекта, Знач Кэш)

	СтруктураПоля = ПодготовитьСтруктуруСтолбцаВPostgreSQL();
	Если ТипОбъекта = Тип("Строка") Тогда

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Строка");
		СтруктураПоля.ИмяТипаДанныхДляPostgreSQL = "mvarchar";

	ИначеЕсли ТипОбъекта = Тип("Число") Тогда

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число");
		СтруктураПоля.ИмяТипаДанныхДляPostgreSQL = "numeric";

	ИначеЕсли ТипОбъекта = Тип("Дата") Тогда

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата");
		СтруктураПоля.ИмяТипаДанныхДляPostgreSQL = "timestamp";

	ИначеЕсли ТипОбъекта = Тип("Булево") Тогда

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево");
		СтруктураПоля.ИмяТипаДанныхДляPostgreSQL = "boolean";

	Иначе

		СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Ссылочный");
		СтруктураПоля.НеNull = Истина;

		Если Спец_ОбщегоНазначенияКлиентСерверПовтИсп.ОписаниеТипаВсеСсылки().СодержитТип(ТипОбъекта) 
				Или ТипОбъекта = Тип("УникальныйИдентификатор") Тогда

			СтруктураПоля.ИмяТипаДанныхДляPostgreSQL = "mvarchar(36)";
			СтруктураПоля.ФункцияПреобразования = "lykov_UIDToRRef(%1)";

		ИначеЕсли Спец_РаботаСКоллекциямиКлиентСервер.ЭтоХранилищеЗначения(ТипОбъекта, Тип("Тип")) Или ТипОбъекта = Тип("ДвоичныеДанные") Тогда

			СтруктураПоля.ИмяТипаДанныхДляPostgreSQL = "text";
			СтруктураПоля.ФункцияПреобразования = "lykov_DDToBytea(%1)";

		Иначе

			СтруктураПоля.ИмяТипаДанныхДляPostgreSQL = "text";

		КонецЕсли;

	КонецЕсли;

	Возврат СтруктураПоля;

КонецФункции

// Параметры:
//	пЗначение - Произвольный
//	СтруктураКолонки - см. СтруктураПоляПоТипуЗначения
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//	Строка
//
Функция ЗначениеДляPostgreSQL_СоставнаяКолонка(Знач пЗначение, Знач СтруктураКолонки, Знач Кэш)

	ТипКолонки = ТипЗнч(пЗначение);
	Если СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Строка") Тогда

		Возврат ?(ТипКолонки = Тип("Строка"),
				  ПолучитьЗначениеДляPostgreSQL(пЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число") Тогда

		Возврат ?(ТипКолонки = Тип("Число"),
				  ПолучитьЗначениеДляPostgreSQL(пЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево") Тогда

		Возврат ?(ТипКолонки = Тип("Булево"),
				  ПолучитьЗначениеДляPostgreSQL(пЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата") Тогда

		Возврат ?(ТипКолонки = Тип("Дата"),
				  ПолучитьЗначениеДляPostgreSQL(пЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ДвоичныеДанные") Тогда

		Возврат ?(Спец_РаботаСКоллекциямиКлиентСервер.ЭтоХранилищеЗначения(пЗначение, ТипКолонки)
				  Или ТипКолонки = Тип("ДвоичныеДанные")
				  Или ТипКолонки = Тип("УникальныйИдентификатор"),
				  ПолучитьЗначениеДляPostgreSQL(пЗначение, ТипКолонки, Кэш),
				  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ИдентификаторСсылки") Тогда
		
		Возврат ?(Спец_ОбщегоНазначенияКлиентСервер.ЭтоСсылка(пЗначение, Кэш, ТипКолонки),
			  ПолучитьЗначениеДляPostgreSQL(пЗначение, ТипКолонки, Кэш),
			  ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(СтруктураКолонки));
		
	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.НомерТаблицы") Тогда

		ИмяМетаданныхПоТипу = Спец_ОбщегоНазначенияКлиентСервер.ИмяМетаданныхПоТипу(ТипКолонки, Кэш);
		Возврат ?(ПустаяСтрока(ИмяМетаданныхПоТипу),
				"0",
				ПолучитьЗначениеДляPostgreSQL(Спец_PostgreSQLВызовСервераПовтИсп.ПолучитьСтруктуруТаблицыПоИмениМетаданных(ИмяМетаданныхПоТипу).КодТаблицы,
																		  Тип("Число"),
																		  Кэш));

	ИначеЕсли СтруктураКолонки.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.ТипТаблицы") Тогда
		
		// Только простые типы пропишем
		Если ТипКолонки = Тип("Булево") Тогда
			Возврат "2";
		ИначеЕсли ТипКолонки = Тип("Число") Тогда
			Возврат "3";
		ИначеЕсли ТипКолонки = Тип("Дата") Тогда
			Возврат "4";
		ИначеЕсли ТипКолонки = Тип("Строка") Тогда
			Возврат "5";
		Иначе
			Возврат "8";
		КонецЕсли;

	Иначе

		Возврат "";

	КонецЕсли;

КонецФункции

// Параметры:
//  СтруктураПоля - см. СтруктураПоляПоТипуЗначения
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьЗначениеДляЗаписиВCSVПоУмолчанию(Знач СтруктураПоля)

	Если Не ЗначениеЗаполнено(СтруктураПоля.ТипСоставногоПоля) Тогда

		Если СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Булево") Тогда
			Возврат "false";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Дата") Тогда
			Возврат "0001-01-01 00:00:00";
		ИначеЕсли СтруктураПоля.ТипДанных = ПредопределенноеЗначение("Перечисление.Спец_ТипыДанныхБазыДанных.Число") Тогда
			Возврат "0";
		Иначе
			Возврат "";
		КонецЕсли;

	Иначе

		Если СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Дата") Тогда
			Возврат "0001-01-01 00:00:00";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Булево") Тогда
			Возврат "false";
		ИначеЕсли СтруктураПоля.ТипСоставногоПоля = ПредопределенноеЗначение("Перечисление.Спец_ТипыСоставныхПолейБазыДанных.Число") Тогда
			Возврат "0";
		Иначе
			Возврат "";
		КонецЕсли;

	КонецЕсли;

КонецФункции

// Параметры:
//  СтрокаСДанными - Структура
//  ТипСоставногоПоля - ПеречислениеСсылка.Спец_ТипыСоставныхПолейБазыДанных
//  ПоляСтолбца - ФиксированныйМассив из см. Спец_PostgreSQLКлиентСервер.ПодготовитьСтруктуруСтолбцаВPostgreSQL
//	Кэш - см. Спец_КлиентСерверГлобальный.Спец_ПолучитьКэш
// 
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьЗначениеПоСоставномуТипуИзСтроки(Знач СтрокаСДанными, Знач ТипСоставногоПоля, Знач ПоляСтолбца, Знач Кэш)

	СтруктураОтбора = Новый Структура("ТипСоставногоПоля", ТипСоставногоПоля);

	НужныйСтолбец = Спец_РаботаСКоллекциямиКлиентСервер.НайтиСтрокиВКоллекцииСтрок(СтруктураОтбора, ПоляСтолбца, Истина); // см. Спец_PostgreSQLКлиентСервер.ПодготовитьСтруктуруСтолбцаВPostgreSQL
	Если НужныйСтолбец = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	Возврат ?(Спец_РаботаСКоллекциямиКлиентСервер.ЕстьРеквизитОбъекта(СтрокаСДанными, НужныйСтолбец.ИмяСтолбцаВPostgreSQL, Кэш),
			  СтрокаСДанными[НужныйСтолбец.ИмяСтолбцаВPostgreSQL],
			  Неопределено);

КонецФункции

//@skip-check structure-consructor-too-many-keys
//@skip-check constructor-function-return-section
#Область Типизация

// Возвращаемое значение:
//	см. ПодготовитьСтруктуруПараметровДляПомещенияВоВременнуюТаблицу
//
Функция НоваяСтруктураПараметровДляПомещенияВоВременнуюТаблицу()
	
	Возврат Новый Структура(
			"МассивПолейДляВозврата,
			|МассивСтолбцовДляPostgreSQL,
			|МассивПолейДляЗапросаPostgreSQL,
			|СоответствиеКэшЭтоСоставное,
			|СоответствиеДляИсходныхДанных",
			Новый Массив(),
			Новый Массив(),
			Новый Массив(),
			Новый Соответствие(),
			Новый Соответствие());

КонецФункции

// Параметры:
//  ПоляPostgreSQL - ФиксированноеСоответствие из КлючИЗначение:
//		* Ключ - Строка
//		* Значение - ФиксированныйМассив из см. Спец_PostgreSQLКлиентСервер.ПодготовитьСтруктуруСтолбцаВPostgreSQL
// 
// Возвращаемое значение:
//	см. ПодготовитьПараметрыТаблицы1С
//
Функция НоваяСтруктураПараметровТаблицы1С(Знач ПоляPostgreSQL)
	
	Возврат Новый Структура("СоответствиеВсехПолейPostrgeSQL, МассивИменКолонокОбновлять, МассивКолонокДляЗначенияПоУмолчанию",
			Спец_РаботаСКоллекциямиКлиентСервер.СкопироватьСоответствие(ПоляPostgreSQL, Ложь),
			Новый Массив(),
			Новый Массив());
	
КонецФункции

#КонецОбласти

#КонецОбласти
